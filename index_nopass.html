<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="UTF-8">
    <title>Options Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.2.1/dist/chartjs-plugin-annotation.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.6.1/nouislider.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.6.1/nouislider.min.js"></script>
<style>
    body {
        font-family: Arial, sans-serif;
        background-color: #1A1A2E;
        color: #FFFFFF;
        margin: 0;
        padding: 0;
        display: flex;
        min-height: 100vh;
        font-size: clamp(12px, 2vw, 14px); /* Tightened clamp range for more consistent body text scaling */
    }
    .sidebar {
        width: clamp(200px, 20vw, 250px);
        background: #208191;
        padding: 15px;
        border-right: 1px solid #26A69A;
        box-shadow: 2px 0 10px rgba(0, 0, 0, 0.5);
        transition: transform 0.3s ease, width 0.3s ease;
        position: fixed;
        top: 0;
        left: 0;
        height: 100%;
        z-index: 1000;
    }
    .sidebar.hidden {
        transform: translateX(-100%);
        width: 0; /* Collapse width when hidden */
        padding: 0; /* Remove padding when hidden */
        overflow: hidden; /* Hide content when collapsed */
    }
    .sidebar-toggle {
        position: fixed;
        top: 10px;
        left: 10px;
        background-color: #208191;
        color: #FFFFFF;
        border: 1px solid #26A69A;
        border-radius: 4px;
        padding: 8px;
        cursor: pointer;
        z-index: 1001;
        font-size: clamp(12px, 2vw, 14px);
        display: block; /* Always visible, controlled by JS based on sidebar state */
    }
    .sidebar.hidden .sidebar-logo,
    .sidebar.hidden .header,
    .sidebar.hidden select,
    .sidebar.hidden input,
    .sidebar.hidden .toggle-button,
    .sidebar.hidden a {
        display: none; /* Hide all sidebar content when hidden */
    }
    .sidebar-logo {
        display: block;
        max-width: 100%;
        height: auto;
        margin: 0 auto 15px;
        border-radius: 4px;
    }
    .sidebar a {
        color: #26A69A;
        text-decoration: none;
        display: block;
        padding: 10px;
        font-size: clamp(12px, 2vw, 14px);
        transition: color 0.3s ease, background-color 0.3s ease;
        border-radius: 4px;
    }
    .sidebar a:hover {
        color: #FFFFFF;
        background-color: #4DB6AC;
    }
    .sidebar select, .sidebar input {
        width: 100%;
        padding: 8px;
        background-color: #208191;
        color: #FFFFFF;
        border: 1px solid #26A69A;
        border-radius: 4px;
        margin-bottom: 10px;
        font-size: clamp(12px, 2vw, 14px);
        transition: border-color 0.3s ease;
    }
    .sidebar select:focus, .sidebar input:focus {
        border-color: #4DB6AC;
        outline: none;
    }
    .main-content {
        flex: 1;
        padding: 15px;
        overflow-y: auto;
        background: #1A1A2E;
        margin-left: 10px; /* Fixed gap between sidebar and main content */
        width: calc(100% - clamp(200px, 20vw, 250px)); /* Adjust width to account for sidebar */
        box-sizing: border-box;
        transition: margin-left 0.3s ease, width 0.3s ease;
        overflow-x: auto; /* Enables horizontal scrolling for main content if needed */
    }
    .main-content.full-width {
        margin-left: 0;
        width: 100%;
    }
    .chart-container {
        background-color: #25253d;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 15px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        width: 100%;
        max-width: 100%; /* Ensures containers don't exceed parent width */
        box-sizing: border-box;
        overflow-x: auto; /* Enables horizontal scrolling for wide content */
        overflow-y: hidden; /* Prevents vertical overflow to avoid overlap */
    }
    .stats-table, .summary-table, .raw-data-table, .contracts-table, .ranking-table, .stock-table {
        border-collapse: collapse;
        width: 100%;
        max-width: 100%; /* Prevents tables from exceeding container width */
        margin-top: 10px;
        background-color: #25253d;
        font-size: clamp(9px, 1.8vw, 11px); /* Smaller font-size clamp for better fit on small screens */
        overflow-x: auto;
        display: block;
        table-layout: auto;
        min-width: 100%; /* Ensures tables fill container but can scroll */
        line-height: 1.3; /* Adjusted line-height to prevent text overlap */
    }
    .ranking-table th, .stock-table th, .contracts-table th {
        border: 1px solid #26A69A;
        background-color: #373758;
        font-weight: bold;
        cursor: pointer;
        white-space: nowrap; /* Keep nowrap for headers on larger screens */
        padding: clamp(4px, 1vw, 6px) clamp(2px, 0.5vw, 4px);
        text-align: left;
        color: #FFFFFF;
        line-height: 1.3; /* Adjusted to prevent overlap */
        min-width: 50px;
        font-size: clamp(9px, 1.8vw, 11px);
    }
    .stats-table th, .stats-table td, .summary-table th, .summary-table td,
    .ranking-table td, .raw-data-table th, .raw-data-table td,
    .contracts-table th, .contracts-table td, .stock-table th, .stock-table td {
        border: 1px solid #26A69A;
        padding: clamp(4px, 1vw, 6px);
        text-align: left;
        color: #FFFFFF;
        font-size: clamp(9px, 1.8vw, 11px);
        white-space: normal; /* Allows wrapping to reduce table width */
        line-height: 1.3; /* Prevents text overlap */
    }
    .stats-table th, .summary-table th, .raw-data-table th, .contracts-table th, .stock-table th {
        background-color: #373758;
        font-weight: bold;
        cursor: pointer;
    }
    .stats-table th:hover, .raw-data-table th:hover, .ranking-table th:hover, .contracts-table th:hover, .stock-table th:hover {
        background-color: #4B4B6F;
    }
    canvas {
        width: 100% !important;
        max-height: clamp(250px, 40vh, 350px); /* Tightened height range for consistency */
        min-height: clamp(200px, 30vh, 300px); /* Ensures consistent minimum height */
        border-radius: 4px;
        background-color: #25253d;
    }
    .header {
        text-align: center;
        padding: 10px;
        background-color: #208191;
        border-bottom: 1px solid #26A69A;
        font-size: clamp(14px, 2.5vw, 16px); /* Smaller clamp range for header text */
        font-weight: bold;
        color: #FFFFFF;
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
    }
    .ticker-display {
        font-size: clamp(12px, 2vw, 14px); /* Adjusted for better scaling */
        margin-bottom: 10px;
        color: #FFFFFF;
        text-align: center;
        background-color: #208191;
        padding: 8px;
        border-radius: 4px;
    }
    .select-container {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 8px;
        flex-wrap: wrap;
    }
    .arrow-button, .toggle-button {
        background-color: #208191;
        color: #FFFFFF;
        border: 1px solid #26A69A;
        border-radius: 4px;
        padding: 6px 10px;
        cursor: pointer;
        transition: background-color 0.3s ease;
        font-size: clamp(12px, 2vw, 14px);
    }
    .arrow-button:hover, .toggle-button:hover {
        background-color: #4DB6AC;
    }
    #historic-error {
        color: #F87171;
        padding: 8px;
        text-align: center;
        font-size: clamp(12px, 2vw, 14px);
    }
    .line-swatch {
        display: inline-block;
        vertical-align: middle;
        margin-right: 5px;
    }
    .overview-grid {
        display: grid;
        grid-template-columns: repeat(10, 1fr); /* 10 equal columns for precise control */
        grid-template-rows: auto auto; /* Two rows, auto-sized */
        gap: 20px; /* Increased gap for better spacing */
        max-width: 100%;
    }
    .overview-grid .historic-container {
        grid-column: span 7; /* Historic takes ~70% (7/10 columns) */
    }
    .overview-grid .summary-container {
        grid-column: span 3; /* Summary takes ~30% (3/10 columns) */
    }
    .overview-grid .contracts-container:nth-child(3) {
        grid-column: span 5; /* Top Volume takes 50% (5/10 columns) */
    }
    .overview-grid .contracts-container:nth-child(4) {
        grid-column: span 5; /* Open Interest takes 50% (5/10 columns) */
    }
    .volatility-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(clamp(350px, 35vw, 400px), 1fr)); /* Larger min-width for consistent plot sizes */
        gap: 20px; /* Increased gap to prevent overlap */
    }
    .ranking-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(clamp(300px, 30vw, 350px), 1fr));
        gap: 20px; /* Increased gap */
    }
    #call-vol-surface {
        width: 100% !important;
        max-height: clamp(250px, 40vh, 350px); /* Consistent with canvas */
        min-height: clamp(200px, 30vh, 300px); /* Ensures uniform size */
        min-width: 100%; /* Ensures it fills container */
    }
    .slider-container {
        margin-top: 10px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        justify-content: center;
        align-items: center;
    }
    .slider-group {
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: flex-start;
        width: 100%;
    }
    .noUi-target {
        background: linear-gradient(to right, #26A69A, #4DB6AC);
        border: none;
        border-radius: 5px;
        height: 8px;
        width: 100%;
    }
    .noUi-connect {
        background: #26A69A;
    }
    .noUi-handle {
        width: 15px;
        height: 15px;
        background: #FFFFFF;
        border: 2px solid #26A69A;
        border-radius: 50%;
        box-shadow: 0 0 5px rgba(38, 166, 154, 0.5);
        cursor: pointer;
    }
    .slider-value {
        margin-top: 5px;
        color: #4DB6AC;
        font-weight: bold;
        font-size: clamp(12px, 2vw, 14px);
    }
    .error-message {
        color: #F87171;
        text-align: center;
        padding: 8px;
        font-size: clamp(12px, 2vw, 14px);
    }
    .chart-container h2, .chart-container h3 {
        margin-bottom: 10px;
        text-align: center;
        font-size: clamp(12px, 2vw, 14px); /* Smaller font-size for chart titles to fit better */
        line-height: 1.3; /* Prevents overlap */
    }
    @media (max-width: 1024px) {
        .volatility-grid {
            grid-template-columns: 1fr; /* Single column to prevent squishing on medium screens */
        }
        .overview-grid, .ranking-grid {
            grid-template-columns: 1fr; /* Single column for consistency on medium screens */
            grid-template-rows: auto auto auto auto; /* Four rows for stacking */
        }
        .overview-grid .historic-container { grid-column: span 1; }
        .overview-grid .summary-container { grid-column: span 1; }
        .overview-grid .contracts-container:nth-child(3) { grid-column: span 1; }
        .overview-grid .contracts-container:nth-child(4) { grid-column: span 1; }
    }
    @media (max-width: 768px) {
        .sidebar {
            transform: translateX(-100%);
            width: clamp(180px, 80vw, 200px);
        }
        .sidebar.visible {
            transform: translateX(0);
        }
        .sidebar-toggle {
            display: block; /* Ensure visible on small screens */
        }
        .main-content {
            margin-left: 0;
            width: 100%;
        }
        .main-content.full-width {
            margin-left: 0;
            width: 100%;
        }
        .overview-grid, .volatility-grid, .ranking-grid {
            grid-template-columns: 1fr;
            grid-template-rows: auto auto auto auto; /* Stack vertically on small screens */
        }
        .overview-grid .historic-container { grid-column: span 1; }
        .overview-grid .summary-container { grid-column: span 1; }
        .overview-grid .contracts-container:nth-child(3) { grid-column: span 1; }
        .overview-grid .contracts-container:nth-child(4) { grid-column: span 1; }
        .chart-container {
            padding: 10px;
            margin-bottom: 10px;
        }
        canvas, #call-vol-surface {
            max-height: clamp(200px, 35vh, 300px);
            min-height: clamp(180px, 30vh, 250px); /* Consistent sizing on smaller screens */
        }
        .stats-table, .summary-table, .raw-data-table, .contracts-table, .ranking-table, .stock-table {
            font-size: clamp(8px, 1.6vw, 10px); /* Smaller text for better fit */
            line-height: 1.2;
        }
        .ranking-table th, .stock-table th, .contracts-table th {
            padding: clamp(3px, 0.8vw, 4px) clamp(2px, 0.4vw, 3px);
            min-width: 40px;
            font-size: clamp(8px, 1.6vw, 10px);
            white-space: normal; /* Allow header wrapping to reduce width */
        }
        .stats-table th, .stats-table td, .summary-table th, .summary-table td,
        .ranking-table td, .raw-data-table th, .raw-data-table td,
        .contracts-table th, .contracts-table td, .stock-table th, .stock-table td {
            padding: clamp(3px, 0.8vw, 4px);
            white-space: normal;
        }
        .chart-container h2, .chart-container h3 {
            font-size: clamp(11px, 1.8vw, 13px); /* Smaller titles on small screens */
        }
    }
    @media (max-width: 480px) {
        .sidebar {
            width: 100%;
        }
        .chart-container {
            padding: 8px;
        }
        canvas, #call-vol-surface {
            max-height: clamp(180px, 30vh, 250px);
            min-height: clamp(160px, 25vh, 220px); /* Further reduced for very small screens */
        }
        .stats-table, .summary-table, .raw-data-table, .contracts-table, .ranking-table, .stock-table {
            font-size: clamp(7px, 1.5vw, 9px); /* Even smaller text for tiny screens */
            line-height: 1.2;
        }
        .ranking-table th, .stock-table th, .contracts-table th {
            padding: clamp(2px, 0.6vw, 3px) clamp(1px, 0.3vw, 2px);
            min-width: 30px;
            font-size: clamp(7px, 1.5vw, 9px);
            white-space: normal;
        }
        .stats-table th, .stats-table td, .summary-table th, .summary-table td,
        .ranking-table td, .raw-data-table th, .raw-data-table td,
        .contracts-table th, .contracts-table td, .stock-table th, .stock-table td {
            padding: clamp(2px, 0.6vw, 3px);
            white-space: normal;
        }
        .chart-container h2, .chart-container h3 {
            font-size: clamp(10px, 1.6vw, 12px);
        }
    }
    .selected-ticker-row {
        background-color: #4B4B6F !important; /* Subtle highlight for selected ticker row in ranking table */
    }
    .selected-ticker-row td {
        background-color: #4B4B6F !important;
    }
    #selected-ticker-summary {
        margin-bottom: 15px;
    }
    #selected-ticker-table {
        margin-top: 10px;
        background-color: #25253d;
        border-collapse: collapse;
        width: 100%;
        max-width: 100%;
        font-size: clamp(9px, 1.8vw, 11px);
        line-height: 1.3;
    }
    #selected-ticker-table th, #selected-ticker-table td {
        border: 1px solid #26A69A;
        padding: clamp(4px, 1vw, 6px);
        text-align: left;
        color: #FFFFFF;
        font-size: clamp(9px, 1.8vw, 11px);
        white-space: normal;
    }
    #selected-ticker-table th {
        background-color: #373758;
        font-weight: bold;
    }
    #selected-ticker-table th:hover {
        background-color: #4B4B6F;
    }
</style>
</head>
<body>
    <button class="sidebar-toggle" onclick="toggleSidebar()">☰</button>
    <div class="sidebar hidden">
        <img src="logo.webp" alt="Fourier Asset Management" class="sidebar-logo">
        <div class="header">Options Analysis</div>
        <select id="date-select"></select>
        <select id="time-select"></select>
        <input type="text" id="ticker-search" list="ticker-datalist" placeholder="Search Ticker...">
        <datalist id="ticker-datalist"></datalist>
        <button class="toggle-button" onclick="toggleStatsTables()">Show Stats Tables</button>
        <a href="#overview">Overview</a>
        <a href="#volatility">Volatility</a>
        <a href="#ranking">Ranking</a>
        <a href="#stock">Stock</a>
        <a href="#data-table">Data Table</a>
    </div>
    <div class="main-content">
        <div class="ticker-display" id="ticker-display">N/A</div>
            <div id="selected-ticker-summary" class="chart-container" style="display: none;">
                <h3>Selected Ticker Ranking Summary</h3>
                <table id="selected-ticker-table" class="ranking-table"></table>
            </div>
            <div id="overview" class="overview-grid">
                <div class="chart-container historic-container">
                    <h2>Historic Stock Price</h2>
                    <div class="select-container">
                        <label for="historic-start-date">Start Date: </label>
                        <input type="date" id="historic-start-date">
                        <label for="historic-end-date">End Date: </label>
                        <input type="date" id="historic-end-date">
                    </div>
                    <canvas id="historic-price-chart"></canvas>
                    <div id="historic-error" class="error-message" style="display: none;">No historic data available</div>
                </div>
                <div class="chart-container summary-container">
                    <h2>Summary</h2>
                    <table id="summary-table" class="summary-table"></table>
                </div>
                <div class="chart-container contracts-container">
                    <h2>Top 10 Volume Contracts</h2>
                    <table id="top-volume-table" class="contracts-table"></table>
                </div>
                <div class="chart-container contracts-container">
                    <h2>Top 10 Open Interest Contracts</h2>
                    <table id="top-open-interest-table" class="contracts-table"></table>
                </div>
            </div>
        <div id="volatility" class="volatility-grid" style="display: none;">
            <div class="chart-container">
                <h3>Implied Volatility Smile</h3>
                <div class="select-container">
                    <label for="expiry-select">Select Expiry: </label>
                    <select id="expiry-select"></select>
                </div>
                <canvas id="moneyness-vs-iv-chart"></canvas>
                <div id="moneyness-error" class="error-message" style="display: none;">No data available</div>
            </div>
            <div class="chart-container">
            <h3>Implied Volatility Term Structure</h3>
            <div class="select-container">
                <label for="moneyness-select">Select Moneyness: </label>
                <select id="moneyness-select"></select>
            </div>
            <div class="select-container">
                <label for="term-min-expiry">Min Expiry: </label>
                <input type="date" id="term-min-expiry">
                <label for="term-max-expiry">Max Expiry: </label>
                <input type="date" id="term-max-expiry">
            </div>
            <canvas id="expiry-vs-iv-chart"></canvas>
            <div id="expiry-error" class="error-message" style="display: none;">No data available</div>
        </div>
            <div class="chart-container">
                <h3>Volatility Skewness</h3>
                <div class="select-container">
                    <label for="skew-min-expiry">Min Expiry: </label>
                    <input type="date" id="skew-min-expiry">
                    <label for="skew-max-expiry">Max Expiry: </label>
                    <input type="date" id="skew-max-expiry">
                </div>
                <div class="select-container">
                    <label for="skew-metric-select">Select Skew Metrics (Multi): </label>
                    <select id="skew-metric-select" multiple>
                        <option value="Skew_25_delta" selected>Skew 25 Delta</option>
                        <option value="Skew_75_delta" selected>Skew 75 Delta</option>
                        <option value="Skew_90_Moneyness" selected>Skew 90 Moneyness</option>
                        <option value="Skew_80_Moneyness" selected>Skew 80 Moneyness</option>
                        <option value="Skew_70_Moneyness" selected>Skew 70 Moneyness</option>
                        <option value="Skew_90_Moneyness_Vol" selected>Skew 90 Moneyness Vol</option>
                        <option value="Skew_80_Moneyness_Vol" selected>Skew 80 Moneyness Vol</option>
                        <option value="Skew_70_Moneyness_Vol" selected>Skew 70 Moneyness Vol</option>
                    </select>
                </div>
                <canvas id="skew-vs-expiry-chart"></canvas>
                <div id="skew-error" class="error-message" style="display: none;">No data available</div>
            </div>
            <div class="chart-container">
            <h3>Realised Volatility</h3>
            <div class="select-container">
                <label for="realised-start-date">Start Date: </label>
                <input type="date" id="realised-start-date">
                <label for="realised-end-date">End Date: </label>
                <input type="date" id="realised-end-date">
            </div>
            <div class="select-container">
                <label for="realised-vol-metric-select">Select Volatility Metrics (Multi): </label>
                <select id="realised-vol-metric-select" multiple>
                    <option value="Realised_Vol_Close_30" selected>30-day Vol</option>
                    <option value="Realised_Vol_Close_60" selected>60-day Vol</option>
                    <option value="Realised_Vol_Close_100" selected>100-day Vol</option>
                    <option value="Realised_Vol_Close_180" selected>180-day Vol</option>
                    <option value="Realised_Vol_Close_252" selected>252-day Vol</option>
                </select>
            </div>
            <canvas id="realised-vol-chart"></canvas>
            <div id="realised-vol-error" class="error-message" style="display: none;">No data available</div>
        </div>
            <div class="chart-container">
                <h3>Call Volatility Surface</h3>
                <div class="slider-container">
                    <div class="slider-group">
                        <label>Moneyness Range: <div id="moneyness-slider" class="pretty-slider"></div>
                            <span id="moneyness-value" class="slider-value">0.6 - 2.5</span></label>
                        <label>Expiry (T) Range: <div id="expiry-t-slider" class="pretty-slider"></div>
                            <span id="expiry-t-value" class="slider-value">0.2 - 5.0</span></label>
                    </div>
                </div>
                <div id="call-vol-surface" style="height: 100%; width: 100%;"></div>
                <div id="surface-error" class="error-message" style="display: none;">No data available</div>
            </div>
            <div class="chart-container">
                <h3>Kurtosis</h3>
                <div class="select-container">
                    <label for="kurtosis-start-date">Start Date: </label>
                    <input type="date" id="kurtosis-start-date">
                    <label for="kurtosis-end-date">End Date: </label>
                    <input type="date" id="kurtosis-end-date">
                </div>
                <div class="select-container">
                    <label for="kurtosis-type-select">Select Kurtosis Type: </label>
                    <select id="kurtosis-type-select">
                        <option value="Kurtosis_Close_100d" selected>Close Prices</option>
                        <option value="Kurtosis_Returns_100d">Log Returns</option>
                    </select>
                </div>
                <canvas id="kurtosis-chart"></canvas>
                <div id="kurtosis-error" class="error-message" style="display: none;">No kurtosis data available</div>
            </div>
            <div class="chart-container">
                <h3>Volatility of Vol (100-day)</h3>
                <div class="select-container">
                    <label for="volofvol-start-date">Start Date: </label>
                    <input type="date" id="volofvol-start-date">
                    <label for="volofvol-end-date">End Date: </label>
                    <input type="date" id="volofvol-end-date">
                </div>
                <canvas id="vol-of-vol-chart"></canvas>
                <div id="vol-of-vol-error" class="error-message" style="display: none;">No volatility of volatility data available</div>
            </div>
           
        </div>
        <div id="ranking" class="chart-container" style="display: none;">
            <h2>Ticker Ranking</h2>
            <button class="toggle-button" onclick="toggleRankingTable()">Show Data</button>
            <table id="ranking-table" class="ranking-table" style="display: none;"></table>
            <div class="ranking-grid">
                <div class="chart-container">
                    <h3>Volume</h3>
                    <canvas id="volume-chart"></canvas>
                </div>
                <div class="chart-container">
                    <h3>Open Interest</h3>
                    <canvas id="open-interest-chart"></canvas>
                </div>
            </div>
        </div>
        <div id="stock" class="chart-container" style="display: none;">
            <h2>Stock Metrics</h2>
            <button class="toggle-button" onclick="toggleStockTable()">Show Data</button>
            <table id="stock-table" class="stock-table" style="display: none;"></table>
        </div>
        <div id="data-table" class="chart-container" style="display: none;">
            <h2>Data Table</h2>
            <table id="raw-data-table" class="raw-data-table"></table>
        </div>
    </div>
    <script>
        let data = [];
        let historicData = [];
        let cleanedData = [];
        let skewData = [];
        let slopeData = [];
        let eventsData = [];
        let rawData = [];
        let rankingData = [];
        let companyNames = [];
        let summaryData = [];
        let topVolumeData = [];
        let topOpenInterestData = [];
        let stockData = [];
        let uniqueExpiries = []; // Global to store unique expiries
        let moneynessChart, expiryChart, historicChart, volumeChart, openInterestChart, skewChart, realisedVolChart, kurtosisChart, volOfVolChart;
        let statsTablesVisible = false;
        let rankingTableVisible = false;
        let stockTableVisible = false;
        let lastLoadDataTimestamp = null;
        let loadDataTimeout = null;
        let lastTicker = null;
        function parseCSV(csvText) {
            try {
                const result = Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    dynamicTyping: true
                });
                return result.data;
            } catch (error) {
                console.error('Error parsing CSV:', error);
                return [];
            }
        }
        async function fetchWithErrorHandling(url, array) {
            try {
                const response = await fetch(`${url}?v=${Date.now()}`);
                if (!response.ok) throw new Error(`Failed to fetch ${url}: ${response.statusText}`);
                const parsedData = parseCSV(await response.text());
                array.splice(0, array.length, ...parsedData);
                if (parsedData.length > 0) {
                    console.log(`Sample row from ${url}:`, parsedData[0]);
                } else {
                    console.warn(`No data parsed from ${url}`);
                }
                console.log(`Data loaded from ${url}, size:`, array.length, 'sample:', array.slice(0, 5));
            } catch (error) {
                console.warn(`Error loading ${url}:`, error);
                array.splice(0, array.length);
                document.getElementById('historic-error').textContent = `Failed to load ${url}: ${error.message}`;
                document.getElementById('historic-error').style.display = 'block';
            }
        }
        function normalizeDate(dateStr) {
            try {
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) throw new Error('Invalid date');
                return date.toLocaleDateString('en-CA');
            } catch (error) {
                console.error('Error normalizing date:', dateStr, error);
                return null;
            }
        }
        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const mainContent = document.querySelector('.main-content');
            const toggleButton = document.querySelector('.sidebar-toggle');
            const sidebarWidth = sidebar.classList.contains('hidden') ? 'clamp(200px, 20vw, 250px)' : '0';
            sidebar.classList.toggle('hidden');
            sidebar.classList.toggle('visible');
            mainContent.classList.toggle('full-width');
            mainContent.style.marginLeft = sidebar.classList.contains('hidden') ? '0' : sidebarWidth;
            mainContent.style.width = sidebar.classList.contains('hidden') ? '100%' : `calc(100% - ${sidebarWidth})`;
            toggleButton.textContent = sidebar.classList.contains('hidden') ? '☰' : '✕'; // Update icon based on state
        }
        function toggleStatsTables() {
            try {
                statsTablesVisible = !statsTablesVisible;
                document.querySelectorAll('.stats-table:not(#historic-price-chart + .stats-table)').forEach(table => {
                    table.style.display = statsTablesVisible ? 'table' : 'none';
                });
                document.querySelector('.toggle-button:not(#ranking .toggle-button)').textContent = statsTablesVisible ? 'Hide Stats Tables' : 'Show Stats Tables';
                console.log(`Stats tables visibility set to: ${statsTablesVisible}`);
            } catch (error) {
                console.error('Error in toggleStatsTables:', error);
            }
        }
        function toggleRankingTable() {
            try {
                rankingTableVisible = !rankingTableVisible;
                const table = document.getElementById('ranking-table');
                table.style.display = rankingTableVisible ? 'table' : 'none';
                document.querySelector('#ranking .toggle-button').textContent = rankingTableVisible ? 'Hide Data' : 'Show Data';
                if (rankingTableVisible) updateRankingTable();
                console.log(`Ranking table visibility set to: ${rankingTableVisible}`);
            } catch (error) {
                console.error('Error in toggleRankingTable:', error);
            }
        }
        function toggleStockTable() {
            try {
                stockTableVisible = !stockTableVisible;
                const table = document.getElementById('stock-table');
                table.style.display = stockTableVisible ? 'table' : 'none';
                document.querySelector('#stock .toggle-button').textContent = stockTableVisible ? 'Hide Data' : 'Show Data';
                if (stockTableVisible) updateStockTable();
                console.log(`Stock table visibility set to: ${stockTableVisible}`);
            } catch (error) {
                console.error('Error in toggleStockTable:', error);
            }
        }
        function debounce(func, wait) {
            let timeout;
            return function (...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }
        async function loadData(timestamp) {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase() || 'COIN';
                if (lastLoadDataTimestamp === timestamp && lastTicker === selectedTicker) {
                    console.log(`Skipping redundant loadData for ticker: ${selectedTicker}, timestamp: ${timestamp}`);
                    return Promise.resolve();
                }
                lastLoadDataTimestamp = timestamp;
                lastTicker = selectedTicker;
                clearTimeout(loadDataTimeout);
                document.getElementById('historic-error').textContent = 'Loading data...';
                document.getElementById('historic-error').style.display = 'block';
                const prefix = '_yfinance';
                console.log(`Loading data for timestamp: ${timestamp}, source: yfinance, ticker: ${selectedTicker}`);
                // Clear existing data
                data = [];
                rawData = [];
                skewData = [];
                slopeData = [];
                historicData = [];
                eventsData = [];
                rankingData = [];
                companyNames = [];
                cleanedData = [];
                summaryData = [];
                topVolumeData = [];
                topOpenInterestData = [];
                stockData = [];
       
                const checkFileExists = async (url) => {
                    try {
                        const response = await fetch(url, { method: 'HEAD' });
                        return response.ok;
                    } catch {
                        return false;
                    }
                };
       
                // Load company names from main directory (tab-separated)
                const companyNamesExists = await checkFileExists(`./company_names.txt`);
                if (companyNamesExists) {
                    await fetchWithErrorHandling(`./company_names.txt`, companyNames);
                    console.log('Company names loaded, size:', companyNames.length, 'sample:', companyNames.slice(0, 5));
                } else {
                    console.warn('Company names file not found: ./company_names.txt');
                }
       
                // Load table-specific data files
                const files = [
                    { url: `data/${timestamp}/tables/ranking/ranking_table${prefix}.csv`, array: rankingData },
                    { url: `data/${timestamp}/tables/stock/stock_table${prefix}.csv`, array: stockData },
                    { url: `data/${timestamp}/tables/summary/summary_table${prefix}.csv`, array: summaryData },
                    { url: `data/${timestamp}/tables/contracts/top_volume_table${prefix}.csv`, array: topVolumeData },
                    { url: `data/${timestamp}/tables/contracts/top_open_interest_table${prefix}.csv`, array: topOpenInterestData },
                    { url: `data/${timestamp}/processed${prefix}/processed${prefix}_${selectedTicker}.csv`, array: data },
                    { url: `data/${timestamp}/historic/historic_${selectedTicker}.csv`, array: historicData },
                    { url: `data/${timestamp}/skew_metrics${prefix}/skew_metrics${prefix}_${selectedTicker}.csv`, array: skewData },
                    { url: `data/${timestamp}/slope_metrics${prefix}/slope_metrics${prefix}_${selectedTicker}.csv`, array: slopeData },
                    { url: `data/${timestamp}/cleaned_yfinance/cleaned_yfinance_${selectedTicker}.csv`, array: cleanedData },
                    { url: `data/${timestamp}/raw${prefix}/raw${prefix}_${selectedTicker}.csv`, array: rawData },
                    { url: `data/Events.csv`, array: eventsData }
                ];
       
                const promises = files.map(file =>
                    checkFileExists(file.url).then(exists => {
                        if (exists) {
                            return fetchWithErrorHandling(file.url, file.array);
                        }
                        console.warn(`File not found: ${file.url}`);
                        file.array.length = 0; // Clear array safely
                        return Promise.resolve();
                    })
                );
       
                await Promise.all(promises);
       
                // Populate ticker datalist
                const tickerDatalist = document.getElementById('ticker-datalist');
                tickerDatalist.innerHTML = '';
                const uniqueTickers = [...new Set(rankingData.map(item => item.Ticker))].filter(val => val).sort();
                uniqueTickers.forEach(val => {
                    const option = document.createElement('option');
                    option.value = val;
                    tickerDatalist.appendChild(option);
                });
       
                // Validate selected ticker
                if (!uniqueTickers.includes(selectedTicker)) {
                    console.warn(`Selected ticker ${selectedTicker} not in ranking data, defaulting`);
                    const defaultTicker = uniqueTickers.includes('COIN') ? 'COIN' : uniqueTickers[0] || '';
                    document.getElementById('ticker-search').value = defaultTicker;
                    document.getElementById('ticker-display').textContent = `${defaultTicker || 'N/A'}`;
                    if (!defaultTicker) {
                        console.warn('No valid tickers available');
                        document.getElementById('historic-error').textContent = 'No valid tickers available';
                        return Promise.resolve();
                    }
                } else {
                    document.getElementById('ticker-display').textContent = `${selectedTicker || 'N/A'}`;
                }
       
                console.log('Data load complete:', {
                    data: data.slice(0, 5),
                    historicData: historicData.slice(0, 5),
                    skewData: skewData.slice(0, 5),
                    slopeData: slopeData.slice(0, 5),
                    rawData: rawData.slice(0, 5),
                    eventsData: eventsData.slice(0, 5),
                    rankingData: rankingData.slice(0, 5),
                    companyNames: companyNames.slice(0, 5),
                    cleanedData: cleanedData.slice(0, 5),
                    summaryData: summaryData.slice(0, 5),
                    topVolumeData: topVolumeData.slice(0, 5),
                    topOpenInterestData: topOpenInterestData.slice(0, 5),
                    stockData: stockData.slice(0, 5)
                });
       
                document.getElementById('historic-error').style.display = 'none';
                return Promise.resolve();
            } catch (error) {
                console.error('Error in loadData:', error);
                document.getElementById('ticker-search').value = '';
                document.getElementById('ticker-datalist').innerHTML = '';
                document.getElementById('ticker-display').textContent = 'N/A';
                data = [];
                rawData = [];
                skewData = [];
                slopeData = [];
                historicData = [];
                eventsData = [];
                rankingData = [];
                companyNames = [];
                cleanedData = [];
                summaryData = [];
                topVolumeData = [];
                topOpenInterestData = [];
                stockData = [];
                document.getElementById('historic-error').textContent = `Error loading data: ${error.message}`;
                document.getElementById('historic-error').style.display = 'block';
                return Promise.resolve();
            }
        }
       
        function calculateMarketSpread(ticker) {
            try {
                const selectedTicker = ticker.toUpperCase();
                console.log(`Calculating market spread for ${selectedTicker}. CleanedData length: ${cleanedData.length}`);
                if (cleanedData.length === 0) {
                    console.warn(`CleanedData is empty for ${selectedTicker}`);
                    return 'N/A';
                }
                const stockRows = cleanedData.filter(item => item.Ticker === selectedTicker && item['Bid Stock'] !== undefined && item['Ask Stock'] !== undefined);
                console.log(`Found ${stockRows.length} rows with Bid Stock and Ask Stock for ${selectedTicker}`);
                if (stockRows.length === 0) {
                    console.warn(`No stock bid/ask data found for ${selectedTicker} in cleanedData. Sample cleanedData[0]:`, cleanedData[0]);
                    return 'N/A';
                }
                const bid = parseFloat(stockRows[0]['Bid Stock']);
                const ask = parseFloat(stockRows[0]['Ask Stock']);
                console.log(`Bid for ${selectedTicker}: ${bid}, Ask: ${ask}`);
                const spread = Number.isFinite(ask) && Number.isFinite(bid) ? (ask - bid).toFixed(2) : 'N/A';
                console.log(`Market spread for ${selectedTicker}: ${spread}`);
                return spread;
            } catch (error) {
                console.error('Error calculating market spread:', error);
                return 'N/A';
            }
        }
       
        function calculateHistoricalSpreads(ticker) {
            try {
                const selectedTicker = ticker.toUpperCase();
                const filteredHistoric = historicData.filter(item => item.Ticker === selectedTicker && item.High !== undefined && item.Low !== undefined);
                if (!filteredHistoric.length) {
                    console.warn(`No OHLC data for ${selectedTicker} in historicData`);
                    return { '1y Spread': 'N/A', '3y Spread': 'N/A', '5y Spread': 'N/A' };
                }
                filteredHistoric.sort((a, b) => new Date(a.Date) - new Date(b.Date));
                const spreads = filteredHistoric.map(item => Number.isFinite(item.High) && Number.isFinite(item.Low) ? item.High - item.Low : null).filter(s => s !== null);
                if (spreads.length === 0) {
                    console.warn(`No valid spread data for ${selectedTicker} after filtering`);
                    return { '1y Spread': 'N/A', '3y Spread': 'N/A', '5y Spread': 'N/A' };
                }
                const recentSpreads = spreads.slice(-Math.min(spreads.length, 1260));
                const oneYearSpreads = recentSpreads.slice(-252);
                const threeYearSpreads = recentSpreads.slice(-756);
                const fiveYearSpreads = recentSpreads;
                const avg = arr => arr.length > 0 ? (arr.reduce((a, b) => a + b, 0) / arr.length).toFixed(2) : 'N/A';
                const result = {
                    '1y Spread': avg(oneYearSpreads),
                    '3y Spread': avg(threeYearSpreads),
                    '5y Spread': avg(fiveYearSpreads)
                };
                console.log(`Historical spreads (OHLC proxy) for ${selectedTicker}:`, result, `(Available days: ${spreads.length})`);
                return result;
            } catch (error) {
                console.error('Error calculating historical spreads:', error);
                return { '1y Spread': 'N/A', '3y Spread': 'N/A', '5y Spread': 'N/A' };
            }
        }
       
        function populateTickerSearch() {
            try {
                const tickerSearch = document.getElementById('ticker-search');
                const tickerDatalist = document.getElementById('ticker-datalist');
                tickerDatalist.innerHTML = '';
                const uniqueTickers = [...new Set(rankingData.map(item => item.Ticker))].filter(val => val).sort();
                uniqueTickers.forEach(val => {
                    const option = document.createElement('option');
                    option.value = val;
                    tickerDatalist.appendChild(option);
                });
                if (uniqueTickers.length > 0 && !tickerSearch.value) {
                    const defaultTicker = uniqueTickers.includes('COIN') ? 'COIN' : uniqueTickers[0];
                    tickerSearch.value = defaultTicker;
                    document.getElementById('ticker-display').textContent = `${defaultTicker}`;
                } else if (!uniqueTickers.length) {
                    console.warn('No tickers available for selection');
                    tickerSearch.value = '';
                    document.getElementById('ticker-display').textContent = 'N/A';
                    document.getElementById('historic-error').textContent = 'No tickers available';
                    document.getElementById('historic-error').style.display = 'block';
                }
                console.log('Ticker search populated, selected:', tickerSearch.value);
            } catch (error) {
                console.error('Error populating ticker search:', error);
                document.getElementById('historic-error').textContent = `Error populating ticker search: ${error.message}`;
                document.getElementById('historic-error').style.display = 'block';
            }
        }
       
        function updateDropdowns() {
            try {
                const tickerSearch = document.getElementById('ticker-search');
                if (!tickerSearch) throw new Error('Ticker search input not found');
                const selectedTicker = tickerSearch.value.toUpperCase() || 'COIN';
                const tickerData = data.filter(item => item.Ticker === selectedTicker && item.Moneyness && item.Expiry);
                console.log('Updating dropdowns for ticker:', selectedTicker, 'Data size:', tickerData.length);
        
                const moneynessSelect = document.getElementById('moneyness-select');
                const expirySelect = document.getElementById('expiry-select');
                if (!moneynessSelect || !expirySelect) {
                    throw new Error('Moneyness or expiry select element not found');
                }
        
                if (!tickerData.length) {
                    console.warn('No data for dropdowns, ticker:', selectedTicker);
                    moneynessSelect.innerHTML = '<option value="">No moneyness available</option>';
                    expirySelect.innerHTML = '<option value="">No expiries available</option>';
                    document.getElementById('historic-error').textContent = `No data available for ticker: ${selectedTicker}`;
                    document.getElementById('historic-error').style.display = 'block';
                    return;
                }
        
                const prevMoneyness = moneynessSelect.value || '';
                const prevExpiry = expirySelect.value || '';
        
                const uniqueRoundedMoneyness = [...new Set(tickerData
                    .filter(item => Number.isFinite(item.Moneyness))
                    .map(item => Math.round(item.Moneyness * 100 / 10) * 0.1))]
                    .sort((a, b) => a - b);
                moneynessSelect.innerHTML = '';
                if (uniqueRoundedMoneyness.length === 0) {
                    moneynessSelect.innerHTML = '<option value="">No moneyness available</option>';
                } else {
                    uniqueRoundedMoneyness.forEach(val => {
                        const option = document.createElement('option');
                        option.value = val;
                        option.text = `${(val * 100).toFixed(0)}%`;
                        moneynessSelect.appendChild(option);
                    });
                    const targetMoneyness = 1.0;
                    let closestMoneyness = uniqueRoundedMoneyness[0];
                    if (uniqueRoundedMoneyness.length > 0) {
                        closestMoneyness = uniqueRoundedMoneyness.reduce((prev, curr) =>
                            Math.abs(curr - targetMoneyness) < Math.abs(prev - targetMoneyness) ? curr : prev
                        );
                    }
                    if (prevMoneyness && uniqueRoundedMoneyness.map(String).includes(prevMoneyness)) {
                        moneynessSelect.value = prevMoneyness;
                    } else if (uniqueRoundedMoneyness.includes(targetMoneyness)) {
                        moneynessSelect.value = targetMoneyness.toString();
                    } else if (uniqueRoundedMoneyness.length > 0) {
                        moneynessSelect.value = closestMoneyness.toString();
                    } else {
                        moneynessSelect.value = '';
                    }
                }
                console.log('Moneyness dropdown updated, selected:', moneynessSelect.value);
        
                const datasetDate = new Date(document.getElementById('date-select').value.replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3'));
                uniqueExpiries = [...new Set(tickerData
                    .filter(item => item.Expiry && !isNaN(new Date(item.Expiry).getTime()))
                    .map(item => item.Expiry))]
                    .sort((a, b) => new Date(a) - new Date(b));
                expirySelect.innerHTML = '';
                if (uniqueExpiries.length === 0) {
                    expirySelect.innerHTML = '<option value="">No expiries available</option>';
                    console.warn('No valid expiries found for ticker:', selectedTicker);
                } else {
                    uniqueExpiries.forEach(val => {
                        const option = document.createElement('option');
                        option.value = val;
                        option.text = new Date(val).toLocaleDateString('en-GB');
                        expirySelect.appendChild(option);
                    });
                    const targetExpiry = new Date(datasetDate);
                    targetExpiry.setDate(targetExpiry.getDate() + 90);
                    let closestExpiry = uniqueExpiries[0];
                    let minDiff = Infinity;
                    uniqueExpiries.forEach(expiry => {
                        const expiryDate = new Date(expiry);
                        const diffDays = Math.abs((expiryDate - targetExpiry) / (1000 * 60 * 60 * 24));
                        if (diffDays < minDiff) {
                            minDiff = diffDays;
                            closestExpiry = expiry;
                        }
                    });
                    if (prevExpiry && uniqueExpiries.includes(prevExpiry)) {
                        expirySelect.value = prevExpiry;
                    } else if (closestExpiry) {
                        expirySelect.value = closestExpiry;
                    } else {
                        expirySelect.value = '';
                    }
                }
                console.log('Expiry dropdown updated, selected:', expirySelect.value);
        
                if (uniqueExpiries.length > 0) {
                    const minExpDate = new Date(Math.min(...uniqueExpiries.map(e => new Date(e))));
                    const maxExpDate = new Date(Math.max(...uniqueExpiries.map(e => new Date(e))));
                    const minExpStr = minExpDate.toISOString().split('T')[0];
                    const maxExpStr = maxExpDate.toISOString().split('T')[0];
                    document.getElementById('term-min-expiry').value = minExpStr;
                    document.getElementById('term-max-expiry').value = maxExpStr;
                    document.getElementById('skew-min-expiry').value = minExpStr;
                    document.getElementById('skew-max-expiry').value = maxExpStr;
                }
        
                if (historicData.length > 0) {
                    const minHistDate = new Date(Math.min(...historicData.map(item => new Date(item.Date))));
                    const maxHistDate = new Date(Math.max(...historicData.map(item => new Date(item.Date))));
                    const minHistStr = minHistDate.toISOString().split('T')[0];
                    const maxHistStr = maxHistDate.toISOString().split('T')[0];
                    document.getElementById('historic-start-date').value = minHistStr;
                    document.getElementById('historic-end-date').value = maxHistStr;
                    document.getElementById('realised-start-date').value = minHistStr;
                    document.getElementById('realised-end-date').value = maxHistStr;
                    document.getElementById('kurtosis-start-date').value = minHistStr;
                    document.getElementById('kurtosis-end-date').value = maxHistStr;
                    document.getElementById('volofvol-start-date').value = minHistStr;
                    document.getElementById('volofvol-end-date').value = maxHistStr;
                }
            } catch (error) {
                console.error('Error updating dropdowns:', error);
                document.getElementById('historic-error').textContent = `Error updating dropdowns: ${error.message}`;
                document.getElementById('historic-error').style.display = 'block';
            }
        }
       
        function updateSkewVsExpiry() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                let filteredSkewData = skewData.filter(item => item.Ticker && item.Ticker.toUpperCase() === selectedTicker);
                const skewMinInput = document.getElementById('skew-min-expiry').value;
                const skewMaxInput = document.getElementById('skew-max-expiry').value;
                const skewMin = skewMinInput ? new Date(skewMinInput) : new Date(Math.min(...uniqueExpiries.map(e => new Date(e))));
                const skewMax = skewMaxInput ? new Date(skewMaxInput) : new Date(Math.max(...uniqueExpiries.map(e => new Date(e))));
                filteredSkewData = filteredSkewData.filter(item => {
                    const expDate = new Date(item.Expiry);
                    return expDate >= skewMin && expDate <= skewMax;
                });
                const errorDiv = document.getElementById('skew-error');
                errorDiv.style.display = 'none';
                if (!filteredSkewData.length) {
                    console.warn('No data for Skew vs. Expiry chart:', { ticker: selectedTicker });
                    if (skewChart) skewChart.destroy();
                    errorDiv.textContent = 'No skew data available';
                    errorDiv.style.display = 'block';
                    return;
                }
                const skewSelect = document.getElementById('skew-metric-select');
                const selectedMetrics = Array.from(skewSelect.selectedOptions).map(opt => opt.value);
                if (selectedMetrics.length === 0) {
                    selectedMetrics.push('Skew_25_delta');
                }
                const colors = ['#FFA500', '#00FF00', '#FF0000', '#26A69A', '#800080', '#00FFFF', '#FF69B4', '#4B0082'];
                const datasets = selectedMetrics.map((metric, idx) => ({
                    label: metric.replace(/_/g, ' '),
                    data: aggregateDataByX(filteredSkewData, 'Expiry', metric),
                    borderColor: colors[idx % colors.length],
                    backgroundColor: `rgba(${parseInt(colors[idx % colors.length].slice(1,3),16)}, ${parseInt(colors[idx % colors.length].slice(3,5),16)}, ${parseInt(colors[idx % colors.length].slice(5,7),16)}, 0.2)`,
                    pointRadius: 3,
                    pointStyle: 'circle',
                    fill: true,
                    showLine: true,
                    borderDash: [],
                    yAxisID: 'y'
                }));
                if (skewChart) skewChart.destroy();
                const canvas = document.getElementById('skew-vs-expiry-chart');
                if (!canvas.getContext('2d')) {
                    throw new Error('Canvas context not available for skew-vs-expiry-chart');
                }
                skewChart = new Chart(canvas.getContext('2d'), {
                    type: 'line',
                    data: { datasets },
                    options: {
                        plugins: { legend: { labels: { color: '#FFFFFF' } } },
                        scales: {
                            x: {
                                type: 'time',
                                time: { unit: 'day' },
                                title: { display: true, text: 'Expiry Date', color: '#FFFFFF' },
                                grid: { display: false },
                                ticks: { color: '#FFFFFF' }
                            },
                            y: {
                                title: { display: true, text: 'Skew', color: '#FFFFFF' },
                                beginAtZero: false,
                                grid: { display: false },
                                ticks: { color: '#FFFFFF' }
                            }
                        },
                        backgroundColor: '#1A1A2E'
                    }
                });
                createStatsTable(skewChart, 'skew-vs-expiry-chart');
            } catch (error) {
                console.error('Error updating Skew vs Expiry chart:', error);
                document.getElementById('skew-error').textContent = `Error rendering chart: ${error.message}`;
                document.getElementById('skew-error').style.display = 'block';
            }
        }
       
        function updateSummaryTable() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase() || 'COIN';
                const table = document.getElementById('summary-table');
                table.innerHTML = '';
                const filteredData = summaryData.filter(row => row.Ticker === selectedTicker);
                if (filteredData.length === 0) {
                    table.innerHTML = '<tr><td colspan="2">No summary data available</td></tr>';
                    console.warn('No summary data for ticker:', selectedTicker);
                    return;
                }
                const row = filteredData[0];
                const thead = document.createElement('thead');
                const headerRow = thead.insertRow();
                ['Metric', 'Value'].forEach(col => {
                    const th = document.createElement('th');
                    th.textContent = col;
                    th.style.textAlign = col === 'Metric' ? 'left' : 'right';
                    th.style.color = '#FFFFFF';
                    headerRow.appendChild(th);
                });
                table.appendChild(thead);
                const tbody = document.createElement('tbody');
                const metrics = [
                    'Latest Close ($)', 'Open ($)', 'Low ($)', 'High ($)', 'Daily Volume',
                    'Close 1d (%)', 'Close 1w (%)', 'Realised Volatility 100d (%)',
                    'Weighted IV (%)', 'Weighted IV 1d (%)', 'Weighted IV 1w (%)',
                    'Volume 1d (%)', 'Volume 1w (%)', 'Open Interest', 'OI 1d (%)',
                    'OI 1w (%)', 'ATM 12m/3m Ratio', 'Volume Rank', 'Open Interest Rank'
                ];
                const displayNameMap = {
                    'Realised Volatility 100d (%)': 'RVol 100d (%)',
                    'Weighted IV (%)': 'WIVol (%)',
                    'Weighted IV 1d (%)': 'WIVol 1d (%)',
                    'Weighted IV 1w (%)': 'WIVol 1w (%)',
                    'ATM 12m/3m Ratio': 'ATM 12m/3m Ratio',
                    'Volume Rank': 'Volume Rank',
                    'Open Interest Rank': 'Open Interest Rank'
                };
                metrics.forEach(metric => {
                    const tr = tbody.insertRow();
                    const metricCell = tr.insertCell();
                    metricCell.textContent = displayNameMap[metric] || metric.replace(/Realised Volatility/g, 'RVol').replace(/Weighted IV/g, 'WIVol').replace(/IV/g, 'IVol');
                    metricCell.style.textAlign = 'left';
                    metricCell.style.color = '#FFFFFF';
                    const valueCell = tr.insertCell();
                    let value = row[metric];
                    if (Number.isFinite(value)) {
                        if (metric === 'Daily Volume' || metric === 'Open Interest') {
                            value = parseInt(value).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
                        } else {
                            value = value.toFixed(2);
                        }
                    } else {
                        value = value || 'N/A';
                    }
                    valueCell.textContent = value;
                    valueCell.style.textAlign = 'right';
                    valueCell.style.color = '#FFFFFF';
                    const isPercentChange = [
                        'Close 1d (%)', 'Close 1w (%)', 'Weighted IV 1d (%)', 'Weighted IV 1w (%)',
                        'Volume 1d (%)', 'Volume 1w (%)', 'OI 1d (%)', 'OI 1w (%)'
                    ].includes(metric);
                    if (isPercentChange && Number.isFinite(parseFloat(value)) && value !== 'N/A') {
                        const val = parseFloat(value);
                        valueCell.style.color = val < 0 ? '#F87171' : val > 0 ? '#10B981' : '#FFFFFF';
                    }
                    if (row[`${metric}_Color`]) {
                        valueCell.style.color = row[`${metric}_Color`];
                    }
                });
                table.appendChild(tbody);
                console.log('Summary table updated with metrics:', metrics.map(m => ({ name: m, value: row[m] || 'N/A' })));
            } catch (error) {
                console.error('Error updating summary table:', error);
                document.getElementById('summary-table').innerHTML = '<tr><td colspan="2">Error loading summary data</td></tr>';
            }
        }
       
        function updateRankingTable() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase() || 'COIN';
                const table = document.getElementById('ranking-table');
                table.innerHTML = '';
                if (rankingData.length === 0) {
                    table.innerHTML = '<tr><td colspan="31">No ranking data available</td></tr>';
                    console.warn('No ranking data for ranking table');
                    return;
                }
                const thead = document.createElement('thead');
                const headerRow = thead.insertRow();
                const columns = [
                    'Rank', 'Ticker', 'Latest Close', 'Realised Volatility 30d (%)',
                    'Realised Volatility 100d (%)', 'Realised Volatility 100d 1d (%)',
                    'Realised Volatility 100d 1w (%)', 'Min Realised Volatility 100d (2y)',
                    'Max Realised Volatility 100d (2y)', 'Mean Realised Volatility 100d (2y)',
                    'Rvol 100d Percentile 2y (%)', 'Rvol 100d Z-Score Percentile 2y (%)',
                    'Realised Volatility 180d (%)', 'Realised Volatility 252d (%)',
                    'Weighted IV (%)', 'Weighted IV 1d (%)', 'Weighted IV 1w (%)',
                    'Weighted IV 3m (%)', 'Weighted IV 3m 1d (%)', 'Weighted IV 3m 1w (%)',
                    'ATM IV 3m (%)', 'ATM IV 3m 1d (%)', 'ATM IV 3m 1w (%)',
                    'Rvol100d - Weighted IV', 'Volume', 'Volume 1d (%)', 'Volume 1w (%)',
                    'Open Interest', 'OI 1d (%)', 'OI 1w (%)', 'Num Contracts'
                ];
                const displayNameMap = {
                    'Realised Volatility 30d (%)': 'RVol\n30d (%)',
                    'Realised Volatility 100d (%)': 'RVol\n100d (%)',
                    'Realised Volatility 100d 1d (%)': 'RVol\n100d 1d (%)',
                    'Realised Volatility 100d 1w (%)': 'RVol\n100d 1w (%)',
                    'Min Realised Volatility 100d (2y)': 'Min RVol\n100d (2y)',
                    'Max Realised Volatility 100d (2y)': 'Max RVol\n100d (2y)',
                    'Mean Realised Volatility 100d (2y)': 'Mean RVol\n100d (2y)',
                    'Rvol 100d Percentile 2y (%)': 'RVol 100d\nPercentile 2y (%)',
                    'Rvol 100d Z-Score Percentile 2y (%)': 'RVol 100d\nZ-Score\nPercentile 2y (%)',
                    'Realised Volatility 180d (%)': 'RVol\n180d (%)',
                    'Realised Volatility 252d (%)': 'RVol\n252d (%)',
                    'Weighted IV (%)': 'WIVol\n(%)',
                    'Weighted IV 1d (%)': 'WIVol\n1d (%)',
                    'Weighted IV 1w (%)': 'WIVol\n1w (%)',
                    'Weighted IV 3m (%)': 'WIVol\n3m (%)',
                    'Weighted IV 3m 1d (%)': 'WIVol\n3m 1d (%)',
                    'Weighted IV 3m 1w (%)': 'WIVol\n3m 1w (%)',
                    'ATM IV 3m (%)': 'ATM IVol\n3m (%)',
                    'ATM IV 3m 1d (%)': 'ATM IVol\n3m 1d (%)',
                    'ATM IV 3m 1w (%)': 'ATM IVol\n3m 1w (%)',
                    'Rvol100d - Weighted IV': 'RVol100d -\nWIVol',
                    'Num Contracts': 'Num\nContracts'
                };
                columns.forEach((col, index) => {
                    const th = document.createElement('th');
                    th.textContent = displayNameMap[col] || col.replace(/Realised Volatility/g, 'RVol').replace(/Weighted IV/g, 'WIVol').replace(/IV/g, 'IVol').replace(/ /g, '\n');
                    th.dataset.column = col;
                    th.dataset.order = 'desc';
                    th.style.color = '#FFFFFF';
                    th.addEventListener('click', () => sortTable('ranking-table', index));
                    headerRow.appendChild(th);
                });
                table.appendChild(thead);
                const tbody = document.createElement('tbody');
                rankingData.forEach(item => {
                    const row = tbody.insertRow();
                    if (item.Ticker === selectedTicker) {
                        row.classList.add('selected-ticker-row');
                    }
                    columns.forEach(col => {
                        const cell = row.insertCell();
                        let value = item[col];
                        if (Number.isFinite(value)) {
                            if (col === 'Volume' || col === 'Open Interest' || col === 'Num Contracts') {
                                value = parseInt(value).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
                            } else if (col === 'Rank') {
                                value = parseInt(value);
                            } else {
                                value = value.toFixed(2);
                            }
                        } else {
                            value = value || 'N/A';
                        }
                        cell.textContent = value;
                        cell.style.color = '#FFFFFF';
                        if (item[`${col}_Color`]) {
                            cell.style.color = item[`${col}_Color`];
                        }
                        const isPercentChange = [
                            'Realised Volatility 100d 1d (%)', 'Realised Volatility 100d 1w (%)',
                            'Weighted IV 1d (%)', 'Weighted IV 1w (%)', 'Weighted IV 3m 1d (%)',
                            'Weighted IV 3m 1w (%)', 'ATM IV 3m 1d (%)', 'ATM IV 3m 1w (%)',
                            'Rvol100d - Weighted IV', 'Volume 1d (%)', 'Volume 1w (%)',
                            'OI 1d (%)', 'OI 1w (%)'
                        ].includes(col);
                        if (isPercentChange && Number.isFinite(parseFloat(item[col])) && item[col] !== 'N/A') {
                            const val = parseFloat(item[col]);
                            cell.style.color = val < 0 ? '#F87171' : val > 0 ? '#10B981' : cell.style.color;
                        }
                    });
                });
                table.appendChild(tbody);
                console.log('Ranking table updated successfully');
            } catch (error) {
                console.error('Error updating ranking table:', error);
                document.getElementById('ranking-table').innerHTML = '<tr><td colspan="31">Error loading ranking data</td></tr>';
            }
        }

        function updateSelectedTickerSummary() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase() || 'COIN';
                const table = document.getElementById('selected-ticker-table');
                table.innerHTML = '';
                const selectedRow = rankingData.find(item => item.Ticker === selectedTicker);
                if (!selectedRow) {
                    table.innerHTML = '<tr><td colspan="31">No ranking data for selected ticker</td></tr>';
                    console.warn('No ranking data for selected ticker:', selectedTicker);
                    return;
                }
                const thead = document.createElement('thead');
                const headerRow = thead.insertRow();
                const columns = [
                    'Rank', 'Ticker', 'Latest Close', 'Realised Volatility 30d (%)',
                    'Realised Volatility 100d (%)', 'Realised Volatility 100d 1d (%)',
                    'Realised Volatility 100d 1w (%)', 'Min Realised Volatility 100d (2y)',
                    'Max Realised Volatility 100d (2y)', 'Mean Realised Volatility 100d (2y)',
                    'Rvol 100d Percentile 2y (%)', 'Rvol 100d Z-Score Percentile 2y (%)',
                    'Realised Volatility 180d (%)', 'Realised Volatility 252d (%)',
                    'Weighted IV (%)', 'Weighted IV 1d (%)', 'Weighted IV 1w (%)',
                    'Weighted IV 3m (%)', 'Weighted IV 3m 1d (%)', 'Weighted IV 3m 1w (%)',
                    'ATM IV 3m (%)', 'ATM IV 3m 1d (%)', 'ATM IV 3m 1w (%)',
                    'Rvol100d - Weighted IV', 'Volume', 'Volume 1d (%)', 'Volume 1w (%)',
                    'Open Interest', 'OI 1d (%)', 'OI 1w (%)', 'Num Contracts'
                ];
                const displayNameMap = {
                    'Realised Volatility 30d (%)': 'RVol\n30d (%)',
                    'Realised Volatility 100d (%)': 'RVol\n100d (%)',
                    'Realised Volatility 100d 1d (%)': 'RVol\n100d 1d (%)',
                    'Realised Volatility 100d 1w (%)': 'RVol\n100d 1w (%)',
                    'Min Realised Volatility 100d (2y)': 'Min RVol\n100d (2y)',
                    'Max Realised Volatility 100d (2y)': 'Max RVol\n100d (2y)',
                    'Mean Realised Volatility 100d (2y)': 'Mean RVol\n100d (2y)',
                    'Rvol 100d Percentile 2y (%)': 'RVol 100d\nPercentile 2y (%)',
                    'Rvol 100d Z-Score Percentile 2y (%)': 'RVol 100d\nZ-Score\nPercentile 2y (%)',
                    'Realised Volatility 180d (%)': 'RVol\n180d (%)',
                    'Realised Volatility 252d (%)': 'RVol\n252d (%)',
                    'Weighted IV (%)': 'WIVol\n(%)',
                    'Weighted IV 1d (%)': 'WIVol\n1d (%)',
                    'Weighted IV 1w (%)': 'WIVol\n1w (%)',
                    'Weighted IV 3m (%)': 'WIVol\n3m (%)',
                    'Weighted IV 3m 1d (%)': 'WIVol\n3m 1d (%)',
                    'Weighted IV 3m 1w (%)': 'WIVol\n3m 1w (%)',
                    'ATM IV 3m (%)': 'ATM IVol\n3m (%)',
                    'ATM IV 3m 1d (%)': 'ATM IVol\n3m 1d (%)',
                    'ATM IV 3m 1w (%)': 'ATM IVol\n3m 1w (%)',
                    'Rvol100d - Weighted IV': 'RVol100d -\nWIVol',
                    'Num Contracts': 'Num\nContracts'
                };
                columns.forEach((col, index) => {
                    const th = document.createElement('th');
                    th.textContent = displayNameMap[col] || col.replace(/Realised Volatility/g, 'RVol').replace(/Weighted IV/g, 'WIVol').replace(/IV/g, 'IVol').replace(/ /g, '\n');
                    th.dataset.column = col;
                    th.dataset.order = 'desc';
                    th.style.color = '#FFFFFF';
                    headerRow.appendChild(th);
                });
                table.appendChild(thead);
                const tbody = document.createElement('tbody');
                const row = tbody.insertRow();
                row.classList.add('selected-ticker-row');
                columns.forEach(col => {
                    const cell = row.insertCell();
                    let value = selectedRow[col];
                    if (Number.isFinite(value)) {
                        if (col === 'Volume' || col === 'Open Interest' || col === 'Num Contracts') {
                            value = parseInt(value).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
                        } else if (col === 'Rank') {
                            value = parseInt(value);
                        } else {
                            value = value.toFixed(2);
                        }
                    } else {
                        value = value || 'N/A';
                    }
                    cell.textContent = value;
                    cell.style.color = '#FFFFFF';
                    if (selectedRow[`${col}_Color`]) {
                        cell.style.color = selectedRow[`${col}_Color`];
                    }
                    const isPercentChange = [
                        'Realised Volatility 100d 1d (%)', 'Realised Volatility 100d 1w (%)',
                        'Weighted IV 1d (%)', 'Weighted IV 1w (%)', 'Weighted IV 3m 1d (%)',
                        'Weighted IV 3m 1w (%)', 'ATM IV 3m 1d (%)', 'ATM IV 3m 1w (%)',
                        'Rvol100d - Weighted IV', 'Volume 1d (%)', 'Volume 1w (%)',
                        'OI 1d (%)', 'OI 1w (%)'
                    ].includes(col);
                    if (isPercentChange && Number.isFinite(parseFloat(selectedRow[col])) && selectedRow[col] !== 'N/A') {
                        const val = parseFloat(selectedRow[col]);
                        cell.style.color = val < 0 ? '#F87171' : val > 0 ? '#10B981' : cell.style.color;
                    }
                });
                table.appendChild(tbody);
                console.log('Selected ticker summary table updated for:', selectedTicker);
            } catch (error) {
                console.error('Error updating selected ticker summary table:', error);
                document.getElementById('selected-ticker-table').innerHTML = '<tr><td colspan="31">Error loading selected ticker data</td></tr>';
            }
        }
        
        function updateStockTable() {
            try {
                const table = document.getElementById('stock-table');
                table.innerHTML = '';
                if (stockData.length === 0) {
                    table.innerHTML = '<tr><td colspan="17">No stock data available</td></tr>';
                    console.warn('No stock data for stock table');
                    return;
                }
                const thead = document.createElement('thead');
                const headerRow = thead.insertRow();
                const columns = [
                    'Ticker', 'Company Name', 'Latest Open', 'Latest Close', 'Latest High',
                    'Latest Low', 'Open 1d (%)', 'Open 1w (%)', 'Close 1d (%)', 'Close 1w (%)',
                    'High 1d (%)', 'High 1w (%)', 'Low 1d (%)', 'Low 1w (%)',
                    'Spread 1Y', 'Spread 3Y', 'Spread 5Y'
                ];
                const displayNameMap = {
                    'Spread 1Y': 'Spread\n1Y',
                    'Spread 3Y': 'Spread\n3Y',
                    'Spread 5Y': 'Spread\n5Y'
                };
                columns.forEach((col, index) => {
                    const th = document.createElement('th');
                    th.textContent = displayNameMap[col] || col.replace(/Realised Volatility/g, 'RVol').replace(/Weighted IV/g, 'WIVol').replace(/IV/g, 'IVol');
                    th.dataset.column = col; // Keep original column name for sorting
                    th.dataset.order = 'desc';
                    th.style.color = '#FFFFFF';
                    th.addEventListener('click', () => sortTable('stock-table', index));
                    headerRow.appendChild(th);
                });
                table.appendChild(thead);
                const tbody = document.createElement('tbody');
                stockData.forEach(item => {
                    const row = tbody.insertRow();
                    columns.forEach(col => {
                        const cell = row.insertCell();
                        let value = item[col];
                        if (Number.isFinite(value)) {
                            value = value.toFixed(2);
                        } else {
                            value = value || 'N/A';
                        }
                        cell.textContent = value;
                        cell.style.color = '#FFFFFF';
                        if (item[`${col}_Color`]) {
                            cell.style.color = item[`${col}_Color`];
                        }
                        const isPercentChange = [
                            'Open 1d (%)', 'Open 1w (%)', 'Close 1d (%)', 'Close 1w (%)',
                            'High 1d (%)', 'High 1w (%)', 'Low 1d (%)', 'Low 1w (%)'
                        ].includes(col);
                        if (isPercentChange && Number.isFinite(parseFloat(item[col])) && item[col] !== 'N/A') {
                            const val = parseFloat(item[col]);
                            cell.style.color = val < 0 ? '#F87171' : val > 0 ? '#10B981' : cell.style.color;
                        }
                    });
                });
                table.appendChild(tbody);
                console.log('Stock table updated successfully');
            } catch (error) {
                console.error('Error updating stock table:', error);
                document.getElementById('stock-table').innerHTML = '<tr><td colspan="17">Error loading stock data</td></tr>';
            }
        }
       
        function updateTopContractsTables() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase() || 'COIN';
                const volumeTable = document.getElementById('top-volume-table');
                const openInterestTable = document.getElementById('top-open-interest-table');
                volumeTable.innerHTML = '';
                openInterestTable.innerHTML = '';
                const tables = [
                    { table: volumeTable, data: topVolumeData.filter(row => row.Ticker === selectedTicker), id: 'top-volume-table' },
                    { table: openInterestTable, data: topOpenInterestData.filter(row => row.Ticker === selectedTicker), id: 'top-open-interest-table' }
                ];
                const formatDate = (dateStr) => {
                    try {
                        const date = new Date(dateStr);
                        if (isNaN(date.getTime())) {
                            console.warn(`Invalid date format format for expiry: ${dateStr}`);
                            return dateStr || 'N/A'; // Fallback to raw value if invalid
                        }
                        return date.toLocaleDateString('en-GB');
                    } catch {
                        console.warn(`Error parsing date: ${dateStr}`);
                        return dateStr || 'N/A'; // Fallback to raw value
                    }
                };
                tables.forEach(({ table, data, id }) => {
                    if (data.length === 0) {
                        table.innerHTML = `<tr><td colspan="7">No ${id.includes('volume') ? 'volume' : 'open interest'} data available for ${selectedTicker}</td></tr>`;
                        console.warn(`No ${id.includes('volume') ? 'volume' : 'open interest'} data for ticker: ${selectedTicker}`);
                        return;
                    }
                    const thead = document.createElement('thead');
                    const headerRow = thead.insertRow();
                    const columns = ['Ticker', 'Strike', 'Expiry', 'Type', 'Bid', 'Ask', 'Volume', 'Open Interest'];
                    columns.forEach((col, index) => {
                        const th = document.createElement('th');
                        th.textContent = col;
                        th.dataset.column = col;
                        th.dataset.order = 'desc';
                        th.style.color = '#FFFFFF';
                        th.addEventListener('click', () => sortTable(id, index));
                        headerRow.appendChild(th);
                    });
                    table.appendChild(thead);
                    const tbody = document.createElement('tbody');
                    data.forEach(item => {
                        const row = tbody.insertRow();
                        columns.forEach(col => {
                            const cell = row.insertCell();
                            let value = item[col];
                            if (Number.isFinite(value)) {
                                if (col === 'Volume' || col === 'Open Interest') {
                                    value = parseInt(value).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
                                } else {
                                    value = value.toFixed(2);
                                }
                            } else if (col === 'Expiry' && value) {
                                value = formatDate(value); // Use robust date formatting
                            } else {
                                value = value || 'N/A';
                            }
                            cell.textContent = value;
                            cell.style.color = '#FFFFFF';
                        });
                    });
                    table.appendChild(tbody);
                });
                console.log('Top contracts tables updated:', { topVolume: topVolumeData.length, topOpenInterest: topOpenInterestData.length });
            } catch (error) {
                console.error('Error updating top contracts tables:', error);
                document.getElementById('top-volume-table').innerHTML = '<tr><td colspan="7">Error loading volume data</td></tr>';
                document.getElementById('top-open-interest-table').innerHTML = '<tr><td colspan="7">Error loading open interest data</td></tr>';
            }
        }
       
        function updateRawDataTable() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase() || 'COIN';
                const table = document.getElementById('raw-data-table');
                table.innerHTML = '';
                const filteredData = rawData.filter(row => row.Ticker === selectedTicker);
                if (filteredData.length === 0) {
                    const row = table.insertRow();
                    const cell = row.insertCell();
                    cell.textContent = `No raw data available for ${selectedTicker}`;
                    cell.colSpan = 10;
                    console.warn(`No raw data for ticker: ${selectedTicker}`);
                    return;
                }
                const thead = document.createElement('thead');
                const headerRow = thead.insertRow();
                const columns = Object.keys(filteredData[0]);
                columns.forEach((text, index) => {
                    const th = document.createElement('th');
                    th.textContent = text;
                    th.dataset.column = text;
                    th.dataset.order = 'desc';
                    th.style.color = '#FFFFFF';
                    th.addEventListener('click', () => sortTable('raw-data-table', index));
                    headerRow.appendChild(th);
                });
                table.appendChild(thead);
                const tbody = document.createElement('tbody');
                filteredData.forEach(item => {
                    const row = tbody.insertRow();
                    columns.forEach(col => {
                        const cell = row.insertCell();
                        let value = item[col];
                        if (Number.isFinite(value)) {
                            if (col === 'Volume' || col === 'Open Interest') {
                                value = parseInt(value).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
                            } else {
                                value = value.toFixed(2);
                            }
                        } else if (col === 'Expiry' && value) {
                            try {
                                const date = new Date(value);
                                value = isNaN(date.getTime()) ? value : date.toLocaleDateString('en-GB');
                            } catch {
                                value = value || 'N/A';
                            }
                        } else {
                            value = value || 'N/A';
                        }
                        cell.textContent = value;
                        cell.style.color = '#FFFFFF';
                    });
                });
                table.appendChild(tbody);
                console.log('Raw data table updated successfully for ticker:', selectedTicker);
            } catch (error) {
                console.error('Error updating raw data table:', error);
                document.getElementById('raw-data-table').innerHTML = '<tr><td colspan="10">Error loading raw data table</td></tr>';
            }
        }
       
        function sortTable(tableId, columnIndex) {
            try {
                const table = document.getElementById(tableId);
                const header = table.querySelector('thead tr').children[columnIndex];
                const column = header.dataset.column;
                const order = header.dataset.order === 'desc' ? 'asc' : 'desc';
                header.dataset.order = order;
                const tbody = table.querySelector('tbody');
                const rows = Array.from(tbody.querySelectorAll('tr'));
                rows.sort((a, b) => {
                    let aValue = a.children[columnIndex].textContent;
                    let bValue = b.children[columnIndex].textContent;
                    if (aValue === 'N/A') return 1;
                    if (bValue === 'N/A') return -1;
                    if (column === 'Volume' || column === 'Open Interest' || column === 'Num Contracts') {
                        aValue = parseInt(aValue.replace(/,/g, '')) || -Infinity;
                        bValue = parseInt(bValue.replace(/,/g, '')) || -Infinity;
                    } else if (column === 'Rank') {
                        aValue = parseInt(aValue);
                        bValue = parseInt(bValue);
                    } else {
                        aValue = parseFloat(aValue) || aValue;
                        bValue = parseFloat(bValue) || bValue;
                    }
                    if (typeof aValue === 'number' && typeof bValue === 'number') {
                        return order === 'desc' ? bValue - aValue : aValue - bValue;
                    }
                    return order === 'desc' ? bValue.localeCompare(aValue) : aValue.localeCompare(bValue);
                });
                tbody.innerHTML = '';
                rows.forEach(row => tbody.appendChild(row));
            } catch (error) {
                console.error('Error sorting table:', error);
            }
        }
       
        function updateMoneynessVsIV() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const selectedExpiry = document.getElementById('expiry-select').value;
                const filteredData = data.filter(item => item.Ticker === selectedTicker && item.Expiry === selectedExpiry);
                const errorDiv = document.getElementById('moneyness-error');
                errorDiv.style.display = 'none';
                if (!filteredData.length) {
                    console.warn('No data for Moneyness vs. IV chart:', { ticker: selectedTicker, expiry: selectedExpiry });
                    if (moneynessChart) moneynessChart.destroy();
                    errorDiv.textContent = 'No data for selected ticker and expiry';
                    errorDiv.style.display = 'block';
                    return;
                }
                const datasets = [
                    {
                        label: 'Calls Smoothed IV',
                        data: aggregateDataByX(filteredData.filter(item => item.Type === 'Call'), 'Moneyness', 'Smoothed_IV'),
                        borderColor: '#FFFF00',
                        backgroundColor: 'rgba(255, 255, 0, 0.2)',
                        pointRadius: 3,
                        pointStyle: 'circle',
                        fill: true,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Puts Smoothed IV',
                        data: aggregateDataByX(filteredData.filter(item => item.Type === 'Put'), 'Moneyness', 'Smoothed_IV'),
                        borderColor: '#26A69A',
                        backgroundColor: 'rgba(38, 166, 154, 0.2)',
                        pointRadius: 3,
                        pointStyle: 'circle',
                        fill: true,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    }
                ];
                const moneynessValues = filteredData
                    .filter(item => Number.isFinite(item.Moneyness))
                    .map(item => item.Moneyness * 100);
                const minMoneyness = moneynessValues.length > 0 ? Math.min(...moneynessValues) : 0;
                const maxMoneyness = moneynessValues.length > 0 ? Math.max(...moneynessValues) : 200;
                if (moneynessChart) moneynessChart.destroy();
                const canvas = document.getElementById('moneyness-vs-iv-chart');
                if (!canvas.getContext('2d')) {
                    throw new Error('Canvas context not available for moneyness-vs-iv-chart');
                }
                moneynessChart = new Chart(canvas.getContext('2d'), {
                    type: 'line',
                    data: { datasets },
                    options: {
                        plugins: { legend: { labels: { color: '#FFFFFF' } } },
                        scales: {
                            x: {
                                type: 'linear',
                                title: { display: true, text: 'Moneyness (%)', color: '#FFFFFF' },
                                min: minMoneyness,
                                max: maxMoneyness,
                                grid: { display: false },
                                ticks: { color: '#FFFFFF' }
                            },
                            y: {
                                title: { display: true, text: 'Volatility (%)', color: '#FFFFFF' },
                                grid: { display: false },
                                ticks: { color: '#FFFFFF' },
                                min: Math.min(...datasets.flatMap(ds => ds.data.map(p => p.y))) * 0.9,
                                max: Math.max(...datasets.flatMap(ds => ds.data.map(p => p.y))) * 1.1
                            }
                        },
                        backgroundColor: '#1A1A2E'
                    }
                });
                createStatsTable(moneynessChart, 'moneyness-vs-iv-chart');
            } catch (error) {
                console.error('Error updating Moneyness vs. IV chart:', error);
                document.getElementById('moneyness-error').textContent = `Error rendering chart: ${error.message}`;
                document.getElementById('moneyness-error').style.display = 'block';
            }
        }
       
        function updateExpiryVsIV() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const selectedMoneyness = parseFloat(document.getElementById('moneyness-select').value);
                let filteredData = data.filter(item => item.Ticker === selectedTicker && Math.round(item.Moneyness * 100 / 10) * 0.1 === selectedMoneyness);
                const termMinInput = document.getElementById('term-min-expiry').value;
                const termMaxInput = document.getElementById('term-max-expiry').value;
                const termMin = termMinInput ? new Date(termMinInput) : new Date(Math.min(...uniqueExpiries.map(e => new Date(e))));
                const termMax = termMaxInput ? new Date(termMaxInput) : new Date(Math.max(...uniqueExpiries.map(e => new Date(e))));
                filteredData = filteredData.filter(item => {
                    const expDate = new Date(item.Expiry);
                    return expDate >= termMin && expDate <= termMax;
                });
                const errorDiv = document.getElementById('expiry-error');
                errorDiv.style.display = 'none';
                if (!filteredData.length) {
                    console.warn('No data for Expiry vs. IV chart:', { ticker: selectedTicker, moneyness: selectedMoneyness });
                    if (expiryChart) expiryChart.destroy();
                    errorDiv.textContent = 'No data for selected ticker and moneyness';
                    errorDiv.style.display = 'block';
                    return;
                }
                const datasets = [
                    {
                        label: 'Calls Smoothed IV',
                        data: aggregateDataByX(filteredData.filter(item => item.Type === 'Call'), 'Expiry', 'Smoothed_IV'),
                        borderColor: '#FFFF00',
                        backgroundColor: 'rgba(255, 255, 0, 0.2)',
                        pointRadius: 3,
                        pointStyle: 'circle',
                        fill: true,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Puts Smoothed IV',
                        data: aggregateDataByX(filteredData.filter(item => item.Type === 'Put'), 'Expiry', 'Smoothed_IV'),
                        borderColor: '#26A69A',
                        backgroundColor: 'rgba(38, 166, 154, 0.2)',
                        pointRadius: 3,
                        pointStyle: 'circle',
                        fill: true,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    }
                ];
                if (expiryChart) expiryChart.destroy();
                const canvas = document.getElementById('expiry-vs-iv-chart');
                if (!canvas.getContext('2d')) {
                    throw new Error('Canvas context not available for expiry-vs-iv-chart');
                }
                expiryChart = new Chart(canvas.getContext('2d'), {
                    type: 'line',
                    data: { datasets },
                    options: {
                        plugins: { legend: { labels: { color: '#FFFFFF' } } },
                        scales: {
                            x: {
                                type: 'time',
                                time: { unit: 'day' },
                                title: { display: true, text: 'Expiry Date', color: '#FFFFFF' },
                                grid: { display: false },
                                ticks: { color: '#FFFFFF' }
                            },
                            y: {
                                title: { display: true, text: 'Volatility (%)', color: '#FFFFFF' },
                                grid: { display: false },
                                ticks: { color: '#FFFFFF' },
                                min: Math.min(...datasets.flatMap(ds => ds.data.map(p => p.y))) * 0.9,
                                max: Math.max(...datasets.flatMap(ds => ds.data.map(p => p.y))) * 1.1
                            }
                        },
                        backgroundColor: '#1A1A2E'
                    }
                });
                createStatsTable(expiryChart, 'expiry-vs-iv-chart');
            } catch (error) {
                console.error('Error updating Expiry vs. IV chart:', error);
                document.getElementById('expiry-error').textContent = `Error rendering chart: ${error.message}`;
                document.getElementById('expiry-error').style.display = 'block';
            }
        }
       
        function updateRealisedVolChart() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const startInput = document.getElementById('realised-start-date').value;
                const endInput = document.getElementById('realised-end-date').value;
                const volSelect = document.getElementById('realised-vol-metric-select');
                const selectedVolMetrics = Array.from(volSelect.selectedOptions).map(opt => opt.value);
                const errorDiv = document.getElementById('realised-vol-error');
                errorDiv.style.display = 'none';
                let filteredHistoric = historicData.filter(item => item.Ticker === selectedTicker && item.Date);
                if (!filteredHistoric.length) {
                    console.warn('No data for Realised Volatility chart:', { ticker: selectedTicker });
                    if (realisedVolChart) realisedVolChart.destroy();
                    errorDiv.textContent = 'No data available';
                    errorDiv.style.display = 'block';
                    return;
                }
                filteredHistoric.sort((a, b) => new Date(a.Date) - new Date(b.Date));
                const minHistDate = new Date(Math.min(...filteredHistoric.map(item => new Date(item.Date))));
                const maxHistDate = new Date(Math.max(...filteredHistoric.map(item => new Date(item.Date))));
                const startDate = startInput ? new Date(startInput) : minHistDate;
                const endDate = endInput ? new Date(endInput) : maxHistDate;
                filteredHistoric = filteredHistoric.filter(item => {
                    const itemDate = new Date(item.Date);
                    return itemDate >= startDate && itemDate <= endDate;
                });
                if (!filteredHistoric.length) {
                    console.warn('No data after date filtering for Realised Volatility chart:', { ticker: selectedTicker });
                    if (realisedVolChart) realisedVolChart.destroy();
                    errorDiv.textContent = 'No data for selected date range';
                    errorDiv.style.display = 'block';
                    return;
                }
                const dates = filteredHistoric.map(item => new Date(item.Date));
                // Define colors for each volatility metric
                const colors = [
                    { metric: 'Realised_Vol_Close_30', border: '#FFFF00', background: 'rgba(255, 255, 0, 0.2)' },
                    { metric: 'Realised_Vol_Close_60', border: '#008000', background: 'rgba(0, 128, 0, 0.2)' },
                    { metric: 'Realised_Vol_Close_100', border: '#FF0000', background: 'rgba(255, 0, 0, 0.2)' },
                    { metric: 'Realised_Vol_Close_180', border: '#FFA500', background: 'rgba(255, 165, 0, 0.2)' },
                    { metric: 'Realised_Vol_Close_252', border: '#26A69A', background: 'rgba(38, 166, 154, 0.2)' }
                ];
                // Default to all metrics if none selected
                if (selectedVolMetrics.length === 0) {
                    selectedVolMetrics.push(...colors.map(c => c.metric));
                }
                const datasets = selectedVolMetrics.map(metric => {
                    const color = colors.find(c => c.metric === metric) || { border: '#FFFFFF', background: 'rgba(255, 255, 255, 0.2)' };
                    const data = filteredHistoric.map(item => Number.isFinite(item[metric]) ? parseFloat(item[metric]) : null).filter(v => v !== null);
                    return {
                        label: `${metric.replace('Realised_Vol_Close_', '')}-day Realised Vol (%)`,
                        data: data.map((v, i) => ({ x: dates[i], y: v })),
                        borderColor: color.border,
                        backgroundColor: color.background,
                        pointRadius: 1,
                        fill: true,
                        showLine: true,
                        yAxisID: 'y'
                    };
                });
                if (datasets.length === 0) {
                    console.warn('No valid data for selected volatility metrics:', selectedVolMetrics);
                    if (realisedVolChart) realisedVolChart.destroy();
                    errorDiv.textContent = 'No data for selected volatility metrics';
                    errorDiv.style.display = 'block';
                    return;
                }
                if (realisedVolChart) realisedVolChart.destroy();
                const canvas = document.getElementById('realised-vol-chart');
                if (!canvas.getContext('2d')) {
                    throw new Error('Canvas context not available for realised-vol-chart');
                }
                realisedVolChart = new Chart(canvas.getContext('2d'), {
                    type: 'line',
                    data: { datasets },
                    options: {
                        plugins: { legend: { labels: { color: '#FFFFFF' } } },
                        scales: {
                            x: {
                                type: 'time',
                                time: { unit: 'month' },
                                title: { display: true, text: 'Date', color: '#FFFFFF' },
                                grid: { display: false },
                                ticks: { color: '#FFFFFF' }
                            },
                            y: {
                                title: { display: true, text: 'Realised Volatility (%)', color: '#FFFFFF' },
                                beginAtZero: false,
                                grid: { display: false },
                                ticks: { color: '#FFFFFF' }
                            }
                        },
                        backgroundColor: '#1A1A2E'
                    }
                });
                createStatsTable(realisedVolChart, 'realised-vol-chart');
            } catch (error) {
                console.error('Error updating Realised Volatility chart:', error);
                document.getElementById('realised-vol-error').textContent = `Error rendering chart: ${error.message}`;
                document.getElementById('realised-vol-error').style.display = 'block';
            }
        }
       
        function updateCallVolSurface() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const filteredData = data.filter(item => item.Ticker && item.Ticker.toUpperCase() === selectedTicker && item.Type === 'Call');
                const errorDiv = document.getElementById('surface-error');
                errorDiv.style.display = 'none';
                console.log('Updating Call Volatility Surface for ticker:', selectedTicker, 'Filtered data size:', filteredData.length);
                if (!filteredData.length) {
                    console.warn('No call option data for volatility surface:', { ticker: selectedTicker });
                    Plotly.purge('call-vol-surface');
                    errorDiv.textContent = 'No call option data available';
                    errorDiv.style.display = 'block';
                    return;
                }
                const moneynessSlider = document.getElementById('moneyness-slider');
                const expiryTSlider = document.getElementById('expiry-t-slider');
                const moneynessMin = parseFloat(moneynessSlider.noUiSlider.get()[0]);
                const moneynessMax = parseFloat(moneynessSlider.noUiSlider.get()[1]);
                const expiryTMin = parseFloat(expiryTSlider.noUiSlider.get()[0]);
                const expiryTMax = parseFloat(expiryTSlider.noUiSlider.get()[1]);
                const datasetDate = new Date(document.getElementById('date-select').value.replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3'));
                const tFilteredData = filteredData.filter(item => {
                    const t = calculateTimeToExpiry(item.Expiry, datasetDate);
                    const moneyness = item.Moneyness;
                    return t !== null && Number.isFinite(t) && t >= expiryTMin && t <= expiryTMax && Number.isFinite(moneyness) && moneyness >= moneynessMin && moneyness <= moneynessMax;
                });
                if (!tFilteredData.length) {
                    console.warn('No data after time and moneyness filtering for volatility surface:', { ticker: selectedTicker });
                    Plotly.purge('call-vol-surface');
                    errorDiv.textContent = 'No data for selected moneyness and expiry range';
                    errorDiv.style.display = 'block';
                    return;
                }
                const surfaceData = prepareSurfaceData(tFilteredData, 'Smoothed_IV');
                console.log('Surface data:', {
                    x: surfaceData.x.slice(0, 5),
                    y: surfaceData.y.slice(0, 5),
                    z: surfaceData.z.map(row => row.slice(0, 5)),
                    minZ: surfaceData.minZ,
                    maxZ: surfaceData.maxZ
                });
                if (!surfaceData.x.length || !surfaceData.y.length || !surfaceData.z.length) {
                    Plotly.purge('call-vol-surface');
                    errorDiv.textContent = 'No data for volatility surface';
                    errorDiv.style.display = 'block';
                    return;
                }
                const minZ = surfaceData.minZ;
                const maxZ = surfaceData.maxZ;
                const colorscale = [
                    [0, '#440154'],
                    [0.1, '#482878'],
                    [0.2, '#3e4989'],
                    [0.3, '#31688e'],
                    [0.4, '#26828e'],
                    [0.5, '#1f9e89'],
                    [0.6, '#35b779'],
                    [0.7, '#6ece58'],
                    [0.8, '#b5de2b'],
                    [0.9, '#fde725']
                ];
                const numTicks = 6;
                const tickInterval = (maxZ - minZ) / (numTicks - 1);
                const tickvals = [];
                const ticktext = [];
                for (let i = 0; i < numTicks; i++) {
                    const val = minZ + i * tickInterval;
                    tickvals.push(val);
                    ticktext.push(val.toFixed(0));
                }
                const plotData = [{
                    x: surfaceData.x,
                    y: surfaceData.y,
                    z: surfaceData.z,
                    type: 'surface',
                    colorscale: 'Viridis',
                    cmin: minZ,
                    cmax: maxZ,
                    showscale: true,
                    colorbar: {
                        title: 'Volatility (%)',
                        titleside: 'right',
                        titlefont: { color: '#FFFFFF' },
                        tickfont: { color: '#FFFFFF' },
                        tickvals: tickvals,
                        ticktext: ticktext
                    }
                }];
                const layout = {
                    title: { text: 'Call Implied Volatility Surface (%)', font: { color: '#FFFFFF', size: 16 }, y: 0.95, x: 0.5, xanchor: 'center' },
                    scene: {
                        xaxis: {
                            title: { text: 'Expiry', color: '#FFFFFF' },
                            type: 'date',
                            tickformat: '%Y-%m-%d',
                            color: '#FFFFFF',
                            autorange: true,
                            showgrid: false
                        },
                        yaxis: {
                            title: { text: 'Moneyness (%)', color: '#FFFFFF' },
                            color: '#FFFFFF',
                            autorange: true,
                            showgrid: false
                        },
                        zaxis: {
                            title: { text: 'Volatility (%)', color: '#FFFFFF' },
                            color: '#FFFFFF',
                            range: [minZ, maxZ],
                            autorange: false,
                            showgrid: false
                        },
                        aspectmode: 'auto',
                        bgcolor: '#1A1A2E',
                        camera: {
                            eye: { x: 1.5, y: 1.5, z: 1.5 },
                            center: { x: 0, y: 0, z: 0 }
                        }
                    },
                    margin: { l: 40, r: 40, b: 40, t: 60 },
                    autosize: true,
                    paper_bgcolor: '#1A1A2E',
                    plot_bgcolor: '#1A1A2E'
                };
                Plotly.newPlot('call-vol-surface', plotData, layout);
                document.getElementById('moneyness-value').textContent = `${moneynessMin.toFixed(1)} - ${moneynessMax.toFixed(1)}`;
                document.getElementById('expiry-t-value').textContent = `${expiryTMin.toFixed(1)} - ${expiryTMax.toFixed(1)}`;
            } catch (error) {
                console.error('Error updating Call Volatility Surface:', error);
                Plotly.purge('call-vol-surface');
                document.getElementById('surface-error').textContent = `Error rendering volatility surface: ${error.message}`;
                document.getElementById('surface-error').style.display = 'block';
            }
        }
       
        function updateKurtosisChart() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const startInput = document.getElementById('kurtosis-start-date').value;
                const endInput = document.getElementById('kurtosis-end-date').value;
                const kurtType = document.getElementById('kurtosis-type-select').value;
                const errorDiv = document.getElementById('kurtosis-error');
                errorDiv.style.display = 'none';
                let filteredHistoric = historicData.filter(item => item.Ticker === selectedTicker && item.Date && Number.isFinite(item[kurtType]));
                if (!filteredHistoric.length) {
                    console.warn('No data for Kurtosis chart:', { ticker: selectedTicker });
                    if (kurtosisChart) kurtosisChart.destroy();
                    errorDiv.textContent = 'No kurtosis data available';
                    errorDiv.style.display = 'block';
                    return;
                }
                filteredHistoric.sort((a, b) => new Date(a.Date) - new Date(b.Date));
                const minHistDate = new Date(Math.min(...filteredHistoric.map(item => new Date(item.Date))));
                const maxHistDate = new Date(Math.max(...filteredHistoric.map(item => new Date(item.Date))));
                const startDate = startInput ? new Date(startInput) : minHistDate;
                const endDate = endInput ? new Date(endInput) : maxHistDate;
                filteredHistoric = filteredHistoric.filter(item => {
                    const itemDate = new Date(item.Date);
                    return itemDate >= startDate && itemDate <= endDate;
                });
                const dates = filteredHistoric.map(item => new Date(item.Date));
                const kurtosis = filteredHistoric.map(item => parseFloat(item[kurtType])).filter(v => v !== null);
                const datasets = [
                    {
                        label: `Kurtosis of 100-day ${kurtType.includes('Returns') ? 'Log Returns' : 'Close Prices'}`,
                        data: kurtosis.map((v, i) => ({ x: dates[i], y: v })),
                        borderColor: '#FFA500',
                        backgroundColor: 'rgba(255, 165, 0, 0.2)',
                        pointRadius: 1,
                        fill: true,
                        showLine: true,
                        yAxisID: 'y'
                    }
                ];
                const annotations = {
                    leptokurtic: {
                        type: 'line',
                        yMin: 3,
                        yMax: 3,
                        borderColor: '#FF0000',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        label: {
                            content: 'Mesokurtic (Normal, ~3)',
                            position: 'end',
                            backgroundColor: 'rgba(255, 0, 0, 0.7)',
                            color: '#FFFFFF',
                            font: { size: 12 }
                        }
                    },
                    leptokurticLabel: {
                        type: 'box',
                        yMin: 3,
                        yMax: Math.max(...kurtosis, 3) + 0.5,
                        backgroundColor: 'rgba(255, 0, 0, 0.1)',
                        borderColor: 'rgba(255, 0, 0, 0.3)',
                        borderWidth: 1,
                        label: {
                            content: 'Leptokurtic (>3)',
                            position: 'center',
                            color: '#FF0000',
                            font: { size: 12 }
                        }
                    },
                    platykurticLabel: {
                        type: 'box',
                        yMin: Math.min(...kurtosis, 3) - 0.5,
                        yMax: 3,
                        backgroundColor: 'rgba(0, 128, 0, 0.1)',
                        borderColor: 'rgba(0, 128, 0, 0.3)',
                        borderWidth: 1,
                        label: {
                            content: 'Platykurtic (<3)',
                            position: 'center',
                            color: '#008000',
                            font: { size: 12 }
                        }
                    }
                };
                if (kurtosisChart) kurtosisChart.destroy();
                const canvas = document.getElementById('kurtosis-chart');
                if (!canvas.getContext('2d')) {
                    throw new Error('Canvas context not available for kurtosis-chart');
                }
                kurtosisChart = new Chart(canvas.getContext('2d'), {
                    type: 'line',
                    data: { datasets },
                    options: {
                        plugins: {
                            legend: { labels: { color: '#FFFFFF' } },
                            annotation: { annotations }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: { unit: 'month' },
                                title: { display: true, text: 'Date', color: '#FFFFFF' },
                                grid: { display: false },
                                ticks: { color: '#FFFFFF' }
                            },
                            y: {
                                title: { display: true, text: 'Kurtosis', color: '#FFFFFF' },
                                beginAtZero: false,
                                grid: { display: false },
                                ticks: { color: '#FFFFFF' }
                            }
                        },
                        backgroundColor: '#1A1A2E'
                    }
                });
                createStatsTable(kurtosisChart, 'kurtosis-chart');
            } catch (error) {
                console.error('Error updating Kurtosis chart:', error);
                document.getElementById('kurtosis-error').textContent = `Error rendering chart: ${error.message}`;
                document.getElementById('kurtosis-error').style.display = 'block';
            }
        }
        function updateVolOfVolChart() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const startInput = document.getElementById('volofvol-start-date').value;
                const endInput = document.getElementById('volofvol-end-date').value;
                const errorDiv = document.getElementById('vol-of-vol-error');
                errorDiv.style.display = 'none';
                let filteredHistoric = historicData.filter(item => item.Ticker === selectedTicker && item.Date && Number.isFinite(item.Vol_of_Vol_100d) && Number.isFinite(item.Vol_of_Vol_100d_Percentile));
                if (!filteredHistoric.length) {
                    console.warn('No data for Volatility of Volatility chart:', { ticker: selectedTicker });
                    if (volOfVolChart) volOfVolChart.destroy();
                    errorDiv.textContent = 'No volatility of volatility data available';
                    errorDiv.style.display = 'block';
                    return;
                }
                filteredHistoric.sort((a, b) => new Date(a.Date) - new Date(b.Date));
                const minHistDate = new Date(Math.min(...filteredHistoric.map(item => new Date(item.Date))));
                const maxHistDate = new Date(Math.max(...filteredHistoric.map(item => new Date(item.Date))));
                const startDate = startInput ? new Date(startInput) : minHistDate;
                const endDate = endInput ? new Date(endInput) : maxHistDate;
                filteredHistoric = filteredHistoric.filter(item => {
                    const itemDate = new Date(item.Date);
                    return itemDate >= startDate && itemDate <= endDate;
                });
                const dates = filteredHistoric.map(item => new Date(item.Date));
                const volOfVol = filteredHistoric.map(item => parseFloat(item.Vol_of_Vol_100d)).filter(v => v !== null);
                const percentile = filteredHistoric.map(item => parseFloat(item.Vol_of_Vol_100d_Percentile)).filter(v => v !== null);
                const datasets = [
                    {
                        label: 'Vol of Vol 100d (%)',
                        data: volOfVol.map((v, i) => ({ x: dates[i], y: v })),
                        borderColor: '#FFA500',
                        backgroundColor: 'rgba(255, 165, 0, 0.2)',
                        pointRadius: 1,
                        fill: true,
                        showLine: true,
                        yAxisID: 'y'
                    },
                    {
                        label: 'Vol of Vol 100d Percentile (%)',
                        data: percentile.map((v, i) => ({ x: dates[i], y: v })),
                        borderColor: '#26A69A',
                        backgroundColor: 'rgba(38, 166, 154, 0.2)',
                        pointRadius: 1,
                        fill: true,
                        showLine: true,
                        yAxisID: 'y1'
                    }
                ];
                if (volOfVolChart) volOfVolChart.destroy();
                const canvas = document.getElementById('vol-of-vol-chart');
                if (!canvas.getContext('2d')) {
                    throw new Error('Canvas context not available for vol-of-vol-chart');
                }
                volOfVolChart = new Chart(canvas.getContext('2d'), {
                    type: 'line',
                    data: { datasets },
                    options: {
                        plugins: { legend: { labels: { color: '#FFFFFF' } } },
                        scales: {
                            x: {
                                type: 'time',
                                time: { unit: 'month' },
                                title: { display: true, text: 'Date', color: '#FFFFFF' },
                                grid: { display: false },
                                ticks: { color: '#FFFFFF' }
                            },
                            y: {
                                title: { display: true, text: 'Vol of Vol (%)', color: '#FFA500' },
                                beginAtZero: false,
                                grid: { display: false },
                                ticks: { color: '#FFA500' }
                            },
                            y1: {
                                title: { display: true, text: 'Percentile (%)', color: '#26A69A' },
                                position: 'right',
                                beginAtZero: false,
                                grid: { display: false },
                                ticks: { color: '#26A69A' }
                            }
                        },
                        backgroundColor: '#1A1A2E'
                    }
                });
                createStatsTable(volOfVolChart, 'vol-of-vol-chart');
            } catch (error) {
                console.error('Error updating Volatility of Volatility chart:', error);
                document.getElementById('vol-of-vol-error').textContent = `Error rendering chart: ${error.message}`;
                document.getElementById('vol-of-vol-error').style.display = 'block';
            }
        }
       
        function prepareSurfaceData(filteredData, zKey) {
            try {
                const datasetDate = new Date(document.getElementById('date-select').value.replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3'));
                const moneynessSlider = document.getElementById('moneyness-slider');
                const expiryTSlider = document.getElementById('expiry-t-slider');
                const moneynessMin = parseFloat(moneynessSlider.noUiSlider.get()[0]);
                const moneynessMax = parseFloat(moneynessSlider.noUiSlider.get()[1]);
                const expiryTMin = parseFloat(expiryTSlider.noUiSlider.get()[0]);
                const expiryTMax = parseFloat(expiryTSlider.noUiSlider.get()[1]);
                const tFilteredData = filteredData.filter(item => {
                    const t = calculateTimeToExpiry(item.Expiry, datasetDate);
                    const moneyness = item.Moneyness;
                    return t !== null && Number.isFinite(t) && t >= expiryTMin && t <= expiryTMax && Number.isFinite(moneyness) && moneyness >= moneynessMin && moneyness <= moneynessMax;
                });
                if (tFilteredData.length === 0) {
                    console.warn('No filtered data for surface');
                    return { x: [], y: [], z: [], minZ: 0, maxZ: 0 };
                }
                const uniqueRoundedMoneyness = [...new Set(tFilteredData.map(item => Math.round(item.Moneyness * 100) * 0.01))]
                    .filter(val => !isNaN(val)).sort((a, b) => a - b);
                let moneynessValues = uniqueRoundedMoneyness;
                if (moneynessValues.length > 0) {
                    let minM = moneynessValues[0];
                    let maxM = moneynessValues[moneynessValues.length - 1];
                    let grid = [];
                    for (let m = minM; m <= maxM + 0.0001; m += 0.01) {
                        grid.push(Math.round(m * 100) / 100);
                    }
                    moneynessValues = grid;
                }
                const expiryValues = [...new Set(tFilteredData.map(item => normalizeDate(item.Expiry)))]
                    .filter(val => {
                        const t = calculateTimeToExpiry(val, datasetDate);
                        return t !== null && Number.isFinite(t) && t >= expiryTMin && t <= expiryTMax;
                    })
                    .sort((a, b) => new Date(a) - new Date(b));
                if (moneynessValues.length === 0 || expiryValues.length === 0) {
                    console.warn('No moneyness or expiry values for surface');
                    return { x: [], y: [], z: [], minZ: 0, maxZ: 0 };
                }
                const expiryTimes = expiryValues.map(val => calculateTimeToExpiry(val, datasetDate)).filter(t => t !== null && Number.isFinite(t));
                if (expiryTimes.length === 0) {
                    console.warn('No valid expiry times for surface');
                    return { x: [], y: [], z: [], minZ: 0, maxZ: 0 };
                }
                const zData = [];
                moneynessValues.forEach(() => zData.push(new Array(expiryValues.length).fill(null)));
                tFilteredData.forEach(item => {
                    const moneynessIndex = moneynessValues.indexOf(Math.round(item.Moneyness * 100) * 0.01);
                    const expiryIndex = expiryValues.indexOf(normalizeDate(item.Expiry));
                    if (moneynessIndex >= 0 && expiryIndex >= 0 && Number.isFinite(item[zKey])) {
                        zData[moneynessIndex][expiryIndex] = item[zKey] * 100;
                    }
                });
                interpolateAlongMoneyness(zData, moneynessValues);
                interpolateAlongExpiry(zData, expiryTimes);
                const zValues = zData.flat().filter(v => Number.isFinite(v));
                const minZ = zValues.length > 0 ? Math.min(...zValues) : 0;
                const maxZ = zValues.length > 0 ? Math.max(...zValues) : 0;
                return {
                    x: expiryValues,
                    y: moneynessValues.map(val => val * 100),
                    z: zData,
                    minZ: minZ,
                    maxZ: maxZ
                };
            } catch (error) {
                console.error('Error preparing surface data:', error);
                return { x: [], y: [], z: [], minZ: 0, maxZ: 0 };
            }
        }
       
        function calculateTimeToExpiry(expiryDate, referenceDate) {
            try {
                const expiry = new Date(expiryDate);
                const ref = new Date(referenceDate);
                const diffMs = expiry - ref;
                return diffMs / (365 * 24 * 60 * 60 * 1000);
            } catch (error) {
                console.error('Error calculating time to expiry:', error);
                return null;
            }
        }
       
        function interpolateAlongExpiry(zData, expiryTimes) {
            if (!zData || zData.length === 0 || !zData[0] || zData[0].length === 0 || !expiryTimes || expiryTimes.length === 0) {
                console.warn('No valid data for expiry interpolation');
                return;
            }
            for (let y = 0; y < zData.length; y++) {
                const row = zData[y];
                const known = [];
                for (let x = 0; x < row.length; x++) {
                    if (row[x] !== null && Number.isFinite(row[x])) {
                        known.push({ t: expiryTimes[x], val: row[x], idx: x });
                    }
                }
                if (known.length < 2) continue;
                known.sort((a, b) => a.t - b.t);
                for (let i = 0; i < known.length - 1; i++) {
                    const start = known[i];
                    const end = known[i + 1];
                    const dt = end.t - start.t;
                    if (dt <= 0) continue;
                    for (let idx = start.idx + 1; idx < end.idx; idx++) {
                        const curr_t = expiryTimes[idx];
                        const frac = (curr_t - start.t) / dt;
                        row[idx] = start.val + frac * (end.val - start.val);
                    }
                }
            }
        }
       
        function interpolateAlongMoneyness(zData, moneynessValues) {
            if (!zData || zData.length === 0 || !zData[0] || zData[0].length === 0 || !moneynessValues || moneynessValues.length === 0) {
                console.warn('No valid data for moneyness interpolation');
                return;
            }
            for (let x = 0; x < zData[0].length; x++) {
                const col = zData.map(row => row[x]);
                const known = [];
                for (let y = 0; y < col.length; y++) {
                    if (col[y] !== null && Number.isFinite(col[y])) {
                        known.push({ m: moneynessValues[y], val: col[y], idx: y });
                    }
                }
                if (known.length < 2) continue;
                known.sort((a, b) => a.m - b.m);
                for (let i = 0; i < known.length - 1; i++) {
                    const start = known[i];
                    const end = known[i + 1];
                    const dm = end.m - start.m;
                    if (dm <= 0) continue;
                    for (let idx = start.idx + 1; idx < end.idx; idx++) {
                        const curr_m = moneynessValues[idx];
                        const frac = (curr_m - start.m) / dm;
                        zData[idx][x] = start.val + frac * (end.val - start.val);
                    }
                }
            }
        }
    
       
        function updateHistoricChart() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const startInput = document.getElementById('historic-start-date').value;
                const endInput = document.getElementById('historic-end-date').value;
                const errorDiv = document.getElementById('historic-error');
                errorDiv.style.display = 'none';
                console.log('Updating Historic chart for ticker:', selectedTicker, 'historicData columns:', historicData.length > 0 ? Object.keys(historicData[0]) : []);
                if (!historicData || historicData.length === 0) {
                    if (historicChart) historicChart.destroy();
                    errorDiv.textContent = 'No historic data available';
                    errorDiv.style.display = 'block';
                    return;
                }
                let filteredHistoric = historicData.filter(item => item.Ticker === selectedTicker && item.Date && Number.isFinite(item.Close));
                if (filteredHistoric.length === 0) {
                    if (historicChart) historicChart.destroy();
                    errorDiv.textContent = 'No valid historic data for selected ticker';
                    errorDiv.style.display = 'block';
                    return;
                }
                filteredHistoric.sort((a, b) => new Date(a.Date) - new Date(b.Date));
                const minHistoricDate = new Date(Math.min(...filteredHistoric.map(item => new Date(item.Date))));
                const maxHistoricDate = new Date(Math.max(...filteredHistoric.map(item => new Date(item.Date))));
                const startDate = startInput ? new Date(startInput) : minHistoricDate;
                const endDate = endInput ? new Date(endInput) : maxHistoricDate;
                filteredHistoric = filteredHistoric.filter(item => {
                    const itemDate = new Date(item.Date);
                    return itemDate >= startDate && itemDate <= endDate;
                });
                const dates = filteredHistoric.map(item => new Date(item.Date));
                const vol100 = filteredHistoric.map(item => {
                    const col = ['Realised_Vol_Close_100', 'Realized_Vol_Close_100'].find(c => item.hasOwnProperty(c)) || 'Realised_Vol_Close_100';
                    return Number.isFinite(item[col]) ? parseFloat(item[col]) : null;
                }).filter(v => v !== null);
                const datasets = [
                    {
                        label: 'Stock Price',
                        data: filteredHistoric.map((item, i) => ({ x: dates[i], y: parseFloat(item.Close) })),
                        borderColor: '#FFFF00',
                        backgroundColor: '#FFFF00',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        yAxisID: 'y'
                    },
                    {
                        label: '100-day Realised Vol (%)',
                        data: vol100.map((v, i) => ({ x: dates[i], y: v })),
                        borderColor: '#FF0000',
                        backgroundColor: 'rgba(255, 0, 0, 0.2)',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        yAxisID: 'y1'
                    }
                ];
                const annotations = eventsData
                    .filter(event => {
                        if (!event.Start_Date || !event.End_Date) return false;
                        const startDate = new Date(event.Start_Date);
                        const endDate = new Date(event.End_Date);
                        if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) return false;
                        if (!(event.Ticker === 'ALL' || event.Ticker === selectedTicker)) return false;
                        if (startDate > maxHistoricDate || endDate < minHistoricDate) return false;
                        return endDate >= startDate && startDate <= endDate;  // Basic validation
                    })
                    .map((event, index) => ({
                        type: 'box',
                        xMin: new Date(Math.max(new Date(event.Start_Date), startDate)),
                        xMax: new Date(Math.min(new Date(event.End_Date), endDate)),
                        yMin: 'y',
                        yMax: 'y',
                        backgroundColor: event.Impact === 'dip' ? 'rgba(248, 113, 113, 0.2)' : 'rgba(74, 222, 128, 0.2)',
                        borderColor: event.Impact === 'dip' ? 'rgba(248, 113, 113, 0.5)' : 'rgba(74, 222, 128, 0.5)',
                        borderWidth: 1,
                        label: {
                            content: event.Event || 'Unknown Event',
                            display: true,
                            position: 'center',
                            color: '#FFFFFF',
                            font: { size: 12 },
                            rotation: 90
                        }
                    }));
                if (historicChart) historicChart.destroy();
                const canvas = document.getElementById('historic-price-chart');
                if (!canvas.getContext('2d')) {
                    throw new Error('Canvas context not available for historic-price-chart');
                }
                historicChart = new Chart(canvas.getContext('2d'), {
                    type: 'line',
                    data: { datasets },
                    options: {
                        plugins: {
                            legend: { labels: { color: '#FFFFFF' } },
                            annotation: { annotations }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: { unit: 'month' },
                                title: { display: true, text: 'Date', color: '#FFFFFF' },
                                grid: { display: false },
                                ticks: { color: '#FFFFFF' }
                            },
                            y: {
                                title: { display: true, text: 'Stock Price ($)', color: '#FFFFFF' },
                                beginAtZero: false,
                                grid: { display: false },
                                ticks: { color: '#FFFFFF' }
                            },
                            y1: {
                                title: { display: true, text: 'Realised Volatility (%)', color: '#FF0000' },
                                position: 'right',
                                beginAtZero: false,
                                grid: { display: false },
                                ticks: { color: '#FF0000' }
                            }
                        },
                        backgroundColor: '#1A1A2E'
                    }
                });
                document.getElementById('historic-error').style.display = 'none';
                createStatsTable(historicChart, 'historic-price-chart');
            } catch (error) {
                console.error('Error updating Historic chart:', error);
                document.getElementById('historic-error').textContent = `Error rendering historic chart: ${error.message}`;
                document.getElementById('historic-error').style.display = 'block';
            }
        }
       
        function updateVolumeChart() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const uniqueTickers = [...new Set(rankingData.map(item => item.Ticker))].filter(val => val).sort();
                const volumes = uniqueTickers.map(ticker => {
                    const tickerData = rankingData.find(item => item.Ticker === ticker);
                    return tickerData && Number.isFinite(tickerData['Volume']) ? parseInt(tickerData['Volume']) : 0;
                });
                const backgroundColors = uniqueTickers.map(ticker => ticker === selectedTicker ? '#FFFF00' : '#00BFFF');
                if (volumeChart) volumeChart.destroy();
                const canvas = document.getElementById('volume-chart');
                if (!canvas.getContext('2d')) {
                    throw new Error('Canvas context not available for volume-chart');
                }
                volumeChart = new Chart(canvas.getContext('2d'), {
                    type: 'bar',
                    data: {
                        labels: uniqueTickers,
                        datasets: [{
                            label: 'Total Volume',
                            data: volumes,
                            backgroundColor: backgroundColors,
                            borderColor: backgroundColors,
                            borderWidth: 1
                        }]
                    },
                    options: {
                        plugins: { legend: { labels: { color: '#FFFFFF' } } },
                        scales: {
                            x: {
                                title: { display: true, text: 'Ticker', color: '#FFFFFF' },
                                grid: { display: false },
                                ticks: { color: '#FFFFFF' }
                            },
                            y: {
                                title: { display: true, text: 'Volume', color: '#FFFFFF' },
                                beginAtZero: true,
                                grid: { display: false },
                                ticks: {
                                    color: '#FFFFFF',
                                    callback: value => Number(value).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 })
                                }
                            }
                        },
                        backgroundColor: '#1C2526'
                    }
                });
                console.log('Volume chart updated for tickers:', uniqueTickers);
            } catch (error) {
                console.error('Error updating volume chart:', error);
                document.getElementById('historic-error').textContent = `Error rendering volume chart: ${error.message}`;
                document.getElementById('historic-error').style.display = 'block';
            }
        }
       
        function updateOpenInterestChart() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const uniqueTickers = [...new Set(rankingData.map(item => item.Ticker))].filter(val => val).sort();
                const openInterests = uniqueTickers.map(ticker => {
                    const tickerData = rankingData.find(item => item.Ticker === ticker);
                    return tickerData && Number.isFinite(tickerData['Open Interest']) ? parseInt(tickerData['Open Interest']) : 0;
                });
                const backgroundColors = uniqueTickers.map(ticker => ticker === selectedTicker ? '#FFFF00' : '#00BFFF');
                if (openInterestChart) openInterestChart.destroy();
                const canvas = document.getElementById('open-interest-chart');
                if (!canvas.getContext('2d')) {
                    throw new Error('Canvas context not available for open-interest-chart');
                }
                openInterestChart = new Chart(canvas.getContext('2d'), {
                    type: 'bar',
                    data: {
                        labels: uniqueTickers,
                        datasets: [{
                            label: 'Total Open Interest',
                            data: openInterests,
                            backgroundColor: backgroundColors,
                            borderColor: backgroundColors,
                            borderWidth: 1
                        }]
                    },
                    options: {
                        plugins: { legend: { labels: { color: '#FFFFFF' } } },
                        scales: {
                            x: {
                                title: { display: true, text: 'Ticker', color: '#FFFFFF' },
                                grid: { display: false },
                                ticks: { color: '#FFFFFF' }
                            },
                            y: {
                                title: { display: true, text: 'Open Interest', color: '#FFFFFF' },
                                beginAtZero: true,
                                grid: { display: false },
                                ticks: {
                                    color: '#FFFFFF',
                                    callback: value => Number(value).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 })
                                }
                            }
                        },
                        backgroundColor: '#1C2526'
                    }
                });
                console.log('Open Interest chart updated for tickers:', uniqueTickers);
            } catch (error) {
                console.error('Error updating open interest chart:', error);
                document.getElementById('historic-error').textContent = `Error rendering open interest chart: ${error.message}`;
                document.getElementById('historic-error').style.display = 'block';
            }
        }
       
        function aggregateDataByX(data, xKey, yKey) {
            try {
                const grouped = data.reduce((acc, item) => {
                    const xValue = xKey === 'Expiry' ? new Date(item[xKey]).toISOString() : item[xKey];
                    const yValue = item[yKey];
                    if (!acc[xValue]) acc[xValue] = { sum: 0, count: 0 };
                    if (!isNaN(yValue) && yValue !== null) {
                        acc[xValue].sum += yValue;
                        acc[xValue].count += 1;
                    }
                    return acc;
                }, {});
                return Object.keys(grouped).map(x => {
                    const group = grouped[x];
                    if (group.count > 0) {
                        return {
                            x: xKey === 'Expiry' ? new Date(x) : parseFloat(x) * (xKey === 'Moneyness' || xKey === 'Delta' ? 100 : 1),
                            y: (group.sum / group.count) * 100
                        };
                    }
                }).filter(point => point).sort((a, b) => a.x - b.x);
            } catch (error) {
                console.error('Error aggregating data:', error);
                return [];
            }
        }
       
        function createStatsTable(chart, canvasId) {
            try {
                const container = document.getElementById(canvasId).parentNode;
                let existingTable = container.querySelector('.stats-table');
                if (existingTable) existingTable.remove();
                const table = document.createElement('table');
                table.className = 'stats-table';
                table.style.display = canvasId === 'historic-price-chart' ? 'table' : (statsTablesVisible ? 'table' : 'none');
                const thead = table.createTHead();
                const headerRow = thead.insertRow();
                ['Label', 'Last', 'Min', 'Max', 'Mean', 'SD', 'SD Change'].forEach(text => {
                    const th = document.createElement('th');
                    th.textContent = text;
                    headerRow.appendChild(th);
                });
                const tbody = table.createTBody();
                chart.data.datasets.forEach(dataset => {
                    if (!dataset.data.length) return;
                    const ys = dataset.data.map(point => point.y).filter(y => !isNaN(y));
                    if (!ys.length) return;
                    const last = ys[ys.length - 1];
                    const min = Math.min(...ys);
                    const max = Math.max(...ys);
                    const mean = ys.reduce((a, b) => a + b, 0) / ys.length;
                    const sd = Math.sqrt(ys.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / (ys.length - 1)) || 0;
                    const sdChanges = ys.slice(1).map((y, i) => y - ys[i]);
                    const sdChange = sdChanges.length > 0 ? Math.sqrt(sdChanges.reduce((a, b) => a + Math.pow(b, 2), 0) / (sdChanges.length - 1)) || 0 : 0;
                    const row = tbody.insertRow();
                    const labelTd = row.insertCell();
                    const swatch = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    swatch.setAttribute('width', '20');
                    swatch.setAttribute('height', '10');
                    swatch.setAttribute('class', 'line-swatch');
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', '0');
                    line.setAttribute('y1', '5');
                    line.setAttribute('x2', '20');
                    line.setAttribute('y2', '5');
                    line.setAttribute('stroke', dataset.borderColor);
                    line.setAttribute('stroke-width', '2');
                    if (dataset.borderDash && dataset.borderDash.length > 0) {
                        line.setAttribute('stroke-dasharray', dataset.borderDash.join(' '));
                    }
                    swatch.appendChild(line);
                    labelTd.appendChild(swatch);
                    labelTd.appendChild(document.createTextNode(` ${dataset.label}`));
                    row.insertCell().textContent = last.toFixed(2);
                    row.insertCell().textContent = min.toFixed(2);
                    row.insertCell().textContent = max.toFixed(2);
                    row.insertCell().textContent = mean.toFixed(2);
                    row.insertCell().textContent = sd.toFixed(2);
                    row.insertCell().textContent = sdChange.toFixed(2);
                });
                container.appendChild(table);
            } catch (error) {
                console.error('Error creating stats table:', error);
                document.getElementById('historic-error').textContent = `Error creating stats table: ${error.message}`;
                document.getElementById('historic-error').style.display = 'block';
            }
        }
       
        function updateSection(sectionId) {
            try {
                console.log('Updating section:', sectionId);
                const sections = ['overview', 'volatility', 'ranking', 'stock', 'data-table'];
                const selectedTickerSummary = document.getElementById('selected-ticker-summary');
                sections.forEach(id => {
                    const element = document.getElementById(id);
                    if (id === sectionId) {
                        element.style.display = id === 'overview' || id === 'volatility' ? 'grid' : 'block';
                    } else {
                        element.style.display = 'none';
                    }
                });
                if (selectedTickerSummary) {
                    selectedTickerSummary.style.display = sectionId === 'volatility' ? 'block' : 'none';
                }
                updateCharts();
            } catch (error) {
                console.error('Error updating section:', error);
                document.getElementById('historic-error').textContent = `Error navigating to section: ${error.message}`;
                document.getElementById('historic-error').style.display = 'block';
            }
        }
       
        function updateCharts() {
            try {
                console.log('Updating all charts and tables');
                updateMoneynessVsIV();
                updateExpiryVsIV();
                updateSkewVsExpiry();
                updateRealisedVolChart();
                updateCallVolSurface();
                updateKurtosisChart();
                updateVolOfVolChart();
                updateSummaryTable();
                updateTopContractsTables();
                updateVolumeChart();
                updateOpenInterestChart();
                updateHistoricChart();
                updateRawDataTable();
                updateRankingTable();
                updateStockTable();
                updateSelectedTickerSummary();
            } catch (error) {
                console.error('Error updating charts:', error);
                document.getElementById('historic-error').textContent = `Error updating charts: ${error.message}`;
                document.getElementById('historic-error').style.display = 'block';
            }
        }
       
        function addKeyboardNavigation() {
            try {
                const chartConfigs = [
                    { canvasId: 'moneyness-vs-iv-chart', selectId: 'expiry-select' },
                    { canvasId: 'expiry-vs-iv-chart', selectId: 'moneyness-select' },
                    { canvasId: 'skew-vs-expiry-chart', selectId: 'skew-metric-select' },
                    { canvasId: 'realised-vol-chart', selectId: 'realised-vol-metric-select' },
                    { canvasId: 'kurtosis-chart', selectId: 'kurtosis-type-select' },
                    { canvasId: 'vol-of-vol-chart', selectId: null },
                    { canvasId: 'volume-chart', selectId: 'ticker-search' },
                    { canvasId: 'open-interest-chart', selectId: 'ticker-search' },
                    { canvasId: 'historic-price-chart', selectId: null }
                ];
                chartConfigs.forEach(config => {
                    const canvas = document.getElementById(config.canvasId);
                    const select = config.selectId ? document.getElementById(config.selectId) : null;
                    if (canvas && select) {
                        canvas.addEventListener('keydown', (event) => {
                            if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
                                event.preventDefault();
                                let newIndex = select.selectedIndex + (event.key === 'ArrowLeft' ? -1 : 1);
                                if (newIndex < 0) newIndex = select.options.length - 1;
                                if (newIndex >= select.options.length) newIndex = 0;
                                select.selectedIndex = newIndex;
                                select.dispatchEvent(new Event('change', { bubbles: true }));
                            }
                        });
                    }
                });
                const expirySelect = document.getElementById('expiry-select');
                if (expirySelect) {
                    expirySelect.addEventListener('change', () => {
                        console.log('Expiry select changed to:', expirySelect.value);
                        updateCharts();
                    });
                }
                const moneynessSelect = document.getElementById('moneyness-select');
                if (moneynessSelect) {
                    moneynessSelect.addEventListener('change', () => {
                        console.log('Moneyness select changed to:', moneynessSelect.value);
                        updateCharts();
                    });
                }
                document.getElementById('historic-start-date').addEventListener('change', updateHistoricChart);
                document.getElementById('historic-end-date').addEventListener('change', updateHistoricChart);
                document.getElementById('realised-start-date').addEventListener('change', updateRealisedVolChart);
                document.getElementById('realised-end-date').addEventListener('change', updateRealisedVolChart);
                document.getElementById('realised-vol-metric-select').addEventListener('change', updateRealisedVolChart);
                document.getElementById('kurtosis-start-date').addEventListener('change', updateKurtosisChart);
                document.getElementById('kurtosis-end-date').addEventListener('change', updateKurtosisChart);
                document.getElementById('volofvol-start-date').addEventListener('change', updateVolOfVolChart);
                document.getElementById('volofvol-end-date').addEventListener('change', updateVolOfVolChart);
                document.getElementById('term-min-expiry').addEventListener('change', updateExpiryVsIV);
                document.getElementById('term-max-expiry').addEventListener('change', updateExpiryVsIV);
                document.getElementById('skew-min-expiry').addEventListener('change', updateSkewVsExpiry);
                document.getElementById('skew-max-expiry').addEventListener('change', updateSkewVsExpiry);
                document.getElementById('skew-metric-select').addEventListener('change', updateSkewVsExpiry);
                document.getElementById('kurtosis-type-select').addEventListener('change', updateKurtosisChart);
            } catch (error) {
                console.error('Error adding keyboard navigation:', error);
                document.getElementById('historic-error').textContent = `Error setting up keyboard navigation: ${error.message}`;
                document.getElementById('historic-error').style.display = 'block';
            }
        }
       
        function updateTimeOptions(selectedDate, dates) {
            try {
                const timeSelect = document.getElementById('time-select');
                timeSelect.innerHTML = '';
                const formattedSelectedDate = selectedDate.replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3');
                const availableTimes = dates
                    .filter(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$1-$2-$3') === formattedSelectedDate)
                    .map(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$4:$5'))
                    .sort();
                const uniqueTimes = [...new Set(availableTimes)];
                uniqueTimes.forEach(timePart => {
                    const option = document.createElement('option');
                    option.value = timePart.replace(':', '');
                    option.textContent = timePart;
                    timeSelect.appendChild(option);
                });
                if (timeSelect.options.length > 0) {
                    timeSelect.value = timeSelect.options[0].value;
                    timeSelect.dispatchEvent(new Event('change', { bubbles: true }));
                } else {
                    console.warn('No times available for selected date:', formattedSelectedDate);
                    document.getElementById('historic-error').textContent = 'No times available for selected date';
                    document.getElementById('historic-error').style.display = 'block';
                }
                console.log('Time options updated:', uniqueTimes);
            } catch (error) {
                console.error('Error updating time options:', error);
                document.getElementById('historic-error').textContent = `Error updating time options: ${error.message}`;
                document.getElementById('historic-error').style.display = 'block';
            }
        }
       
        document.addEventListener('DOMContentLoaded', () => {
            try {
                if (typeof Chart === 'undefined' || typeof Plotly === 'undefined' || typeof Papa === 'undefined') {
                    console.error('Required libraries (Chart.js, Plotly, or PapaParse) not loaded');
                    document.getElementById('historic-error').textContent = 'Failed to load required libraries';
                    document.getElementById('historic-error').style.display = 'block';
                    return;
                }
                const moneynessSlider = document.getElementById('moneyness-slider');
                const expiryTSlider = document.getElementById('expiry-t-slider');
                noUiSlider.create(moneynessSlider, {
                    start: [0.6, 2.5],
                    connect: true,
                    range: { min: 0.1, max: 3 },
                    step: 0.1
                });
                noUiSlider.create(expiryTSlider, {
                    start: [0.2, 5],
                    connect: true,
                    range: { min: 0, max: 5 },
                    step: 0.1
                });
                moneynessSlider.noUiSlider.on('update', (values) => {
                    document.getElementById('moneyness-value').textContent = `${parseFloat(values[0]).toFixed(1)} - ${parseFloat(values[1]).toFixed(1)}`;
                    updateCallVolSurface();
                });
                expiryTSlider.noUiSlider.on('update', (values) => {
                    document.getElementById('expiry-t-value').textContent = `${parseFloat(values[0]).toFixed(1)} - ${parseFloat(values[1]).toFixed(1)}`;
                    updateCallVolSurface();
                });
                const dateSelect = document.getElementById('date-select');
                const timeSelect = document.getElementById('time-select');
                const tickerSearch = document.getElementById('ticker-search');
                const validateTimestamp = async (timestamp) => {
                    const prefix = '_yfinance';
                    try {
                        const response = await fetch(`data/${timestamp}/tables/ranking/ranking_table${prefix}.csv?v=${Date.now()}`, { method: 'HEAD' });
                        return response.ok ? timestamp : null;
                    } catch {
                        return null;
                    }
                };
                const getLatestValidTimestamp = async (dates) => {
                    const timestamps = dates.sort((a, b) => b.localeCompare(a));
                    for (const ts of timestamps) {
                        if (await validateTimestamp(ts)) return ts;
                    }
                    console.warn('No valid timestamps found, using fallback');
                    return '20250827_2136';
                };
                fetch('data/dates.json?v=' + Date.now())
                    .then(response => {
                        if (!response.ok) throw new Error('Failed to load dates.json');
                        return response.json();
                    })
                    .then(async dates => {
                        const uniqueDates = [...new Set(dates.map(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$1-$2-$3')))].sort((a, b) => b.localeCompare(a));
                        dateSelect.innerHTML = '';
                        uniqueDates.forEach(datePart => {
                            const option = document.createElement('option');
                            option.value = datePart.replace(/-/g, '');
                            option.textContent = datePart;
                            dateSelect.appendChild(option);
                        });
                        const loadInitialData = async () => {
                            let timestamp = await getLatestValidTimestamp(dates);
                            if (dateSelect.options.length > 0) {
                                dateSelect.value = timestamp.slice(0, 8);
                                await updateTimeOptions(dateSelect.value, dates);
                                timestamp = dateSelect.value + '_' + (timeSelect.options.length > 0 ? timeSelect.value : '2136');
                            }
                            console.log('Loading initial data with timestamp:', timestamp);
                            await loadData(timestamp);
                            updateDropdowns();
                            updateSection('overview');
                            console.log('Initial data and Overview loaded for timestamp:', timestamp);
                        };
                        await loadInitialData();
                        dateSelect.addEventListener('change', async (e) => {
                            console.log('Date select changed to:', e.target.value);
                            await updateTimeOptions(e.target.value, dates);
                            const timestamp = e.target.value + '_' + (timeSelect.options.length > 0 ? timeSelect.value : '2136');
                            if (await validateTimestamp(timestamp)) {
                                await loadData(timestamp);
                                updateDropdowns();
                                const currentSection = document.querySelector('.overview-grid[style*="grid"], .volatility-grid[style*="grid"], .chart-container[style*="block"]');
                                const sectionId = currentSection ? currentSection.id : 'overview';
                                updateSection(sectionId);
                                console.log('Updated section after date change:', sectionId);
                            } else {
                                console.warn('Invalid timestamp:', timestamp);
                                document.getElementById('historic-error').textContent = 'Invalid date selected';
                                document.getElementById('historic-error').style.display = 'block';
                            }
                        });
                        timeSelect.addEventListener('change', async (e) => {
                            console.log('Time select changed to:', e.target.value);
                            const timestamp = dateSelect.value + '_' + e.target.value;
                            if (await validateTimestamp(timestamp)) {
                                await loadData(timestamp);
                                updateDropdowns();
                                const currentSection = document.querySelector('.overview-grid[style*="grid"], .volatility-grid[style*="grid"], .chart-container[style*="block"]');
                                const sectionId = currentSection ? currentSection.id : 'overview';
                                updateSection(sectionId);
                                console.log('Updated section after time change:', sectionId);
                            } else {
                                console.warn('Invalid timestamp:', timestamp);
                                document.getElementById('historic-error').textContent = 'Invalid time selected';
                                document.getElementById('historic-error').style.display = 'block';
                            }
                        });
                        tickerSearch.addEventListener('input', debounce(async () => {
                            console.log('Ticker changed to:', tickerSearch.value);
                            document.getElementById('ticker-display').textContent = `${tickerSearch.value.toUpperCase() || 'N/A'}`;
                            const timestamp = dateSelect.value + '_' + (timeSelect.options.length > 0 ? timeSelect.value : '2136');
                            if (await validateTimestamp(timestamp)) {
                                await loadData(timestamp);
                                updateDropdowns();
                                const currentSection = document.querySelector('.overview-grid[style*="grid"], .volatility-grid[style*="grid"], .chart-container[style*="block"]');
                                const sectionId = currentSection ? currentSection.id : 'overview';
                                updateSection(sectionId);
                                console.log('Updated section after ticker change:', sectionId);
                            } else {
                                console.warn('Invalid timestamp:', timestamp);
                                document.getElementById('historic-error').textContent = 'Invalid data timestamp';
                                document.getElementById('historic-error').style.display = 'block';
                            }
                        }, 500));
                        const links = document.querySelectorAll('.sidebar a');
                        links.forEach(link => {
                            link.addEventListener('click', async (e) => {
                                e.preventDefault();
                                const targetId = link.getAttribute('href').substring(1);
                                console.log(`Navigating to section: ${targetId}`);
                                const timestamp = dateSelect.value + '_' + (timeSelect.options.length > 0 ? timeSelect.value : '2136');
                                if (await validateTimestamp(timestamp)) {
                                    await loadData(timestamp);
                                    updateDropdowns();
                                    updateSection(targetId);
                                } else {
                                    console.warn('Invalid timestamp on navigation:', timestamp);
                                    document.getElementById('historic-error').textContent = 'Invalid data timestamp';
                                    document.getElementById('historic-error').style.display = 'block';
                                }
                            });
                        });
                        const overviewContainer = document.getElementById('overview');
                        overviewContainer.style.display = 'grid';
                        document.getElementById('volatility').style.display = 'none';
                        document.getElementById('ranking').style.display = 'none';
                        document.getElementById('data-table').style.display = 'none';
                        console.log('Initial load: Showing Overview');
                        addKeyboardNavigation();
                    })
                    .catch(error => {
                        console.error('Error loading dates:', error);
                        document.getElementById('historic-error').textContent = `Failed to load date options: ${error.message}`;
                        document.getElementById('historic-error').style.display = 'block';
                    });
            } catch (error) {
                console.error('Error in DOMContentLoaded:', error);
                document.getElementById('historic-error').textContent = `Error initializing page: ${error.message}`;
                document.getElementById('historic-error').style.display = 'block';
            }
        });
    </script>
</body>
</html>
