<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ticker Ranking</title>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #1C2526;
            color: #FFFFFF;
            margin: 0;
            padding: 20px;
        }
        .data-table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        .data-table th, .data-table td {
            border: 1px solid #FFFFFF;
            padding: 12px;
            text-align: left;
            color: #FFFFFF;
        }
        .data-table th {
            background-color: #2E3537;
            cursor: pointer;
        }
        .data-table th:hover {
            background-color: #3E4547;
        }
        .nav-link {
            color: #00BFFF;
            text-decoration: none;
            padding: 5px;
            display: inline-block;
        }
        .nav-link:hover {
            text-decoration: underline;
        }
        .sort-indicator::after {
            content: '';
            display: inline-block;
            margin-left: 5px;
        }
        .sort-asc::after {
            content: ' ▲';
        }
        .sort-desc::after {
            content: ' ▼';
        }
        select {
            padding: 5px;
            background-color: #2E3537;
            color: #FFFFFF;
            border: 1px solid #FFFFFF;
            border-radius: 4px;
        }
        .controls-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div>
        <a href="index.html" class="nav-link">Back to Main Dashboard</a>
        <a href="vol-surfaces.html" class="nav-link">View Volatility Surfaces</a>
    </div>
    <div class="controls-container">
        <label for="source-select">Select Data Source: </label>
        <select id="source-select">
            <option value="nasdaq">Nasdaq</option>
            <option value="yfinance" selected>yfinance</option>
        </select>
        <label for="date-select">Select Date: </label>
        <select id="date-select"></select>
        <label for="time-select">Select Time: </label>
        <select id="time-select"></select>
    </div>
    <table id="data-table" class="data-table">
        <thead>
            <tr>
                <th data-sort="order">Rank</th>
                <th data-sort="ticker">Ticker</th>
                <th data-sort="latestClose">Latest Close ($)</th>
                <th data-sort="close1d">Close 1d (%)</th>
                <th data-sort="close1w">Close 1w (%)</th>
                <th data-sort="realisedVol30">Rvol 30d (%)</th>
                <th data-sort="realisedVol60">Rvol 60d (%)</th>
                <th data-sort="realisedVol100">Rvol 100d (%)</th>
                <th data-sort="realisedVol100_1d">Rvol 100d 1d (%)</th>
                <th data-sort="realisedVol100_1w">Rvol 100d 1w (%)</th>
                <th data-sort="minRealisedVol100">Min Rvol 100d (1y)</th>
                <th data-sort="maxRealisedVol100">Max Rvol 100d (1y)</th>
                <th data-sort="meanRealisedVol100">Mean Rvol 100d (1y)</th>
                <th data-sort="realisedVol180">Rvol 180d (%)</th>
                <th data-sort="realisedVol252">Rvol 252d (%)</th>
                <th data-sort="weightedIV">Weighted IV (%)</th>
                <th data-sort="volume">Volume</th>
                <th data-sort="vol1d">Vol 1d (%)</th>
                <th data-sort="vol1w">Vol 1w (%)</th>
                <th data-sort="openInterest">Open Interest</th>
                <th data-sort="oi1d">OI 1d (%)</th>
                <th data-sort="oi1w">OI 1w (%)</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>
    <script>
        let rankingData = [];
        let currentSort = { column: 'openInterest', direction: 'desc' };

        function parseCSV(csvText) {
            try {
                const result = Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    dynamicTyping: true
                });
                console.log('Parsed CSV data types:', result.data.map(item => ({
                    ticker: typeof item.Ticker,
                    openInterest: typeof item['Open Interest'],
                    volume: typeof item['Volume'],
                    weightedIV: typeof item['Weighted IV (%)']
                })));
                return result.data;
            } catch (error) {
                console.error('Error parsing CSV:', error);
                return [];
            }
        }

        function normalizeDate(dateStr) {
            try {
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) throw new Error('Invalid date');
                return date.toLocaleDateString('en-CA');
            } catch (error) {
                console.error('Error normalizing date:', dateStr, error);
                return null;
            }
        }

        function updateTimeOptions(selectedDate, dates) {
            try {
                const timeSelect = document.getElementById('time-select');
                timeSelect.innerHTML = '';
                const formattedSelectedDate = selectedDate.replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3');
                const availableTimes = dates
                    .filter(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$1-$2-$3') === formattedSelectedDate)
                    .map(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$4:$5'));
                const uniqueTimes = [...new Set(availableTimes)];
                uniqueTimes.forEach(timePart => {
                    const option = document.createElement('option');
                    option.value = timePart.replace(':', '');
                    option.textContent = timePart;
                    timeSelect.appendChild(option);
                });
                if (timeSelect.options.length > 0) timeSelect.value = timeSelect.options[0].value;
                console.log('Time options updated:', uniqueTimes);
            } catch (error) {
                console.error('Error updating time options:', error);
            }
        }

        function loadData(timestamp) {
            try {
                const source = document.getElementById('source-select').value;
                const prefix = source === 'yfinance' ? 'yfinance_' : '';
                console.log(`Loading data for timestamp: ${timestamp}, source: ${source}`);
                fetch(`data/ranking_${prefix}${timestamp}.csv?v=` + Date.now())
                    .then(response => response.text())
                    .then(csvText => {
                        rankingData = parseCSV(csvText);
                        console.log(`Ranking ${source} data loaded:`, rankingData);
                        updateTable();
                    })
                    .catch(error => console.error(`Error loading ranking ${source} data:`, error));
            } catch (error) {
                console.error('Error in loadData:', error);
            }
        }

        function updateTable() {
            try {
                const tbody = document.querySelector('#data-table tbody');
                tbody.innerHTML = '';
                const tableData = rankingData.map((item, index) => {
                    const ticker = item.Ticker;
                    return {
                        order: index + 1,
                        ticker,
                        openInterest: Number.isFinite(item['Open Interest']) ? Number(item['Open Interest']).toFixed(0) : '0',
                        oi1d: Number.isFinite(item['OI 1d (%)']) ? Number(item['OI 1d (%)']).toFixed(2) : 'N/A',
                        oi1w: Number.isFinite(item['OI 1w (%)']) ? Number(item['OI 1w (%)']).toFixed(2) : 'N/A',
                        volume: Number.isFinite(item['Volume']) ? Number(item['Volume']).toFixed(0) : '0',
                        vol1d: Number.isFinite(item['Volume 1d (%)']) ? Number(item['Volume 1d (%)']).toFixed(2) : 'N/A',
                        vol1w: Number.isFinite(item['Volume 1w (%)']) ? Number(item['Volume 1w (%)']).toFixed(2) : 'N/A',
                        latestClose: Number.isFinite(item['Latest Close']) ? Number(item['Latest Close']).toFixed(2) : 'N/A',
                        close1d: Number.isFinite(item['Close 1d (%)']) ? Number(item['Close 1d (%)']).toFixed(2) : 'N/A',
                        close1w: Number.isFinite(item['Close 1w (%)']) ? Number(item['Close 1w (%)']).toFixed(2) : 'N/A',
                        realisedVol30: Number.isFinite(item['Realised Volatility 30d (%)']) ? Number(item['Realised Volatility 30d (%)']).toFixed(2) : 'N/A',
                        realisedVol60: Number.isFinite(item['Realised Volatility 60d (%)']) ? Number(item['Realised Volatility 60d (%)']).toFixed(2) : 'N/A',
                        realisedVol100: Number.isFinite(item['Realised Volatility 100d (%)']) ? Number(item['Realised Volatility 100d (%)']).toFixed(2) : 'N/A',
                        realisedVol100_1d: Number.isFinite(item['Realised Volatility 100d 1d (%)']) ? Number(item['Realised Volatility 100d 1d (%)']).toFixed(2) : 'N/A',
                        realisedVol100_1w: Number.isFinite(item['Realised Volatility 100d 1w (%)']) ? Number(item['Realised Volatility 100d 1w (%)']).toFixed(2) : 'N/A',
                        minRealisedVol100: Number.isFinite(item['Min Realised Volatility 100d (1y)']) ? Number(item['Min Realised Volatility 100d (1y)']).toFixed(2) : 'N/A',
                        maxRealisedVol100: Number.isFinite(item['Max Realised Volatility 100d (1y)']) ? Number(item['Max Realised Volatility 100d (1y)']).toFixed(2) : 'N/A',
                        meanRealisedVol100: Number.isFinite(item['Mean Realised Volatility 100d (1y)']) ? Number(item['Mean Realised Volatility 100d (1y)']).toFixed(2) : 'N/A',
                        realisedVol180: Number.isFinite(item['Realised Volatility 180d (%)']) ? Number(item['Realised Volatility 180d (%)']).toFixed(2) : 'N/A',
                        realisedVol252: Number.isFinite(item['Realised Volatility 252d (%)']) ? Number(item['Realised Volatility 252d (%)']).toFixed(2) : 'N/A',
                        weightedIV: Number.isFinite(item['Weighted IV (%)']) ? Number(item['Weighted IV (%)']).toFixed(2) : 'N/A'
                    };
                });

                tableData.sort((a, b) => {
                    let valA = a[currentSort.column];
                    let valB = b[currentSort.column];
                    // Handle numeric columns
                    if (['openInterest', 'volume', 'realisedVol30', 'realisedVol60', 'realisedVol100', 'realisedVol100_1d', 'realisedVol100_1w', 'minRealisedVol100', 'maxRealisedVol100', 'meanRealisedVol100', 'realisedVol180', 'realisedVol252', 'latestClose', 'close1d', 'close1w', 'oi1d', 'oi1w', 'vol1d', 'vol1w', 'weightedIV'].includes(currentSort.column)) {
                        valA = valA === 'N/A' || valA === undefined || isNaN(valA) ? -Infinity : parseFloat(valA);
                        valB = valB === 'N/A' || valB === undefined || isNaN(valB) ? -Infinity : parseFloat(valB);
                    } else if (currentSort.column === 'ticker') {
                        // Case-insensitive string comparison for ticker
                        valA = valA ? String(valA).toLowerCase() : '';
                        valB = valB ? String(valB).toLowerCase() : '';
                    } else if (currentSort.column === 'order') {
                        // Handle order column (numeric)
                        valA = parseInt(valA);
                        valB = parseInt(valB);
                    }
                    if (valA < valB) return currentSort.direction === 'asc' ? -1 : 1;
                    if (valA > valB) return currentSort.direction === 'asc' ? 1 : -1;
                    return 0;
                });

                // Update order based on sort
                tableData.forEach((item, index) => {
                    item.order = index + 1;
                });

                // Populate table
                tableData.forEach(item => {
                    const row = document.createElement('tr');
                    ['order', 'ticker', 'latestClose', 'close1d', 'close1w', 'realisedVol30', 'realisedVol60', 'realisedVol100', 'realisedVol100_1d', 'realisedVol100_1w', 'minRealisedVol100', 'maxRealisedVol100', 'meanRealisedVol100', 'realisedVol180', 'realisedVol252', 'weightedIV', 'volume', 'vol1d', 'vol1w', 'openInterest', 'oi1d', 'oi1w'].forEach(key => {
                        const cell = document.createElement('td');
                        cell.textContent = item[key];
                        row.appendChild(cell);
                    });
                    tbody.appendChild(row);
                });
                console.log('Table updated with sorted data:', tableData);
            } catch (error) {
                console.error('Error updating table:', error);
            }
        }

        function setupSortListeners() {
            try {
                const headers = document.querySelectorAll('#data-table th[data-sort]');
                headers.forEach(header => {
                    const column = header.getAttribute('data-sort');
                    if (column === currentSort.column) {
                        header.classList.add(`sort-${currentSort.direction}`);
                    }
                    header.addEventListener('click', () => {
                        if (currentSort.column === column) {
                            currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                        } else {
                            currentSort.column = column;
                            currentSort.direction = 'desc'; // Default to descending for new columns
                        }
                        headers.forEach(h => {
                            h.classList.remove('sort-asc', 'sort-desc');
                            if (h.getAttribute('data-sort') === currentSort.column) {
                                h.classList.add(`sort-${currentSort.direction}`);
                            }
                        });
                        updateTable();
                    });
                });
            } catch (error) {
                console.error('Error setting up sort listeners:', error);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            try {
                const dateSelect = document.getElementById('date-select');
                const timeSelect = document.getElementById('time-select');
                const sourceSelect = document.getElementById('source-select');
                fetch('data/dates.json?v=' + Date.now())
                    .then(response => response.json())
                    .then(dates => {
                        const uniqueDates = [...new Set(dates.map(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$1-$2-$3')))];
                        uniqueDates.forEach(datePart => {
                            const option = document.createElement('option');
                            option.value = datePart.replace(/-/g, '');
                            option.textContent = datePart;
                            dateSelect.appendChild(option);
                        });
                        if (dateSelect.options.length > 0) {
                            dateSelect.value = dateSelect.options[0].value;
                            updateTimeOptions(dateSelect.value, dates);
                            loadData(dateSelect.value + '_' + timeSelect.value);
                        }
                        dateSelect.addEventListener('change', (e) => {
                            updateTimeOptions(e.target.value, dates);
                            loadData(e.target.value + '_' + timeSelect.value);
                        });
                        timeSelect.addEventListener('change', (e) => {
                            loadData(dateSelect.value + '_' + e.target.value);
                        });
                        sourceSelect.addEventListener('change', () => {
                            console.log('Data source changed to:', sourceSelect.value);
                            loadData(dateSelect.value + '_' + timeSelect.value);
                        });
                    })
                    .catch(error => console.error('Error loading dates:', error));
                setupSortListeners();
            } catch (error) {
                console.error('Error in DOMContentLoaded:', error);
            }
        });
    </script>
</body>
</html>
