<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ticker Ranking</title>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #1C2526;
            color: #FFFFFF;
            margin: 0;
            padding: 20px;
        }
        .data-table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        .data-table th, .data-table td {
            border: 1px solid #FFFFFF;
            padding: 12px;
            text-align: left;
            color: #FFFFFF;
        }
        .data-table th {
            background-color: #2E3537;
            cursor: pointer;
        }
        .data-table th:hover {
            background-color: #3E4547;
        }
        .nav-link {
            color: #00BFFF;
            text-decoration: none;
            padding: 5px;
            display: inline-block;
        }
        .nav-link:hover {
            text-decoration: underline;
        }
        .sort-indicator::after {
            content: '';
            display: inline-block;
            margin-left: 5px;
        }
        .sort-asc::after {
            content: ' ▲';
        }
        .sort-desc::after {
            content: ' ▼';
        }
        select {
            padding: 5px;
            background-color: #2E3537;
            color: #FFFFFF;
            border: 1px solid #FFFFFF;
            border-radius: 4px;
        }
        .controls-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div>
        <a href="index.html" class="nav-link">Back to Main Dashboard</a>
        <a href="vol-surfaces.html" class="nav-link">View Volatility Surfaces</a>
    </div>
    <div class="controls-container">
        <label for="source-select">Select Data Source: </label>
        <select id="source-select">
            <option value="nasdaq">Nasdaq</option>
            <option value="yfinance" selected>yfinance</option>
        </select>
        <label for="date-select">Select Date: </label>
        <select id="date-select"></select>
        <label for="time-select">Select Time: </label>
        <select id="time-select"></select>
    </div>
    <table id="data-table" class="data-table">
        <thead>
            <tr>
                <th data-sort="order">Order</th>
                <th data-sort="ticker">Ticker</th>
                <th data-sort="openInterest">Open Interest</th>
                <th data-sort="oi1d">OI 1d (%)</th>
                <th data-sort="oi1w">OI 1w (%)</th>
                <th data-sort="volume">Volume</th>
                <th data-sort="vol1d">Vol 1d (%)</th>
                <th data-sort="vol1w">Vol 1w (%)</th>
                <th data-sort="latestClose">Latest Close ($)</th>
                <th data-sort="close1d">Close 1d (%)</th>
                <th data-sort="close1w">Close 1w (%)</th>
                <th data-sort="realisedVol30">Rvol 30d (%)</th>
                <th data-sort="realisedVol60">Rvol 60d (%)</th>
                <th data-sort="realisedVol100">Rvol 100d (%)</th>
                <th data-sort="minRealisedVol100">Min Rvol 100d (%)</th>
                <th data-sort="maxRealisedVol100">Max Rvol 100d (%)</th>
                <th data-sort="meanRealisedVol100">Mean Rvol 100d (%)</th>
                <th data-sort="realisedVol180">Rvol 180d (%)</th>
                <th data-sort="realisedVol252">Rvol 252d (%)</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>
    <script>
        let rankingData = [];
        let historicData = [];
        let currentSort = { column: 'openInterest', direction: 'desc' };
        function parseCSV(csvText) {
            try {
                const result = Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    dynamicTyping: true
                });
                return result.data;
            } catch (error) {
                console.error('Error parsing CSV:', error);
                return [];
            }
        }
        function normalizeDate(dateStr) {
            try {
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) throw new Error('Invalid date');
                return date.toLocaleDateString('en-CA');
            } catch (error) {
                console.error('Error normalizing date:', dateStr, error);
                return null;
            }
        }
        function updateTimeOptions(selectedDate, dates) {
            try {
                const timeSelect = document.getElementById('time-select');
                timeSelect.innerHTML = '';
                const formattedSelectedDate = selectedDate.replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3');
                const availableTimes = dates
                    .filter(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$1-$2-$3') === formattedSelectedDate)
                    .map(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$4:$5'));
                const uniqueTimes = [...new Set(availableTimes)];
                uniqueTimes.forEach(timePart => {
                    const option = document.createElement('option');
                    option.value = timePart.replace(':', '');
                    option.textContent = timePart;
                    timeSelect.appendChild(option);
                });
                if (timeSelect.options.length > 0) timeSelect.value = timeSelect.options[0].value;
                console.log('Time options updated:', uniqueTimes);
            } catch (error) {
                console.error('Error updating time options:', error);
            }
        }
        function loadData(timestamp) {
            try {
                const source = document.getElementById('source-select').value;
                const prefix = source === 'yfinance' ? 'yfinance_' : '';
                console.log(`Loading data for timestamp: ${timestamp}, source: ${source}`);
                Promise.all([
                    fetch(`data/ranking_${prefix}${timestamp}.csv?v=` + Date.now())
                        .then(response => response.text())
                        .then(csvText => {
                            rankingData = parseCSV(csvText);
                            console.log(`Ranking ${source} data loaded:`, rankingData);
                        })
                        .catch(error => console.error(`Error loading ranking ${source} data:`, error)),
                    fetch(`data/historic_${timestamp}.csv?v=` + Date.now())
                        .then(response => response.text())
                        .then(csvText => {
                            historicData = parseCSV(csvText);
                            console.log('Historic data loaded:', historicData);
                        })
                        .catch(error => console.error('Error loading historic data:', error))
                ]).then(() => {
                    updateTable();
                });
            } catch (error) {
                console.error('Error in loadData:', error);
            }
        }
        function updateTable() {
            try {
                const tbody = document.querySelector('#data-table tbody');
                tbody.innerHTML = '';
                const tableData = rankingData.map((item, index) => {
                    const ticker = item.Ticker;
                    const tickerHistoricData = historicData.filter(h => h.Ticker === ticker);
                    let realisedVol30 = item['Realised Volatility 30d (%)'] || 'N/A';
                    let realisedVol60 = item['Realised Volatility 60d (%)'] || 'N/A';
                    let realisedVol100 = item['Realised Volatility 100d (%)'] || 'N/A';
                    let minRealisedVol100 = 'N/A';
                    let maxRealisedVol100 = 'N/A';
                    let meanRealisedVol100 = 'N/A';
                    let latestClose = 'N/A';
                    let realisedVol180 = item['Realised Volatility 180d (%)'] || 'N/A';
                    let realisedVol252 = item['Realised Volatility 252d (%)'] || 'N/A';
                    if (tickerHistoricData.length > 0) {
                        tickerHistoricData.sort((a, b) => new Date(b.Date) - new Date(a.Date));
                        const latestHistoric = tickerHistoricData[0];
                        latestClose = Number.isFinite(latestHistoric.Close) ? latestHistoric.Close.toFixed(2) : 'N/A';
                        const rvol100Values = tickerHistoricData
                            .map(h => Number.isFinite(h.Realised_Vol_100) ? h.Realised_Vol_100 : null)
                            .filter(val => val !== null);
                        if (rvol100Values.length > 0) {
                            minRealisedVol100 = Math.min(...rvol100Values).toFixed(2);
                            maxRealisedVol100 = Math.max(...rvol100Values).toFixed(2);
                            const sum = rvol100Values.reduce((a, b) => a + b, 0);
                            meanRealisedVol100 = (sum / rvol100Values.length).toFixed(2);
                        }
                    }
                    return {
                        order: index + 1,
                        ticker,
                        openInterest: item['Open Interest'] || 0,
                        oi1d: item['OI 1d (%)'] || 'N/A',
                        oi1w: item['OI 1w (%)'] || 'N/A',
                        volume: item['Volume'] || 0,
                        vol1d: item['Volume 1d (%)'] || 'N/A',
                        vol1w: item['Volume 1w (%)'] || 'N/A',
                        latestClose,
                        close1d: item['Close 1d (%)'] || 'N/A',
                        close1w: item['Close 1w (%)'] || 'N/A',
                        realisedVol30,
                        realisedVol60,
                        realisedVol100,
                        minRealisedVol100,
                        maxRealisedVol100,
                        meanRealisedVol100,
                        realisedVol180,
                        realisedVol252
                    };
                });
                // Sort the data
                tableData.sort((a, b) => {
                    let valA = a[currentSort.column];
                    let valB = b[currentSort.column];
                    if (['realisedVol30', 'realisedVol60', 'realisedVol100', 'minRealisedVol100', 'maxRealisedVol100', 'meanRealisedVol100', 'realisedVol180', 'realisedVol252', 'latestClose', 'oi1d', 'oi1w', 'vol1d', 'vol1w', 'close1d', 'close1w'].includes(currentSort.column)) {
                        valA = valA === 'N/A' ? -Infinity : parseFloat(valA);
                        valB = valB === 'N/A' ? -Infinity : parseFloat(valB);
                    }
                    if (valA < valB) return currentSort.direction === 'asc' ? -1 : 1;
                    if (valA > valB) return currentSort.direction === 'asc' ? 1 : -1;
                    return 0;
                });
                // Update order based on current sort
                tableData.forEach((item, index) => {
                    item.order = index + 1;
                });
                // Populate table
                tableData.forEach(item => {
                    const row = document.createElement('tr');
                    ['order', 'ticker', 'openInterest', 'oi1d', 'oi1w', 'volume', 'vol1d', 'vol1w', 'latestClose', 'close1d', 'close1w', 'realisedVol30', 'realisedVol60', 'realisedVol100', 'minRealisedVol100', 'maxRealisedVol100', 'meanRealisedVol100', 'realisedVol180', 'realisedVol252'].forEach(key => {
                        const cell = document.createElement('td');
                        cell.textContent = item[key];
                        row.appendChild(cell);
                    });
                    tbody.appendChild(row);
                });
                console.log('Table updated with sorted data:', tableData);
            } catch (error) {
                console.error('Error updating table:', error);
            }
        }
        function setupSortListeners() {
            try {
                const headers = document.querySelectorAll('#data-table th[data-sort]');
                headers.forEach(header => {
                    const column = header.getAttribute('data-sort');
                    // Apply default sort indicator for openInterest
                    if (column === currentSort.column) {
                        header.classList.add(`sort-${currentSort.direction}`);
                    }
                    header.addEventListener('click', () => {
                        if (currentSort.column === column) {
                            currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                        } else {
                            currentSort.column = column;
                            currentSort.direction = 'asc';
                        }
                        headers.forEach(h => {
                            h.classList.remove('sort-asc', 'sort-desc');
                            if (h.getAttribute('data-sort') === currentSort.column) {
                                h.classList.add(`sort-${currentSort.direction}`);
                            }
                        });
                        updateTable();
                    });
                });
            } catch (error) {
                console.error('Error setting up sort listeners:', error);
            }
        }
        document.addEventListener('DOMContentLoaded', () => {
            try {
                const dateSelect = document.getElementById('date-select');
                const timeSelect = document.getElementById('time-select');
                const sourceSelect = document.getElementById('source-select');
                fetch('data/dates.json?v=' + Date.now())
                    .then(response => response.json())
                    .then(dates => {
                        const uniqueDates = [...new Set(dates.map(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$1-$2-$3')))];
                        uniqueDates.forEach(datePart => {
                            const option = document.createElement('option');
                            option.value = datePart.replace(/-/g, '');
                            option.textContent = datePart;
                            dateSelect.appendChild(option);
                        });
                        if (dateSelect.options.length > 0) {
                            dateSelect.value = dateSelect.options[0].value;
                            updateTimeOptions(dateSelect.value, dates);
                            loadData(dateSelect.value + '_' + timeSelect.value);
                        }
                        dateSelect.addEventListener('change', (e) => {
                            updateTimeOptions(e.target.value, dates);
                            loadData(e.target.value + '_' + timeSelect.value);
                        });
                        timeSelect.addEventListener('change', (e) => {
                            loadData(dateSelect.value + '_' + e.target.value);
                        });
                        sourceSelect.addEventListener('change', () => {
                            console.log('Data source changed to:', sourceSelect.value);
                            loadData(dateSelect.value + '_' + timeSelect.value);
                        });
                    })
                    .catch(error => console.error('Error loading dates:', error));
                setupSortListeners();
            } catch (error) {
                console.error('Error in DOMContentLoaded:', error);
            }
        });
    </script>
</body>
</html>
