<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ticker Ranking</title>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            font-size: 0.9em;
            background-color: #1C2526;
            color: #FFFFFF;
            margin: 0;
            padding: 20px;
        }
        .data-table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        .data-table th, .data-table td {
            border: 1px solid #FFFFFF;
            padding: 12px;
            text-align: left;
            color: #FFFFFF;
        }
        .data-table th {
            background-color: #2E3537;
            cursor: pointer;
        }
        .data-table th:hover {
            background-color: #3E4547;
        }
        .nav-link {
            color: #00BFFF;
            text-decoration: none;
            padding: 5px;
            display: inline-block;
        }
        .nav-link:hover {
            text-decoration: underline;
        }
        .sort-indicator::after {
            content: '';
            display: inline-block;
            margin-left: 5px;
        }
        .sort-asc::after {
            content: ' ▲';
        }
        .sort-desc::after {
            content: ' ▼';
        }
        select {
            padding: 5px;
            background-color: #2E3537;
            color: #FFFFFF;
            border: 1px solid #FFFFFF;
            border-radius: 4px;
        }
        .controls-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div>
        <a href="index.html" class="nav-link">Back to Main Dashboard</a>
        <a href="vol-surfaces.html" class="nav-link">View Volatility Surfaces</a>
    </div>
    <div class="controls-container">
        <label for="source-select">Select Data Source: </label>
        <select id="source-select">
            <option value="nasdaq">Nasdaq</option>
            <option value="yfinance" selected>yfinance</option>
        </select>
        <label for="date-select">Select Date: </label>
        <select id="date-select"></select>
        <label for="time-select">Select Time: </label>
        <select id="time-select"></select>
    </div>
    <table id="data-table" class="data-table">
        <thead>
            <tr>
                <th data-sort="order">Rank</th>
                <th data-sort="ticker">Ticker</th>
                <th data-sort="latestClose">Latest Close ($)</th>
                <th data-sort="latestHigh">Latest High ($)</th>
                <th data-sort="latestLow">Latest Low ($)</th>
                <th data-sort="close1d">Close 1d (%)</th>
                <th data-sort="close1w">Close 1w (%)</th>
                <th data-sort="high1d">High 1d (%)</th>
                <th data-sort="high1w">High 1w (%)</th>
                <th data-sort="low1d">Low 1d (%)</th>
                <th data-sort="low1w">Low 1w (%)</th>
                <th data-sort="realisedVolClose30">Rvol Close 30d (%)</th>
                <th data-sort="realisedVolClose60">Rvol Close 60d (%)</th>
                <th data-sort="realisedVolClose100">Rvol Close 100d (%)</th>
                <th data-sort="realisedVolClose100_1d">Rvol Close 100d 1d (%)</th>
                <th data-sort="realisedVolClose100_1w">Rvol Close 100d 1w (%)</th>
                <th data-sort="minRealisedVolClose100">Min Rvol Close 100d (1y)</th>
                <th data-sort="maxRealisedVolClose100">Max Rvol Close 100d (1y)</th>
                <th data-sort="meanRealisedVolClose100">Mean Rvol Close 100d (1y)</th>
                <th data-sort="rvolClose100Percentile">Rvol Close 100d Percentile (%)</th>
                <th data-sort="rvolClose100ZScorePercentile">Rvol Close 100d Z-Score Percentile (%)</th>
                <th data-sort="realisedVolClose180">Rvol Close 180d (%)</th>
                <th data-sort="realisedVolClose252">Rvol Close 252d (%)</th>
                <th data-sort="weightedIV">Weighted IV (%)</th>
                <th data-sort="weightedIV_1d">Weighted IV 1d (%)</th>
                <th data-sort="weightedIV_1w">Weighted IV 1w (%)</th>
                <th data-sort="rvolClose100dMinusWeightedIV">Rvol Close 100d - Weighted IV</th>
                <th data-sort="volume">Volume</th>
                <th data-sort="vol1d">Vol 1d (%)</th>
                <th data-sort="vol1w">Vol 1w (%)</th>
                <th data-sort="openInterest">Open Interest</th>
                <th data-sort="oi1d">OI 1d (%)</th>
                <th data-sort="oi1w">OI 1w (%)</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>
    <script>
        let rankingData = [];
        let currentSort = { column: 'openInterest', direction: 'desc' };

        function parseCSV(csvText) {
            try {
                const result = Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    dynamicTyping: true
                });
                console.log('Parsed CSV data types:', result.data.map(item => ({
                    ticker: typeof item.Ticker,
                    openInterest: { raw: item['Open Interest'], type: typeof item['Open Interest'] },
                    volume: { raw: item['Volume'], type: typeof item['Volume'] },
                    weightedIV: typeof item['Weighted IV (%)'],
                    rvolClose100Percentile: typeof item['Rvol Close 100d Percentile (%)'],
                    rvolClose100ZScorePercentile: typeof item['Rvol Close 100d Z-Score Percentile (%)']
                })));
                return result.data;
            } catch (error) {
                console.error('Error parsing CSV:', error);
                return [];
            }
        }

        function formatNumberWithCommas(number) {
            if (number === 'N/A' || number === null || number === undefined || isNaN(number)) {
                return 'N/A';
            }
            return Number(number).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
        }

        function formatValue(value, isNumericColumn) {
            if (value === 'N/A' || value === null || value === undefined) {
                return 'N/A';
            }
            if (isNumericColumn && Number.isFinite(value)) {
                return Number(value).toFixed(2);
            }
            return value;
        }

        function normalizeDate(dateStr) {
            try {
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) throw new Error('Invalid date');
                return date.toLocaleDateString('en-CA');
            } catch (error) {
                console.error('Error normalizing date:', dateStr, error);
                return null;
            }
        }

        function updateTimeOptions(selectedDate, dates) {
            try {
                const timeSelect = document.getElementById('time-select');
                timeSelect.innerHTML = '';
                const formattedSelectedDate = selectedDate.replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3');
                const availableTimes = dates
                    .filter(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$1-$2-$3') === formattedSelectedDate)
                    .map(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$4:$5'));
                const uniqueTimes = [...new Set(availableTimes)];
                uniqueTimes.forEach(timePart => {
                    const option = document.createElement('option');
                    option.value = timePart.replace(':', '');
                    option.textContent = timePart;
                    timeSelect.appendChild(option);
                });
                if (timeSelect.options.length > 0) timeSelect.value = timeSelect.options[0].value;
                console.log('Time options updated:', uniqueTimes);
            } catch (error) {
                console.error('Error updating time options:', error);
            }
        }

        function loadData(timestamp) {
            try {
                const source = document.getElementById('source-select').value;
                const prefix = source === 'yfinance' ? 'yfinance_' : '';
                console.log(`Loading data for timestamp: ${timestamp}, source: ${source}`);
                fetch(`data/ranking_${prefix}${timestamp}.csv?v=` + Date.now())
                    .then(response => {
                        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                        return response.text();
                    })
                    .then(csvText => {
                        rankingData = parseCSV(csvText);
                        console.log(`Ranking ${source} data loaded:`, rankingData);
                        updateTable();
                    })
                    .catch(error => console.error(`Error loading ranking ${source} data:`, error));
            } catch (error) {
                console.error('Error in loadData:', error);
            }
        }

        function updateTable() {
            try {
                const tbody = document.querySelector('#data-table tbody');
                tbody.innerHTML = '';
                const numericColumns = [
                    'openInterest', 'volume', 'realisedVolClose30', 'realisedVolClose60', 'realisedVolClose100',
                    'realisedVolClose100_1d', 'realisedVolClose100_1w', 'minRealisedVolClose100',
                    'maxRealisedVolClose100', 'meanRealisedVolClose100', 'rvolClose100Percentile',
                    'rvolClose100ZScorePercentile', 'realisedVolClose180', 'realisedVolClose252',
                    'latestClose', 'latestHigh', 'latestLow', 'close1d', 'close1w', 'high1d', 'high1w',
                    'low1d', 'low1w', 'oi1d', 'oi1w', 'vol1d', 'vol1w', 'weightedIV', 'weightedIV_1d',
                    'weightedIV_1w', 'rvolClose100dMinusWeightedIV'
                ];
                const tableData = rankingData.map((item, index) => {
                    const ticker = item.Ticker;
                    const openInterestRaw = item['Open Interest'];
                    const volumeRaw = item['Volume'];
                    console.log(`Formatting for ${ticker}: Open Interest = ${openInterestRaw} (${typeof openInterestRaw}), Volume = ${volumeRaw} (${typeof volumeRaw})`);
                    return {
                        order: index + 1,
                        ticker: item.Ticker || 'N/A',
                        openInterest: formatNumberWithCommas(openInterestRaw),
                        oi1d: formatValue(item['OI 1d (%)'], true),
                        oi1w: formatValue(item['OI 1w (%)'], true),
                        volume: formatNumberWithCommas(volumeRaw),
                        vol1d: formatValue(item['Volume 1d (%)'], true),
                        vol1w: formatValue(item['Volume 1w (%)'], true),
                        latestClose: formatValue(item['Latest Close'], true),
                        latestHigh: formatValue(item['Latest High'], true),
                        latestLow: formatValue(item['Latest Low'], true),
                        close1d: formatValue(item['Close 1d (%)'], true),
                        close1w: formatValue(item['Close 1w (%)'], true),
                        high1d: formatValue(item['High 1d (%)'], true),
                        high1w: formatValue(item['High 1w (%)'], true),
                        low1d: formatValue(item['Low 1d (%)'], true),
                        low1w: formatValue(item['Low 1w (%)'], true),
                        realisedVolClose30: formatValue(item['Realised Volatility Close 30d (%)'], true),
                        realisedVolClose60: formatValue(item['Realised Volatility Close 60d (%)'], true),
                        realisedVolClose100: formatValue(item['Realised Volatility Close 100d (%)'], true),
                        realisedVolClose100_1d: formatValue(item['Realised Volatility Close 100d 1d (%)'], true),
                        realisedVolClose100_1w: formatValue(item['Realised Volatility Close 100d 1w (%)'], true),
                        minRealisedVolClose100: formatValue(item['Min Realised Volatility Close 100d (1y)'], true),
                        maxRealisedVolClose100: formatValue(item['Max Realised Volatility Close 100d (1y)'], true),
                        meanRealisedVolClose100: formatValue(item['Mean Realised Volatility Close 100d (1y)'], true),
                        rvolClose100Percentile: formatValue(item['Rvol Close 100d Percentile (%)'], true),
                        rvolClose100ZScorePercentile: formatValue(item['Rvol Close 100d Z-Score Percentile (%)'], true),
                        realisedVolClose180: formatValue(item['Realised Volatility Close 180d (%)'], true),
                        realisedVolClose252: formatValue(item['Realised Volatility Close 252d (%)'], true),
                        weightedIV: formatValue(item['Weighted IV (%)'], true),
                        weightedIV_1d: formatValue(item['Weighted IV 1d (%)'], true),
                        weightedIV_1w: formatValue(item['Weighted IV 1w (%)'], true),
                        rvolClose100dMinusWeightedIV: formatValue(item['Rvol Close 100d - Weighted IV'], true)
                    };
                });

                tableData.sort((a, b) => {
                    let valA = a[currentSort.column];
                    let valB = b[currentSort.column];
                    if (numericColumns.includes(currentSort.column)) {
                        valA = valA === 'N/A' || valA === undefined || isNaN(valA) ? -Infinity : parseFloat(valA);
                        valB = valB === 'N/A' || valB === undefined || isNaN(valB) ? -Infinity : parseFloat(valB);
                    } else if (currentSort.column === 'ticker') {
                        valA = valA ? String(valA).toLowerCase() : '';
                        valB = valB ? String(valB).toLowerCase() : '';
                    } else if (currentSort.column === 'order') {
                        valA = parseInt(valA);
                        valB = parseInt(valB);
                    }
                    if (valA < valB) return currentSort.direction === 'asc' ? -1 : 1;
                    if (valA > valB) return currentSort.direction === 'asc' ? 1 : -1;
                    return 0;
                });

                tableData.forEach((item, index) => {
                    item.order = index + 1;
                });

                tableData.forEach(item => {
                    const row = document.createElement('tr');
                    const columns = ['order', 'ticker', 'latestClose', 'latestHigh', 'latestLow', 'close1d', 'close1w', 'high1d', 'high1w', 'low1d', 'low1w', 'realisedVolClose30', 'realisedVolClose60', 'realisedVolClose100', 'realisedVolClose100_1d', 'realisedVolClose100_1w', 'minRealisedVolClose100', 'maxRealisedVolClose100', 'meanRealisedVolClose100', 'rvolClose100Percentile', 'rvolClose100ZScorePercentile', 'realisedVolClose180', 'realisedVolClose252', 'weightedIV', 'weightedIV_1d', 'weightedIV_1w', 'rvolClose100dMinusWeightedIV', 'volume', 'vol1d', 'vol1w', 'openInterest', 'oi1d', 'oi1w'];
                    columns.forEach(key => {
                        const cell = document.createElement('td');
                        cell.textContent = item[key];
                        row.appendChild(cell);
                    });
                    tbody.appendChild(row);
                });
                console.log('Table updated with sorted data:', tableData);
            } catch (error) {
                console.error('Error updating table:', error);
            }
        }

        function setupSortListeners() {
            try {
                const headers = document.querySelectorAll('#data-table th[data-sort]');
                headers.forEach(header => {
                    const column = header.getAttribute('data-sort');
                    if (column === currentSort.column) {
                        header.classList.add(`sort-${currentSort.direction}`);
                    }
                    header.addEventListener('click', () => {
                        if (currentSort.column === column) {
                            currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                        } else {
                            currentSort.column = column;
                            currentSort.direction = 'desc';
                        }
                        headers.forEach(h => {
                            h.classList.remove('sort-asc', 'sort-desc');
                            if (h.getAttribute('data-sort') === currentSort.column) {
                                h.classList.add(`sort-${currentSort.direction}`);
                            }
                        });
                        updateTable();
                    });
                });
            } catch (error) {
                console.error('Error setting up sort listeners:', error);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            try {
                const dateSelect = document.getElementById('date-select');
                const timeSelect = document.getElementById('time-select');
                const sourceSelect = document.getElementById('source-select');
                fetch('data/dates.json?v=' + Date.now())
                    .then(response => {
                        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                        return response.text();
                    })
                    .then(data => {
                        const dates = JSON.parse(data);
                        const uniqueDates = [...new Set(dates.map(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$1-$2-$3')))];
                        uniqueDates.forEach(datePart => {
                            const option = document.createElement('option');
                            option.value = datePart.replace(/-/g, '');
                            option.textContent = datePart;
                            dateSelect.appendChild(option);
                        });
                        if (dateSelect.options.length > 0) {
                            dateSelect.value = dateSelect.options[0].value;
                            updateTimeOptions(dateSelect.value, dates);
                            loadData(dateSelect.value + '_' + timeSelect.value);
                        }
                        dateSelect.addEventListener('change', (e) => {
                            updateTimeOptions(e.target.value, dates);
                            loadData(e.target.value + '_' + timeSelect.value);
                        });
                        timeSelect.addEventListener('change', (e) => {
                            loadData(dateSelect.value + '_' + e.target.value);
                        });
                        sourceSelect.addEventListener('change', () => {
                            console.log('Data source changed to:', sourceSelect.value);
                            loadData(dateSelect.value + '_' + timeSelect.value);
                        });
                    })
                    .catch(error => console.error('Error loading dates:', error));
                setupSortListeners();
            } catch (error) {
                console.error('Error in DOMContentLoaded:', error);
            }
        });
    </script>
</body>
</html>
