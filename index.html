<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Options Data Visualisation</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.2.1/dist/chartjs-plugin-annotation.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #1C2526;
            color: #FFFFFF;
            margin: 0;
            padding: 0;
        }
        .chart-container {
            width: 100%;
            background-color: #1C2526;
            padding: 0;
        }
        select, input {
            padding: 5px;
            background-color: #2E3537;
            color: #FFFFFF;
            border: 1px solid #FFFFFF;
            border-radius: 4px;
        }
        .stats-table, .skew-table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        .stats-table th, .stats-table td, .skew-table th, .skew-table td {
            border: 1px solid #FFFFFF;
            padding: 12px;
            text-align: left;
            color: #FFFFFF;
        }
        .stats-table th, .skew-table th {
            background-color: #2E3537;
        }
        .summary-table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        .summary-table th, .summary-table td {
            border: 1px solid #FFFFFF;
            padding: 12px;
            text-align: left;
        }
        .summary-table th {
            background-color: #2E3537;
        }
        .line-swatch {
            display: inline-block;
            vertical-align: middle;
            margin-right: 5px;
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 5px;
            width: 100%;
            margin: 0;
        }
        .full-width {
            grid-column: span 2;
        }
        .date-time-container, .source-container {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px;
        }
        #ticker-search {
            width: 200px;
        }
        #ticker-datalist {
            background-color: #2E3537;
            color: #FFFFFF;
        }
        .select-container {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px;
        }
        .arrow-button, .toggle-button {
            background-color: #2E3537;
            color: #FFFFFF;
            border: 1px solid #FFFFFF;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
        }
        .arrow-button:hover, .toggle-button:hover {
            background-color: #3E4547;
        }
        .nav-link {
            color: #00BFFF;
            text-decoration: none;
            padding: 5px;
            display: inline-block;
        }
        .nav-link:hover {
            text-decoration: underline;
        }
        #historic-error {
            color: #FF6666;
            padding: 5px;
        }
    </style>
</head>
<body>
    <div>
        <a href="data-table.html" class="nav-link">View Data Table</a>
        <a href="vol-surfaces.html" class="nav-link">View Volatility Surfaces</a>
        <a href="ticker-ranking.html" class="nav-link">View Ticker Ranking</a>
    </div>
    <div class="date-time-container">
        <label for="source-select">Select Data Source: </label>
        <select id="source-select">
            <option value="nasdaq">Nasdaq</option>
            <option value="yfinance" selected>yfinance</option>
        </select>
        <label for="date-select">Select Date: </label>
        <select id="date-select"></select>
        <label for="time-select">Select Time: </label>
        <select id="time-select"></select>
        <button class="toggle-button" onclick="toggleStatsTables()">Show Stats Tables</button>
    </div>
    <div>
        <label for="ticker-search">Search Ticker: </label>
        <input type="text" id="ticker-search" list="ticker-datalist" placeholder="Type to search ticker...">
        <datalist id="ticker-datalist"></datalist>
    </div>
    <div class="grid-container">
        <div class="chart-container">
            <h2>Summary</h2>
            <table id="summary-table" class="summary-table"></table>
            <table id="skew-table" class="skew-table"></table>
        </div>
        <div class="chart-container">
            <h2>Moneyness vs. Volatility</h2>
            <div class="select-container">
                <label for="expiry-select">Select Expiry: </label>
                <button class="arrow-button" onclick="changeSelect('expiry-select', -1)">&#9664;</button>
                <select id="expiry-select"></select>
                <button class="arrow-button" onclick="changeSelect('expiry-select', 1)">&#9654;</button>
            </div>
            <canvas id="moneyness-vs-iv-chart" tabindex="0"></canvas>
        </div>
        <div class="chart-container">
            <h2>Expiry vs. Volatility</h2>
            <div class="select-container">
                <label for="moneyness-select">Select Moneyness: </label>
                <button class="arrow-button" onclick="changeSelect('moneyness-select', -1)">&#9664;</button>
                <select id="moneyness-select"></select>
                <button class="arrow-button" onclick="changeSelect('moneyness-select', 1)">&#9654;</button>
            </div>
            <canvas id="expiry-vs-iv-chart" tabindex="0"></canvas>
        </div>
        <div class="chart-container">
            <h2>Delta vs. Volatility</h2>
            <div class="select-container">
                <label for="delta-expiry-select">Select Expiry: </label>
                <button class="arrow-button" onclick="changeSelect('delta-expiry-select', -1)">&#9664;</button>
                <select id="delta-expiry-select"></select>
                <button class="arrow-button" onclick="changeSelect('delta-expiry-select', 1)">&#9654;</button>
            </div>
            <canvas id="delta-vs-iv-chart" tabindex="0"></canvas>
        </div>
        <div class="chart-container">
            <h2>Total Volume by Ticker</h2>
            <canvas id="volume-chart" tabindex="0"></canvas>
        </div>
        <div class="chart-container">
            <h2>Total Open Interest by Ticker</h2>
            <canvas id="open-interest-chart" tabindex="0"></canvas>
        </div>
    </div>
    <div class="chart-container full-width">
        <h2>Historic Stock Price with Realised Volatility</h2>
        <div class="select-container">
            <label for="history-select">Select History Length: </label>
            <button class="arrow-button" onclick="changeSelect('history-select', -1)">&#9664;</button>
            <select id="history-select">
                <option value="1m">1-month</option>
                <option value="3m">3-month</option>
                <option value="6m">6-month</option>
                <option value="1y">1-year</option>
                <option value="5y">5-year</option>
                <option value="all" selected>All</option>
            </select>
            <button class="arrow-button" onclick="changeSelect('history-select', 1)">&#9654;</button>
        </div>
        <canvas id="historic-price-chart" tabindex="0"></canvas>
        <div id="historic-error" style="display: none;">No historic data available</div>
    </div>
    <script>
        let data = [];
        let historicData = [];
        let skewData = [];
        let slopeData = [];
        let eventsData = [];
        let rawData = [];
        let rankingData = [];
        let moneynessChart, expiryChart, deltaChart, historicChart, volumeChart, openInterestChart;
        let statsTablesVisible = false;
        function parseCSV(csvText) {
            try {
                const result = Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    dynamicTyping: true
                });
                return result.data;
            } catch (error) {
                console.error('Error parsing CSV:', error);
                return [];
            }
        }
        function normalizeDate(dateStr) {
            try {
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) throw new Error('Invalid date');
                return date.toLocaleDateString('en-CA');
            } catch (error) {
                console.error('Error normalizing date:', dateStr, error);
                return null;
            }
        }
        function calculateDateRange(historyLength) {
            try {
                const now = new Date();
                let fromDate = new Date();
                switch (historyLength) {
                    case '1m':
                        fromDate.setMonth(now.getMonth() - 1);
                        break;
                    case '3m':
                        fromDate.setMonth(now.getMonth() - 3);
                        break;
                    case '6m':
                        fromDate.setMonth(now.getMonth() - 6);
                        break;
                    case '1y':
                        fromDate.setFullYear(now.getFullYear() - 1);
                        break;
                    case '5y':
                        fromDate.setFullYear(now.getFullYear() - 5);
                        break;
                    case 'all':
                    default:
                        return null;
                }
                return fromDate;
            } catch (error) {
                console.error('Error calculating date range:', error);
                return null;
            }
        }
        function changeSelect(selectId, direction) {
            try {
                const select = document.getElementById(selectId);
                let newIndex = select.selectedIndex + direction;
                if (newIndex < 0) newIndex = select.options.length - 1;
                if (newIndex >= select.options.length) newIndex = 0;
                select.selectedIndex = newIndex;
                const changeEvent = new Event('change', { bubbles: true });
                select.dispatchEvent(changeEvent);
                console.log(`Changed ${selectId} to:`, select.value);
            } catch (error) {
                console.error('Error in changeSelect:', error);
            }
        }
        function toggleStatsTables() {
            try {
                statsTablesVisible = !statsTablesVisible;
                const statsTables = document.querySelectorAll('.stats-table:not(#historic-price-chart + .stats-table)');
                statsTables.forEach(table => {
                    table.style.display = statsTablesVisible ? 'table' : 'none';
                });
                const toggleButton = document.querySelector('.toggle-button');
                toggleButton.textContent = statsTablesVisible ? 'Hide Stats Tables' : 'Show Stats Tables';
                console.log(`Stats tables visibility set to: ${statsTablesVisible}`);
            } catch (error) {
                console.error('Error in toggleStatsTables:', error);
            }
        }
        document.addEventListener('DOMContentLoaded', () => {
            try {
                const dateSelect = document.getElementById('date-select');
                const timeSelect = document.getElementById('time-select');
                const tickerSearch = document.getElementById('ticker-search');
                const sourceSelect = document.getElementById('source-select');
                fetch('data/dates.json?v=' + Date.now())
                    .then(response => response.json())
                    .then(dates => {
                        const uniqueDates = [...new Set(dates.map(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$1-$2-$3')))];
                        uniqueDates.forEach(datePart => {
                            const option = document.createElement('option');
                            option.value = datePart.replace(/-/g, '');
                            option.textContent = datePart;
                            dateSelect.appendChild(option);
                        });
                        if (dateSelect.options.length > 0) {
                            dateSelect.value = dateSelect.options[0].value;
                            updateTimeOptions(dateSelect.value, dates);
                            loadData(dateSelect.value + '_' + timeSelect.value);
                        }
                        dateSelect.addEventListener('change', (e) => {
                            updateTimeOptions(e.target.value, dates);
                            loadData(e.target.value + '_' + timeSelect.value);
                        });
                        timeSelect.addEventListener('change', (e) => {
                            loadData(dateSelect.value + '_' + e.target.value);
                        });
                        tickerSearch.addEventListener('change', () => {
                            console.log('Ticker changed to:', tickerSearch.value);
                            loadData(dateSelect.value + '_' + timeSelect.value);
                        });
                        sourceSelect.addEventListener('change', () => {
                            console.log('Data source changed to:', sourceSelect.value);
                            loadData(dateSelect.value + '_' + timeSelect.value);
                        });
                        const historySelect = document.getElementById('history-select');
                        historySelect.addEventListener('change', () => {
                            console.log('History length changed to:', historySelect.value);
                            updateHistoricChart();
                        });
                    })
                    .catch(error => console.error('Error loading dates:', error));
            } catch (error) {
                console.error('Error in DOMContentLoaded:', error);
            }
        });
        function updateTimeOptions(selectedDate, dates) {
            try {
                const timeSelect = document.getElementById('time-select');
                timeSelect.innerHTML = '';
                const formattedSelectedDate = selectedDate.replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3');
                const availableTimes = dates
                    .filter(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$1-$2-$3') === formattedSelectedDate)
                    .map(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$4:$5'));
                const uniqueTimes = [...new Set(availableTimes)];
                uniqueTimes.forEach(timePart => {
                    const option = document.createElement('option');
                    option.value = timePart.replace(':', '');
                    option.textContent = timePart;
                    timeSelect.appendChild(option);
                });
                if (timeSelect.options.length > 0) timeSelect.value = timeSelect.options[0].value;
                console.log('Time options updated:', uniqueTimes);
            } catch (error) {
                console.error('Error updating time options:', error);
            }
        }
        function loadData(timestamp) {
            try {
                const source = document.getElementById('source-select').value;
                const prefix = source === 'yfinance' ? '_yfinance' : '';
                let selectedTicker = document.getElementById('ticker-search').value.toUpperCase() || 'COIN';
                console.log(`Loading data for timestamp: ${timestamp}, source: ${source}, ticker: ${selectedTicker}`);
                const checkFileExists = (url) => {
                    return fetch(url, { method: 'HEAD' })
                        .then(response => response.ok)
                        .catch(() => false);
                };
                // Step 1: Load ranking data to populate tickers
                fetch(`data/${timestamp}/ranking/ranking${prefix}.csv?v=` + Date.now())
                    .then(response => {
                        if (!response.ok) throw new Error(`Ranking file not found: data/${timestamp}/ranking/ranking${prefix}.csv`);
                        return response.text();
                    })
                    .then(csvText => {
                        const rankingData = parseCSV(csvText);
                        console.log(`Ranking ${source} data loaded:`, rankingData);
                        // Populate ticker-search dropdown
                        const tickerSearch = document.getElementById('ticker-search');
                        const tickerDatalist = document.getElementById('ticker-datalist');
                        tickerDatalist.innerHTML = '';
                        const uniqueTickers = [...new Set(rankingData.map(item => item.Ticker))]
                            .filter(val => val).sort();
                        uniqueTickers.forEach(val => {
                            const option = document.createElement('option');
                            option.value = val;
                            tickerDatalist.appendChild(option);
                        });
                        // Set default ticker if current selection is invalid
                        if (!uniqueTickers.includes(selectedTicker)) {
                            selectedTicker = uniqueTickers.includes('COIN') ? 'COIN' : uniqueTickers[0] || '';
                            tickerSearch.value = selectedTicker;
                        }
                        console.log('Ticker search populated, selected:', selectedTicker);
                        // Step 2: Load ticker-specific data if a ticker is selected
                        if (selectedTicker) {
                            Promise.all([
                                checkFileExists(`data/${timestamp}/processed${prefix}/processed${prefix}_${selectedTicker}.csv`),
                                checkFileExists(`data/${timestamp}/raw${prefix}/raw${prefix}_${selectedTicker}.csv`),
                                checkFileExists(`data/${timestamp}/skew_metrics${prefix}/skew_metrics${prefix}_${selectedTicker}.csv`),
                                checkFileExists(`data/${timestamp}/slope_metrics${prefix}/slope_metrics${prefix}_${selectedTicker}.csv`),
                                checkFileExists(`data/${timestamp}/historic/historic_${selectedTicker}.csv`),
                                checkFileExists(`data/Events.csv`)
                            ]).then(([processedExists, rawExists, skewExists, slopeExists, historicExists, eventsExists]) => {
                                if (!processedExists) console.error(`Processed file data/${timestamp}/processed${prefix}/processed${prefix}_${selectedTicker}.csv not found`);
                                if (!rawExists) console.error(`Raw file data/${timestamp}/raw${prefix}/raw${prefix}_${selectedTicker}.csv not found`);
                                if (!skewExists) console.error(`Skew metrics file data/${timestamp}/skew_metrics${prefix}/skew_metrics${prefix}_${selectedTicker}.csv not found`);
                                if (!slopeExists) console.error(`Slope metrics file data/${timestamp}/slope_metrics${prefix}/slope_metrics${prefix}_${selectedTicker}.csv not found`);
                                if (!historicExists) console.error(`Historic file data/${timestamp}/historic/historic_${selectedTicker}.csv not found`);
                                if (!eventsExists) console.error(`Events file data/Events.csv not found`);
                                fetch(`data/${timestamp}/processed${prefix}/processed${prefix}_${selectedTicker}.csv?v=` + Date.now())
                                    .then(response => response.text())
                                    .then(csvText => {
                                        data = parseCSV(csvText);
                                        console.log(`Processed ${source} data loaded for ${selectedTicker}:`, data);
                                        updateDropdowns();
                                        updateCharts();
                                    })
                                    .catch(error => {
                                        console.error(`Error loading processed ${source} data for ${selectedTicker}:`, error);
                                        data = [];
                                        updateDropdowns();
                                        updateCharts();
                                    });
                                fetch(`data/${timestamp}/raw${prefix}/raw${prefix}_${selectedTicker}.csv?v=` + Date.now())
                                    .then(response => response.text())
                                    .then(csvText => {
                                        rawData = parseCSV(csvText);
                                        console.log(`Raw ${source} data loaded for ${selectedTicker}:`, rawData);
                                        updateSummaryTable();
                                        updateVolumeChart();
                                        updateOpenInterestChart();
                                    })
                                    .catch(error => {
                                        console.error(`Error loading raw ${source} data for ${selectedTicker}:`, error);
                                        rawData = [];
                                        updateSummaryTable();
                                        updateVolumeChart();
                                        updateOpenInterestChart();
                                    });
                                fetch(`data/${timestamp}/skew_metrics${prefix}/skew_metrics${prefix}_${selectedTicker}.csv?v=` + Date.now())
                                    .then(response => response.text())
                                    .then(csvText => {
                                        skewData = parseCSV(csvText);
                                        console.log(`Skew ${source} data loaded for ${selectedTicker}:`, skewData);
                                        updateSkewTable();
                                        updateSummaryTable();
                                    })
                                    .catch(error => {
                                        console.error(`Error loading skew ${source} metrics for ${selectedTicker}:`, error);
                                        skewData = [];
                                        updateSkewTable();
                                        updateSummaryTable();
                                    });
                                fetch(`data/${timestamp}/slope_metrics${prefix}/slope_metrics${prefix}_${selectedTicker}.csv?v=` + Date.now())
                                    .then(response => response.text())
                                    .then(csvText => {
                                        slopeData = parseCSV(csvText);
                                        console.log(`Slope ${source} data loaded for ${selectedTicker}:`, slopeData);
                                        updateSummaryTable();
                                    })
                                    .catch(error => {
                                        console.error(`Error loading slope ${source} metrics for ${selectedTicker}:`, error);
                                        slopeData = [];
                                        updateSummaryTable();
                                    });
                                fetch(`data/${timestamp}/historic/historic_${selectedTicker}.csv?v=` + Date.now())
                                    .then(response => response.text())
                                    .then(csvText => {
                                        historicData = parseCSV(csvText);
                                        console.log(`Historic data loaded for ${selectedTicker}:`, historicData);
                                        document.getElementById('historic-error').style.display = 'none';
                                        updateHistoricChart();
                                    })
                                    .catch(error => {
                                        console.error(`Error loading historic data for ${selectedTicker}:`, error);
                                        historicData = [];
                                        document.getElementById('historic-error').style.display = 'block';
                                        updateHistoricChart();
                                    });
                                fetch(`data/Events.csv?v=` + Date.now())
                                    .then(response => response.text())
                                    .then(csvText => {
                                        eventsData = parseCSV(csvText);
                                        console.log('Events data loaded:', eventsData);
                                        updateHistoricChart();
                                    })
                                    .catch(error => {
                                        console.error('Error loading events data:', error);
                                        eventsData = [];
                                        updateHistoricChart();
                                    });
                            });
                        } else {
                            console.warn('No ticker selected, skipping data load');
                            data = [];
                            rawData = [];
                            skewData = [];
                            slopeData = [];
                            historicData = [];
                            eventsData = [];
                            updateDropdowns();
                            updateCharts();
                        }
                    })
                    .catch(error => {
                        console.error(`Error loading ranking ${source} data:`, error);
                        document.getElementById('ticker-search').value = '';
                        document.getElementById('ticker-datalist').innerHTML = '';
                        data = [];
                        rawData = [];
                        skewData = [];
                        slopeData = [];
                        historicData = [];
                        eventsData = [];
                        updateDropdowns();
                        updateCharts();
                    });
            } catch (error) {
                console.error('Error in loadData:', error);
            }
        }
        function populateTickerSearch() {
            try {
                const tickerSearch = document.getElementById('ticker-search');
                const tickerDatalist = document.getElementById('ticker-datalist');
                tickerDatalist.innerHTML = '';
                const uniqueTickers = [...new Set(data.map(item => item.Ticker))]
                    .filter(val => val).sort();
                uniqueTickers.forEach(val => {
                    const option = document.createElement('option');
                    option.value = val;
                    tickerDatalist.appendChild(option);
                });
                if (uniqueTickers.includes('COIN')) {
                    tickerSearch.value = 'COIN';
                } else if (uniqueTickers.length > 0) {
                    tickerSearch.value = uniqueTickers[0];
                }
                console.log('Ticker search populated, default:', tickerSearch.value);
            } catch (error) {
                console.error('Error populating ticker search:', error);
            }
        }
        function updateDropdowns() {
            try {
                const tickerSearch = document.getElementById('ticker-search');
                const selectedTicker = tickerSearch.value.toUpperCase();
                const tickerData = data.filter(item => item.Ticker === selectedTicker);
                console.log('Updating dropdowns for ticker:', selectedTicker, 'Data size:', tickerData.length);
                const moneynessSelect = document.getElementById('moneyness-select');
                const expirySelect = document.getElementById('expiry-select');
                const deltaExpirySelect = document.getElementById('delta-expiry-select');
                const prevMoneyness = moneynessSelect.value;
                const prevExpiry = expirySelect.value;
                const uniqueRoundedMoneyness = [...new Set(tickerData.map(item => Math.round(item.Moneyness * 100 / 10) * 0.1))]
                    .filter(val => !isNaN(val)).sort((a, b) => a - b);
                moneynessSelect.innerHTML = '';
                uniqueRoundedMoneyness.forEach(val => {
                    const option = document.createElement('option');
                    option.value = val;
                    option.text = `${(val * 100).toFixed(0)}%`;
                    moneynessSelect.add(option);
                });
                const targetMoneyness = 1.0;
                let closestMoneyness = uniqueRoundedMoneyness.reduce((prev, curr) =>
                    Math.abs(curr - targetMoneyness) < Math.abs(prev - targetMoneyness) ? curr : prev,
                    uniqueRoundedMoneyness[0]
                );
                if (prevMoneyness && uniqueRoundedMoneyness.map(v => v.toString()).includes(prevMoneyness)) {
                    moneynessSelect.value = prevMoneyness;
                } else if (uniqueRoundedMoneyness.includes(targetMoneyness)) {
                    moneynessSelect.value = targetMoneyness.toString();
                } else if (uniqueRoundedMoneyness.length > 0) {
                    moneynessSelect.value = closestMoneyness.toString();
                }
                console.log('Moneyness dropdown updated, selected:', moneynessSelect.value);
                const uniqueExpiries = [...new Set(tickerData.map(item => item.Expiry))]
                    .filter(val => val).sort((a, b) => new Date(a) - new Date(b));
                expirySelect.innerHTML = '';
                deltaExpirySelect.innerHTML = '';
                uniqueExpiries.forEach(val => {
                    const option = document.createElement('option');
                    option.value = val;
                    option.text = new Date(val).toLocaleDateString('en-GB');
                    expirySelect.add(option);
                    deltaExpirySelect.add(option.cloneNode(true));
                });
                if (prevExpiry && uniqueExpiries.includes(prevExpiry)) {
                    expirySelect.value = prevExpiry;
                    deltaExpirySelect.value = prevExpiry;
                } else if (expirySelect.options.length > 0) {
                    expirySelect.value = expirySelect.options[0].value;
                    deltaExpirySelect.value = expirySelect.options[0].value;
                }
                console.log('Expiry dropdowns updated, selected:', expirySelect.value);
            } catch (error) {
                console.error('Error updating dropdowns:', error);
            }
        }
        function updateSkewTable() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const selectedExpiry = document.getElementById('expiry-select').value;
                const normalizedSelectedExpiry = normalizeDate(selectedExpiry);
                const table = document.getElementById('skew-table');
                table.innerHTML = '';
                const filteredSkewData = skewData.filter(item => item.Ticker === selectedTicker);
                console.log('Updating skew table for ticker:', selectedTicker, 'Expiry:', normalizedSelectedExpiry, 'Skew data size:', filteredSkewData.length);
                if (filteredSkewData.length === 0) {
                    const row = document.createElement('tr');
                    const cell = document.createElement('td');
                    cell.textContent = 'No skew metrics available';
                    cell.colSpan = 6;
                    row.appendChild(cell);
                    table.appendChild(row);
                    return;
                }
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                ['Expiry', 'Skew 25 Delta', 'Skew 75 Delta', 'Skew Call 25/75', 'Skew Put 25/75', 'ATM 12m/3m Ratio'].forEach(text => {
                    const th = document.createElement('th');
                    th.textContent = text;
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);
                table.appendChild(thead);
                const tbody = document.createElement('tbody');
                const selectedRow = filteredSkewData.find(item => normalizeDate(item.Expiry) === normalizedSelectedExpiry);
                if (selectedRow) {
                    const row = document.createElement('tr');
                    const expiryCell = document.createElement('td');
                    expiryCell.textContent = new Date(selectedRow.Expiry).toLocaleDateString('en-GB');
                    row.appendChild(expiryCell);
                    const skew25Cell = document.createElement('td');
                    skew25Cell.textContent = Number.isFinite(selectedRow.Skew_25_delta) ? selectedRow.Skew_25_delta.toFixed(4) : 'N/A';
                    row.appendChild(skew25Cell);
                    const skew75Cell = document.createElement('td');
                    skew75Cell.textContent = Number.isFinite(selectedRow.Skew_75_delta) ? selectedRow.Skew_75_delta.toFixed(4) : 'N/A';
                    row.appendChild(skew75Cell);
                    const skewCallCell = document.createElement('td');
                    skewCallCell.textContent = Number.isFinite(selectedRow.Skew_call_25_75) ? selectedRow.Skew_call_25_75.toFixed(4) : 'N/A';
                    row.appendChild(skewCallCell);
                    const skewPutCell = document.createElement('td');
                    skewPutCell.textContent = Number.isFinite(selectedRow.Skew_put_25_75) ? selectedRow.Skew_put_25_75.toFixed(4) : 'N/A';
                    row.appendChild(skewPutCell);
                    const atmRatioCell = document.createElement('td');
                    atmRatioCell.textContent = Number.isFinite(selectedRow.ATM_12m_3m_Ratio) ? selectedRow.ATM_12m_3m_Ratio.toFixed(4) : 'N/A';
                    row.appendChild(atmRatioCell);
                    tbody.appendChild(row);
                } else {
                    const row = document.createElement('tr');
                    const cell = document.createElement('td');
                    cell.textContent = 'No data for selected expiry';
                    cell.colSpan = 6;
                    row.appendChild(cell);
                    tbody.appendChild(row);
                }
                table.appendChild(tbody);
            } catch (error) {
                console.error('Error updating skew table:', error);
            }
        }
        function updateSummaryTable() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const selectedExpiry = document.getElementById('expiry-select').value;
                const normalizedSelectedExpiry = normalizeDate(selectedExpiry);
                const source = document.getElementById('source-select').value;
                const table = document.getElementById('summary-table');
                table.innerHTML = '';
                console.log('Updating summary table for ticker:', selectedTicker, 'Expiry:', normalizedSelectedExpiry, 'Source:', source);
        
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                ['Metric', 'Value', 'Metric', 'Value'].forEach(text => {
                    const th = document.createElement('th');
                    th.textContent = text;
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);
                table.appendChild(thead);
        
                const tbody = document.createElement('tbody');
                const changeMetrics = [
                    'Close 1d (%)', 'Close 1w (%)', 'High 1d (%)', 'High 1w (%)', 'Low 1d (%)', 'Low 1w (%)',
                    'Rvol 100d 1d (%)', 'Rvol 100d 1w (%)', 'Vol 1d (%)', 'Vol 1w (%)', 'OI 1d (%)', 'OI 1w (%)',
                    'Weighted IV 1d (%)', 'Weighted IV 1w (%)'
                ];
        
                // Collect metrics from rankingData
                const metrics = [];
                const filteredRankingData = rankingData.find(item => item.Ticker === selectedTicker);
                if (filteredRankingData) {
                    metrics.push(
                        { name: 'Rank', value: filteredRankingData['Rank'] || 'N/A', key: 'Rank' },
                        { name: 'Ticker', value: filteredRankingData['Ticker'] || 'N/A', key: 'Ticker' },
                        { name: 'Latest Close ($)', value: Number.isFinite(filteredRankingData['Latest Close']) ? filteredRankingData['Latest Close'].toFixed(2) : 'N/A', key: 'Latest Close' },
                        { name: 'Latest High ($)', value: Number.isFinite(filteredRankingData['Latest High']) ? filteredRankingData['Latest High'].toFixed(2) : 'N/A', key: 'Latest High' },
                        { name: 'Latest Low ($)', value: Number.isFinite(filteredRankingData['Latest Low']) ? filteredRankingData['Latest Low'].toFixed(2) : 'N/A', key: 'Latest Low' },
                        { name: 'Close 1d (%)', value: Number.isFinite(filteredRankingData['Close 1d (%)']) ? filteredRankingData['Close 1d (%)'].toFixed(2) : 'N/A', key: 'Close 1d (%)' },
                        { name: 'Close 1w (%)', value: Number.isFinite(filteredRankingData['Close 1w (%)']) ? filteredRankingData['Close 1w (%)'].toFixed(2) : 'N/A', key: 'Close 1w (%)' },
                        { name: 'High 1d (%)', value: Number.isFinite(filteredRankingData['High 1d (%)']) ? filteredRankingData['High 1d (%)'].toFixed(2) : 'N/A', key: 'High 1d (%)' },
                        { name: 'High 1w (%)', value: Number.isFinite(filteredRankingData['High 1w (%)']) ? filteredRankingData['High 1w (%)'].toFixed(2) : 'N/A', key: 'High 1w (%)' },
                        { name: 'Low 1d (%)', value: Number.isFinite(filteredRankingData['Low 1d (%)']) ? filteredRankingData['Low 1d (%)'].toFixed(2) : 'N/A', key: 'Low 1d (%)' },
                        { name: 'Low 1w (%)', value: Number.isFinite(filteredRankingData['Low 1w (%)']) ? filteredRankingData['Low 1w (%)'].toFixed(2) : 'N/A', key: 'Low 1w (%)' },
                        { name: 'Rvol 30d (%)', value: Number.isFinite(filteredRankingData['Realised Volatility 30d (%)']) ? filteredRankingData['Realised Volatility 30d (%)'].toFixed(2) : 'N/A', key: 'Realised Volatility 30d (%)' },
                        { name: 'Rvol 60d (%)', value: Number.isFinite(filteredRankingData['Realised Volatility 60d (%)']) ? filteredRankingData['Realised Volatility 60d (%)'].toFixed(2) : 'N/A', key: 'Realised Volatility 60d (%)' },
                        { name: 'Rvol 100d (%)', value: Number.isFinite(filteredRankingData['Realised Volatility 100d (%)']) ? filteredRankingData['Realised Volatility 100d (%)'].toFixed(2) : 'N/A', key: 'Realised Volatility 100d (%)' },
                        { name: 'Rvol 100d 1d (%)', value: Number.isFinite(filteredRankingData['Realised Volatility 100d 1d (%)']) ? filteredRankingData['Realised Volatility 100d 1d (%)'].toFixed(2) : 'N/A', key: 'Realised Volatility 100d 1d (%)' },
                        { name: 'Rvol 100d 1w (%)', value: Number.isFinite(filteredRankingData['Realised Volatility 100d 1w (%)']) ? filteredRankingData['Realised Volatility 100d 1w (%)'].toFixed(2) : 'N/A', key: 'Realised Volatility 100d 1w (%)' },
                        { name: 'Min Rvol 100d (1y)', value: Number.isFinite(filteredRankingData['Min Realised Volatility 100d (1y)']) ? filteredRankingData['Min Realised Volatility 100d (1y)'].toFixed(2) : 'N/A', key: 'Min Realised Volatility 100d (1y)' },
                        { name: 'Max Rvol 100d (1y)', value: Number.isFinite(filteredRankingData['Max Realised Volatility 100d (1y)']) ? filteredRankingData['Max Realised Volatility 100d (1y)'].toFixed(2) : 'N/A', key: 'Max Realised Volatility 100d (1y)' },
                        { name: 'Mean Rvol 100d (1y)', value: Number.isFinite(filteredRankingData['Mean Realised Volatility 100d (1y)']) ? filteredRankingData['Mean Realised Volatility 100d (1y)'].toFixed(2) : 'N/A', key: 'Mean Realised Volatility 100d (1y)' },
                        { name: 'Rvol 100d Percentile (%)', value: Number.isFinite(filteredRankingData['Rvol 100d Percentile (%)']) ? filteredRankingData['Rvol 100d Percentile (%)'].toFixed(2) : 'N/A', key: 'Rvol 100d Percentile (%)' },
                        { name: 'Rvol 100d Z-Score Percentile (%)', value: Number.isFinite(filteredRankingData['Rvol 100d Z-Score Percentile (%)']) ? filteredRankingData['Rvol 100d Z-Score Percentile (%)'].toFixed(2) : 'N/A', key: 'Rvol 100d Z-Score Percentile (%)' },
                        { name: 'Rvol 180d (%)', value: Number.isFinite(filteredRankingData['Realised Volatility 180d (%)']) ? filteredRankingData['Realised Volatility 180d (%)'].toFixed(2) : 'N/A', key: 'Realised Volatility 180d (%)' },
                        { name: 'Rvol 252d (%)', value: Number.isFinite(filteredRankingData['Realised Volatility 252d (%)']) ? filteredRankingData['Realised Volatility 252d (%)'].toFixed(2) : 'N/A', key: 'Realised Volatility 252d (%)' },
                        { name: 'Weighted IV (%)', value: Number.isFinite(filteredRankingData['Weighted IV (%)']) ? filteredRankingData['Weighted IV (%)'].toFixed(2) : 'N/A', key: 'Weighted IV (%)' },
                        { name: 'Weighted IV 1d (%)', value: Number.isFinite(filteredRankingData['Weighted IV 1d (%)']) ? filteredRankingData['Weighted IV 1d (%)'].toFixed(2) : 'N/A', key: 'Weighted IV 1d (%)' },
                        { name: 'Weighted IV 1w (%)', value: Number.isFinite(filteredRankingData['Weighted IV 1w (%)']) ? filteredRankingData['Weighted IV 1w (%)'].toFixed(2) : 'N/A', key: 'Weighted IV 1w (%)' },
                        { name: 'Rvol 100d - Weighted IV', value: Number.isFinite(filteredRankingData['Rvol100d - Weighted IV']) ? filteredRankingData['Rvol100d - Weighted IV'].toFixed(2) : 'N/A', key: 'Rvol100d - Weighted IV' },
                        { name: 'Volume', value: Number.isFinite(filteredRankingData['Volume']) ? Number(filteredRankingData['Volume']).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 }) : 'N/A', key: 'Volume' },
                        { name: 'Vol 1d (%)', value: Number.isFinite(filteredRankingData['Volume 1d (%)']) ? filteredRankingData['Volume 1d (%)'].toFixed(2) : 'N/A', key: 'Volume 1d (%)' },
                        { name: 'Vol 1w (%)', value: Number.isFinite(filteredRankingData['Volume 1w (%)']) ? filteredRankingData['Volume 1w (%)'].toFixed(2) : 'N/A', key: 'Volume 1w (%)' },
                        { name: 'Open Interest', value: Number.isFinite(filteredRankingData['Open Interest']) ? Number(filteredRankingData['Open Interest']).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 }) : 'N/A', key: 'Open Interest' },
                        { name: 'OI 1d (%)', value: Number.isFinite(filteredRankingData['OI 1d (%)']) ? filteredRankingData['OI 1d (%)'].toFixed(2) : 'N/A', key: 'OI 1d (%)' },
                        { name: 'OI 1w (%)', value: Number.isFinite(filteredRankingData['OI 1w (%)']) ? filteredRankingData['OI 1w (%)'].toFixed(2) : 'N/A', key: 'OI 1w (%)' }
                    );
                }
        
                // ATM 12m/3m Ratio from skew data
                let atmRatio = 'N/A';
                const filteredSkewData = skewData.filter(item => item.Ticker === selectedTicker);
                console.log('Skew data filtered size:', filteredSkewData.length);
                const selectedSkewRow = filteredSkewData.find(item => normalizeDate(item.Expiry) === normalizedSelectedExpiry);
                if (selectedSkewRow) {
                    atmRatio = Number.isFinite(selectedSkewRow.ATM_12m_3m_Ratio) ? selectedSkewRow.ATM_12m_3m_Ratio.toFixed(4) : 'N/A';
                } else {
                    console.warn('No skew data for ticker:', selectedTicker, 'Expiry:', normalizedSelectedExpiry);
                }
                metrics.push({ name: 'ATM 12m/3m Ratio', value: atmRatio, key: 'ATM_12m_3m_Ratio' });
        
                // Slope data from slope_metrics
                const filteredSlopeData = slopeData.filter(item => item.Ticker === selectedTicker);
                console.log('Slope data filtered size:', filteredSlopeData.length);
                if (filteredSlopeData.length > 0) {
                    filteredSlopeData.forEach(item => {
                        metrics.push({
                            name: `IV Slope 3m/12m (${item.Type} Delta ${Number.isFinite(item.Delta) ? item.Delta.toFixed(2) : 'N/A'})`,
                            value: Number.isFinite(item.IV_Slope_3m_12m) ? item.IV_Slope_3m_12m.toFixed(4) : 'N/A',
                            key: `IV_Slope_3m_12m_${item.Type}_${item.Delta}`
                        });
                    });
                } else {
                    metrics.push({ name: 'IV Slope 3m/12m', value: 'No slope metrics available', key: 'IV_Slope_3m_12m' });
                }
        
                // Create rows for 4-column layout
                for (let i = 0; i < metrics.length; i += 2) {
                    const row = document.createElement('tr');
                    const metric1Cell = document.createElement('td');
                    metric1Cell.textContent = metrics[i].name;
                    row.appendChild(metric1Cell);
                    const value1Cell = document.createElement('td');
                    value1Cell.textContent = metrics[i].value;
                    if (changeMetrics.includes(metrics[i].name) && Number.isFinite(parseFloat(metrics[i].value))) {
                        const val = parseFloat(metrics[i].value);
                        value1Cell.style.color = val < 0 ? '#FF0000' : val > 0 ? '#00FF00' : '#FFFFFF';
                    }
                    row.appendChild(value1Cell);
                    const metric2Cell = document.createElement('td');
                    metric2Cell.textContent = i + 1 < metrics.length ? metrics[i + 1].name : '';
                    row.appendChild(metric2Cell);
                    const value2Cell = document.createElement('td');
                    value2Cell.textContent = i + 1 < metrics.length ? metrics[i + 1].value : '';
                    if (i + 1 < metrics.length && changeMetrics.includes(metrics[i + 1].name) && Number.isFinite(parseFloat(metrics[i + 1].value))) {
                        const val = parseFloat(metrics[i + 1].value);
                        value2Cell.style.color = val < 0 ? '#FF0000' : val > 0 ? '#00FF00' : '#FFFFFF';
                    }
                    row.appendChild(value2Cell);
                    tbody.appendChild(row);
                }
                table.appendChild(tbody);
            } catch (error) {
                console.error('Error updating summary table:', error);
                const tbody = document.createElement('tbody');
                const row = document.createElement('tr');
                const cell = document.createElement('td');
                cell.textContent = 'No data available';
                cell.colSpan = 4;
                row.appendChild(cell);
                tbody.appendChild(row);
                table.appendChild(tbody);
            }
        }
        function updateVolumeChart() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const uniqueTickers = [...new Set(data.map(item => item.Ticker))].filter(val => val).sort();
                const volumes = uniqueTickers.map(ticker => {
                    return rawData.filter(item => item.Ticker === ticker).reduce((sum, item) => sum + (item.Volume || 0), 0);
                });
                const backgroundColors = uniqueTickers.map(ticker => ticker === selectedTicker ? '#FFFF00' : '#00BFFF');
                if (volumeChart) volumeChart.destroy();
                volumeChart = new Chart(document.getElementById('volume-chart').getContext('2d'), {
                    type: 'bar',
                    data: {
                        labels: uniqueTickers,
                        datasets: [{
                            label: 'Total Volume',
                            data: volumes,
                            backgroundColor: backgroundColors,
                            borderColor: backgroundColors,
                            borderWidth: 1
                        }]
                    },
                    options: {
                        plugins: {
                            legend: {
                                display: true,
                                labels: {
                                    color: '#FFFFFF'
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Ticker',
                                    color: '#FFFFFF'
                                },
                                grid: {
                                    color: '#FFFFFF33'
                                },
                                ticks: {
                                    color: '#FFFFFF'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Volume',
                                    color: '#FFFFFF'
                                },
                                beginAtZero: true,
                                grid: {
                                    color: '#FFFFFF33'
                                },
                                ticks: {
                                    color: '#FFFFFF'
                                }
                            }
                        },
                        backgroundColor: '#1C2526'
                    }
                });
                console.log('Volume chart updated for tickers:', uniqueTickers);
            } catch (error) {
                console.error('Error updating volume chart:', error);
            }
        }
        function updateOpenInterestChart() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const uniqueTickers = [...new Set(data.map(item => item.Ticker))].filter(val => val).sort();
                const openInterests = uniqueTickers.map(ticker => {
                    return rawData.filter(item => item.Ticker === ticker).reduce((sum, item) => sum + (item['Open Interest'] || 0), 0);
                });
                const backgroundColors = uniqueTickers.map(ticker => ticker === selectedTicker ? '#FFFF00' : '#00BFFF');
                if (openInterestChart) openInterestChart.destroy();
                openInterestChart = new Chart(document.getElementById('open-interest-chart').getContext('2d'), {
                    type: 'bar',
                    data: {
                        labels: uniqueTickers,
                        datasets: [{
                            label: 'Total Open Interest',
                            data: openInterests,
                            backgroundColor: backgroundColors,
                            borderColor: backgroundColors,
                            borderWidth: 1
                        }]
                    },
                    options: {
                        plugins: {
                            legend: {
                                display: true,
                                labels: {
                                    color: '#FFFFFF'
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Ticker',
                                    color: '#FFFFFF'
                                },
                                grid: {
                                    color: '#FFFFFF33'
                                },
                                ticks: {
                                    color: '#FFFFFF'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Open Interest',
                                    color: '#FFFFFF'
                                },
                                beginAtZero: true,
                                grid: {
                                    color: '#FFFFFF33'
                                },
                                ticks: {
                                    color: '#FFFFFF'
                                }
                            }
                        },
                        backgroundColor: '#1C2526'
                    }
                });
                console.log('Open Interest chart updated for tickers:', uniqueTickers);
            } catch (error) {
                console.error('Error updating open interest chart:', error);
            }
        }
        function aggregateDataByX(data, xKey, yKey) {
            try {
                const grouped = data.reduce((acc, item) => {
                    const xValue = xKey === 'Expiry' ? new Date(item[xKey]).toISOString() : item[xKey];
                    const yValue = item[yKey];
                    if (!acc[xValue]) {
                        acc[xValue] = { sum: 0, count: 0 };
                    }
                    if (!isNaN(yValue) && yValue !== null) {
                        acc[xValue].sum += yValue;
                        acc[xValue].count += 1;
                    }
                    return acc;
                }, {});
                return Object.keys(grouped).map(x => {
                    const group = grouped[x];
                    if (group.count > 0) {
                        return {
                            x: xKey === 'Expiry' ? new Date(x) : parseFloat(x) * (xKey === 'Moneyness' || xKey === 'Delta' ? 100 : 1),
                            y: (group.sum / group.count) * 100
                        };
                    }
                }).filter(point => point !== undefined).sort((a, b) => a.x - b.x);
            } catch (error) {
                console.error('Error aggregating data:', error);
                return [];
            }
        }
        function createStatsTable(chart, canvasId) {
            try {
                const container = document.getElementById(canvasId).parentNode;
                let existingTable = container.querySelector('.stats-table');
                if (existingTable) existingTable.remove();
                const table = document.createElement('table');
                table.className = 'stats-table';
                table.style.display = canvasId === 'historic-price-chart' ? 'table' : (statsTablesVisible ? 'table' : 'none');
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                ['Label', 'Last', 'Min', 'Max', 'Mean', 'SD', 'SD Change'].forEach(text => {
                    const th = document.createElement('th');
                    th.textContent = text;
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);
                table.appendChild(thead);
                const tbody = document.createElement('tbody');
                chart.data.datasets.forEach(dataset => {
                    if (dataset.data.length === 0) return;
                    const ys = dataset.data.map(point => point.y).filter(y => !isNaN(y));
                    if (ys.length === 0) return;
                    const last = ys[ys.length - 1];
                    const min = Math.min(...ys);
                    const max = Math.max(...ys);
                    const sum = ys.reduce((a, b) => a + b, 0);
                    const mean = sum / ys.length;
                    const sd = Math.sqrt(ys.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / (ys.length - 1)) || 0;
                    const sdChanges = ys.slice(1).map((y, i) => y - ys[i]);
                    const sdChange = sdChanges.length > 0 ? Math.sqrt(sdChanges.reduce((a, b) => a + Math.pow(b, 2), 0) / (sdChanges.length - 1)) || 0 : 0;
                    const row = document.createElement('tr');
                    const labelTd = document.createElement('td');
                    const swatch = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    swatch.setAttribute('width', '20');
                    swatch.setAttribute('height', '10');
                    swatch.setAttribute('class', 'line-swatch');
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', '0');
                    line.setAttribute('y1', '5');
                    line.setAttribute('x2', '20');
                    line.setAttribute('y2', '5');
                    line.setAttribute('stroke', dataset.borderColor);
                    line.setAttribute('stroke-width', '2');
                    if (dataset.borderDash && dataset.borderDash.length > 0) {
                        line.setAttribute('stroke-dasharray', dataset.borderDash.join(' '));
                    }
                    swatch.appendChild(line);
                    labelTd.appendChild(swatch);
                    const labelText = document.createTextNode(` ${dataset.label}`);
                    labelTd.appendChild(labelText);
                    row.appendChild(labelTd);
                    const lastTd = document.createElement('td');
                    lastTd.textContent = last.toFixed(2);
                    row.appendChild(lastTd);
                    const minTd = document.createElement('td');
                    minTd.textContent = min.toFixed(2);
                    row.appendChild(minTd);
                    const maxTd = document.createElement('td');
                    maxTd.textContent = max.toFixed(2);
                    row.appendChild(maxTd);
                    const meanTd = document.createElement('td');
                    meanTd.textContent = mean.toFixed(2);
                    row.appendChild(meanTd);
                    const sdTd = document.createElement('td');
                    sdTd.textContent = sd.toFixed(2);
                    row.appendChild(sdTd);
                    const sdChangeTd = document.createElement('td');
                    sdChangeTd.textContent = sdChange.toFixed(2);
                    row.appendChild(sdChangeTd);
                    tbody.appendChild(row);
                });
                table.appendChild(tbody);
                container.appendChild(table);
            } catch (error) {
                console.error('Error creating stats table:', error);
            }
        }
        function updateMoneynessVsIV() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const selectedExpiry = document.getElementById('expiry-select').value;
                const filteredData = data.filter(item => item.Ticker === selectedTicker && item.Expiry === selectedExpiry);
                console.log('Updating Moneyness vs. IV chart for ticker:', selectedTicker, 'Expiry:', selectedExpiry);
                const datasets = [
                    {
                        label: 'Calls Implied Volatility Mid',
                        data: aggregateDataByX(
                            filteredData.filter(item => item.Type === 'Call'),
                            'Moneyness',
                            'IV_mid'
                        ),
                        borderColor: '#FF0000',
                        backgroundColor: '#FF0000',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Puts Implied Volatility Mid',
                        data: aggregateDataByX(
                            filteredData.filter(item => item.Type === 'Put'),
                            'Moneyness',
                            'IV_mid'
                        ),
                        borderColor: '#FF0000',
                        backgroundColor: '#FF0000',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [5, 5],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Calls Smoothed IV',
                        data: aggregateDataByX(
                            filteredData.filter(item => item.Type === 'Call'),
                            'Moneyness',
                            'Smoothed_IV'
                        ),
                        borderColor: '#800080',
                        backgroundColor: '#800080',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Puts Smoothed IV',
                        data: aggregateDataByX(
                            filteredData.filter(item => item.Type === 'Put'),
                            'Moneyness',
                            'Smoothed_IV'
                        ),
                        borderColor: '#800080',
                        backgroundColor: '#800080',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [5, 5],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Call Local Vol',
                        data: aggregateDataByX(
                            filteredData.filter(item => item.Type === 'Call' && item['Call Local Vol'] > 0),
                            'Moneyness',
                            'Call Local Vol'
                        ),
                        borderColor: '#00FF00',
                        backgroundColor: '#00FF00',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Put Local Vol',
                        data: aggregateDataByX(
                            filteredData.filter(item => item.Type === 'Put' && item['Put Local Vol'] > 0),
                            'Moneyness',
                            'Put Local Vol'
                        ),
                        borderColor: '#00FF00',
                        backgroundColor: '#00FF00',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [5, 5],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Realised Vol 100d',
                        data: aggregateDataByX(
                            filteredData,
                            'Moneyness',
                            'Realised Vol 100d'
                        ),
                        borderColor: '#FFFF00',
                        backgroundColor: '#FFFF00',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    }
                ];
                if (moneynessChart) moneynessChart.destroy();
                moneynessChart = new Chart(document.getElementById('moneyness-vs-iv-chart').getContext('2d'), {
                    type: 'line',
                    data: { datasets },
                    options: {
                        plugins: {
                            legend: {
                                display: true,
                                labels: {
                                    color: '#FFFFFF'
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                title: {
                                    display: true,
                                    text: 'Moneyness (%)',
                                    color: '#FFFFFF'
                                },
                                min: 0,
                                max: 200,
                                grid: {
                                    color: '#FFFFFF33'
                                },
                                ticks: {
                                    color: '#FFFFFF'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Volatility (%)',
                                    color: '#FFFFFF'
                                },
                                beginAtZero: true,
                                grid: {
                                    color: '#FFFFFF33'
                                },
                                ticks: {
                                    color: '#FFFFFF'
                                }
                            }
                        },
                        backgroundColor: '#1C2526'
                    }
                });
                createStatsTable(moneynessChart, 'moneyness-vs-iv-chart');
            } catch (error) {
                console.error('Error updating Moneyness vs. IV chart:', error);
            }
        }
        function updateExpiryVsIV() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const selectedMoneyness = parseFloat(document.getElementById('moneyness-select').value);
                const filteredData = data.filter(item => item.Ticker === selectedTicker && Math.round(item.Moneyness * 100 / 10) * 0.1 === selectedMoneyness);
                console.log('Updating Expiry vs. IV chart for ticker:', selectedTicker, 'Moneyness:', selectedMoneyness);
                const datasets = [
                    {
                        label: 'Calls Implied Volatility Mid',
                        data: aggregateDataByX(
                            filteredData.filter(item => item.Type === 'Call'),
                            'Expiry',
                            'IV_mid'
                        ),
                        borderColor: '#FF0000',
                        backgroundColor: '#FF0000',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Puts Implied Volatility Mid',
                        data: aggregateDataByX(
                            filteredData.filter(item => item.Type === 'Put'),
                            'Expiry',
                            'IV_mid'
                        ),
                        borderColor: '#FF0000',
                        backgroundColor: '#FF0000',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [5, 5],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Calls Smoothed IV',
                        data: aggregateDataByX(
                            filteredData.filter(item => item.Type === 'Call'),
                            'Expiry',
                            'Smoothed_IV'
                        ),
                        borderColor: '#800080',
                        backgroundColor: '#800080',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [5, 5],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Puts Smoothed IV',
                        data: aggregateDataByX(
                            filteredData.filter(item => item.Type === 'Put'),
                            'Expiry',
                            'Smoothed_IV'
                        ),
                        borderColor: '#800080',
                        backgroundColor: '#800080',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [10, 5],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Call Local Vol',
                        data: aggregateDataByX(
                            filteredData.filter(item => item.Type === 'Call' && item['Call Local Vol'] > 0),
                            'Expiry',
                            'Call Local Vol'
                        ),
                        borderColor: '#00FF00',
                        backgroundColor: '#00FF00',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Put Local Vol',
                        data: aggregateDataByX(
                            filteredData.filter(item => item.Type === 'Put' && item['Put Local Vol'] > 0),
                            'Expiry',
                            'Put Local Vol'
                        ),
                        borderColor: '#00FF00',
                        backgroundColor: '#00FF00',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [5, 5],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Realised Vol 100d',
                        data: aggregateDataByX(
                            filteredData,
                            'Expiry',
                            'Realised Vol 100d'
                        ),
                        borderColor: '#FFFF00',
                        backgroundColor: '#FFFF00',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    }
                ];
                if (expiryChart) expiryChart.destroy();
                expiryChart = new Chart(document.getElementById('expiry-vs-iv-chart').getContext('2d'), {
                    type: 'line',
                    data: { datasets },
                    options: {
                        plugins: {
                            legend: {
                                display: true,
                                labels: {
                                    color: '#FFFFFF'
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: { unit: 'day' },
                                title: {
                                    display: true,
                                    text: 'Expiry Date',
                                    color: '#FFFFFF'
                                },
                                grid: {
                                    color: '#FFFFFF33'
                                },
                                ticks: {
                                    color: '#FFFFFF'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Volatility (%)',
                                    color: '#FFFFFF'
                                },
                                beginAtZero: true,
                                grid: {
                                    color: '#FFFFFF33'
                                },
                                ticks: {
                                    color: '#FFFFFF'
                                }
                            }
                        },
                        backgroundColor: '#1C2526'
                    }
                });
                createStatsTable(expiryChart, 'expiry-vs-iv-chart');
            } catch (error) {
                console.error('Error updating Expiry vs. IV chart:', error);
            }
        }
        function updateDeltaVsIV() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const selectedExpiry = document.getElementById('delta-expiry-select').value;
                const filteredData = data.filter(item => item.Ticker === selectedTicker && item.Expiry === selectedExpiry);
                console.log('Updating Delta vs. IV chart for ticker:', selectedTicker, 'Expiry:', selectedExpiry);
                const datasets = [
                    {
                        label: 'Calls Implied Volatility Mid',
                        data: aggregateDataByX(
                            filteredData.filter(item => item.Type === 'Call'),
                            'Delta',
                            'IV_mid'
                        ),
                        borderColor: '#FF0000',
                        backgroundColor: '#FF0000',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Puts Implied Volatility Mid',
                        data: aggregateDataByX(
                            filteredData.filter(item => item.Type === 'Put'),
                            'Delta',
                            'IV_mid'
                        ),
                        borderColor: '#FF0000',
                        backgroundColor: '#FF0000',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [5, 5],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Calls Smoothed IV',
                        data: aggregateDataByX(
                            filteredData.filter(item => item.Type === 'Call'),
                            'Delta',
                            'Smoothed_IV'
                        ),
                        borderColor: '#800080',
                        backgroundColor: '#800080',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [5, 5],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Puts Smoothed IV',
                        data: aggregateDataByX(
                            filteredData.filter(item => item.Type === 'Put'),
                            'Delta',
                            'Smoothed_IV'
                        ),
                        borderColor: '#800080',
                        backgroundColor: '#800080',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [10, 5],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Call Local Vol',
                        data: aggregateDataByX(
                            filteredData.filter(item => item.Type === 'Call' && item['Call Local Vol'] > 0),
                            'Delta',
                            'Call Local Vol'
                        ),
                        borderColor: '#00FF00',
                        backgroundColor: '#00FF00',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Put Local Vol',
                        data: aggregateDataByX(
                            filteredData.filter(item => item.Type === 'Put' && item['Put Local Vol'] > 0),
                            'Delta',
                            'Put Local Vol'
                        ),
                        borderColor: '#00FF00',
                        backgroundColor: '#00FF00',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [5, 5],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Realised Vol 100d',
                        data: aggregateDataByX(
                            filteredData,
                            'Delta',
                            'Realised Vol 100d'
                        ),
                        borderColor: '#FFFF00',
                        backgroundColor: '#FFFF00',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    }
                ];
                if (deltaChart) deltaChart.destroy();
                deltaChart = new Chart(document.getElementById('delta-vs-iv-chart').getContext('2d'), {
                    type: 'line',
                    data: { datasets },
                    options: {
                        plugins: {
                            legend: {
                                display: true,
                                labels: {
                                    color: '#FFFFFF'
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                title: {
                                    display: true,
                                    text: 'Delta (%)',
                                    color: '#FFFFFF'
                                },
                                min: -100,
                                max: 100,
                                grid: {
                                    color: '#FFFFFF33'
                                },
                                ticks: {
                                    color: '#FFFFFF',
                                    callback: function(value) {
                                        return Math.abs(value).toFixed(0);
                                    }
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Volatility (%)',
                                    color: '#FFFFFF'
                                },
                                beginAtZero: true,
                                grid: {
                                    color: '#FFFFFF33'
                                },
                                ticks: {
                                    color: '#FFFFFF'
                                }
                            }
                        },
                        backgroundColor: '#1C2526'
                    }
                });
                createStatsTable(deltaChart, 'delta-vs-iv-chart');
            } catch (error) {
                console.error('Error updating Delta vs. IV chart:', error);
            }
        }
        function updateHistoricChart() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const historyLength = document.getElementById('history-select').value;
                console.log('Updating Historic chart for ticker:', selectedTicker, 'History length:', historyLength);
                if (historicData.length === 0) {
                    if (historicChart) historicChart.destroy();
                    document.getElementById('historic-error').style.display = 'block';
                    return;
                }
                let filteredHistoric = historicData.filter(item => item.Ticker === selectedTicker);
                filteredHistoric.sort((a, b) => new Date(a.Date) - new Date(b.Date));
                const fromDate = calculateDateRange(historyLength);
                const minHistoricDate = new Date(Math.min(...filteredHistoric.map(item => new Date(item.Date))));
                const maxHistoricDate = new Date(Math.max(...filteredHistoric.map(item => new Date(item.Date))));
                if (fromDate) {
                    filteredHistoric = filteredHistoric.filter(item => new Date(item.Date) >= fromDate);
                }
                const dates = filteredHistoric.map(item => new Date(item.Date));
                const prices = filteredHistoric.map(item => parseFloat(item.Close));
                const vol30 = filteredHistoric.map(item => parseFloat(item.Realised_Vol_30));
                const vol60 = filteredHistoric.map(item => parseFloat(item.Realised_Vol_60));
                const vol90 = filteredHistoric.map(item => parseFloat(item.Realised_Vol_100));
                const vol180 = filteredHistoric.map(item => parseFloat(item.Realised_Vol_180));
                const vol360 = filteredHistoric.map(item => parseFloat(item.Realised_Vol_252));
                const datasets = [
                    {
                        label: 'Stock Price',
                        data: prices.map((p, i) => ({ x: dates[i], y: p })),
                        borderColor: '#FFFF00',
                        backgroundColor: '#FFFF00',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        yAxisID: 'y'
                    },
                    {
                        label: '30-day Realised Vol (%)',
                        data: vol30.map((v, i) => ({ x: dates[i], y: v })),
                        borderColor: '#00BFFF',
                        backgroundColor: '#00BFFF',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y1'
                    },
                    {
                        label: '60-day Realised Vol (%)',
                        data: vol60.map((v, i) => ({ x: dates[i], y: v })),
                        borderColor: '#8A2BE2',
                        backgroundColor: '#8A2BE2',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y1'
                    },
                    {
                        label: '100-day Realised Vol (%)',
                        data: vol90.map((v, i) => ({ x: dates[i], y: v })),
                        borderColor: '#FF0000',
                        backgroundColor: '#FF0000',
                        pointRadius: 5,
                        pointStyle: 'crossRot',
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y1'
                    },
                    {
                        label: '180-day Realised Vol (%)',
                        data: vol180.map((v, i) => ({ x: dates[i], y: v })),
                        borderColor: '#FFA500',
                        backgroundColor: '#FFA500',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y1'
                    },
                    {
                        label: '252-day Realised Vol (%)',
                        data: vol360.map((v, i) => ({ x: dates[i], y: v })),
                        borderColor: '#00FF00',
                        backgroundColor: '#00FF00',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y1'
                    }
                ];
                const annotations = eventsData
                    .filter(event => {
                        const startDate = new Date(event.Start_Date);
                        const endDate = new Date(event.End_Date);
                        if (!(event.Ticker === 'ALL' || event.Ticker === selectedTicker)) return false;
                        if (startDate > maxHistoricDate || endDate < minHistoricDate) return false;
                        if (fromDate && (endDate < fromDate)) return false;
                        return true;
                    })
                    .map((event, index) => ({
                        type: 'box',
                        xMin: new Date(Math.max(new Date(event.Start_Date), fromDate || minHistoricDate)),
                        xMax: new Date(Math.min(new Date(event.End_Date), maxHistoricDate)),
                        yMin: 'y',
                        yMax: 'y',
                        backgroundColor: event.Impact === 'dip' ? 'rgba(255, 99, 132, 0.2)' : 'rgba(75, 192, 192, 0.2)',
                        borderColor: event.Impact === 'dip' ? 'rgba(255, 99, 132, 0.5)' : 'rgba(75, 192, 192, 0.5)',
                        borderWidth: 1,
                        label: {
                            content: event.Event,
                            display: true,
                            position: 'center',
                            color: '#FFFFFF',
                            font: {
                                size: 12
                            },
                            rotation: 90
                        }
                    }));
                if (historicChart) historicChart.destroy();
                historicChart = new Chart(document.getElementById('historic-price-chart').getContext('2d'), {
                    type: 'line',
                    data: { datasets },
                    options: {
                        plugins: {
                            legend: {
                                display: true,
                                labels: {
                                    color: '#FFFFFF'
                                }
                            },
                            annotation: {
                                annotations: annotations
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: { unit: 'month' },
                                title: {
                                    display: true,
                                    text: 'Date',
                                    color: '#FFFFFF'
                                },
                                grid: {
                                    color: '#FFFFFF33'
                                },
                                ticks: {
                                    color: '#FFFFFF'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Stock Price ($)',
                                    color: '#FFFFFF'
                                },
                                beginAtZero: false,
                                grid: {
                                    color: '#FFFFFF33'
                                },
                                ticks: {
                                    color: '#FFFFFF'
                                }
                            },
                            y1: {
                                type: 'linear',
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Realised Volatility (%)',
                                    color: '#FFFFFF'
                                },
                                beginAtZero: false,
                                grid: {
                                    color: '#FFFFFF33'
                                },
                                ticks: {
                                    color: '#FFFFFF'
                                }
                            }
                        },
                        backgroundColor: '#1C2526'
                    }
                });
                document.getElementById('historic-error').style.display = 'none';
                createStatsTable(historicChart, 'historic-price-chart');
            } catch (error) {
                console.error('Error updating Historic chart:', error);
            }
        }
        function updateCharts() {
            try {
                console.log('Updating all charts and tables');
                updateMoneynessVsIV();
                updateExpiryVsIV();
                updateDeltaVsIV();
                updateSkewTable();
                updateSummaryTable();
                updateVolumeChart();
                updateOpenInterestChart();
                updateHistoricChart();
            } catch (error) {
                console.error('Error updating charts:', error);
            }
        }
        function addKeyboardNavigation() {
            try {
                const chartConfigs = [
                    {
                        canvasId: 'moneyness-vs-iv-chart',
                        selectId: 'expiry-select'
                    },
                    {
                        canvasId: 'expiry-vs-iv-chart',
                        selectId: 'moneyness-select'
                    },
                    {
                        canvasId: 'delta-vs-iv-chart',
                        selectId: 'delta-expiry-select'
                    },
                    {
                        canvasId: 'volume-chart',
                        selectId: 'ticker-search'
                    },
                    {
                        canvasId: 'open-interest-chart',
                        selectId: 'ticker-search'
                    },
                    {
                        canvasId: 'historic-price-chart',
                        selectId: 'history-select'
                    }
                ];
                chartConfigs.forEach(config => {
                    const canvas = document.getElementById(config.canvasId);
                    const select = document.getElementById(config.selectId);
                    canvas.addEventListener('keydown', (event) => {
                        if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
                            event.preventDefault();
                            let newIndex = select.selectedIndex + (event.key === 'ArrowLeft' ? -1 : 1);
                            if (newIndex < 0) newIndex = select.options.length - 1;
                            if (newIndex >= select.options.length) newIndex = 0;
                            select.selectedIndex = newIndex;
                            const changeEvent = new Event('change', { bubbles: true });
                            select.dispatchEvent(changeEvent);
                        }
                    });
                });
                const expirySelect = document.getElementById('expiry-select');
                const deltaExpirySelect = document.getElementById('delta-expiry-select');
                expirySelect.addEventListener('change', () => {
                    console.log('Expiry select changed to:', expirySelect.value);
                    deltaExpirySelect.value = expirySelect.value;
                    updateCharts();
                });
                deltaExpirySelect.addEventListener('change', () => {
                    console.log('Delta expiry select changed to:', deltaExpirySelect.value);
                    expirySelect.value = deltaExpirySelect.value;
                    updateCharts();
                });
                document.getElementById('moneyness-select').addEventListener('change', () => {
                    console.log('Moneyness select changed to:', document.getElementById('moneyness-select').value);
                    updateCharts();
                });
            } catch (error) {
                console.error('Error adding keyboard navigation:', error);
            }
        }
        document.addEventListener('DOMContentLoaded', addKeyboardNavigation);
    </script>
</body>
</html>
