<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Stock Overview</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.2.1/dist/chartjs-plugin-annotation.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #1A1A2E;
            color: #FFFFFF;
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            font-size: 14px;
        }
        .sidebar {
            width: 250px;
            background: #25253D;
            padding: 20px;
            border-right: 1px solid #A855F7;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.5);
        }
        .sidebar a {
            color: #A855F7;
            text-decoration: none;
            display: block;
            padding: 12px 15px;
            font-size: 16px;
            transition: color 0.3s ease, background-color 0.3s ease;
            border-radius: 4px;
        }
        .sidebar a:hover {
            color: #FFFFFF;
            background-color: #D8B4FE;
            text-decoration: none;
        }
        .sidebar select, .sidebar input {
            width: 100%;
            padding: 8px;
            background-color: #25253D;
            color: #FFFFFF;
            border: 1px solid #A855F7;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }
        .sidebar select:focus, .sidebar input:focus {
            border-color: #D8B4FE;
            outline: none;
        }
        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #1A1A2E;
        }
        .chart-container {
            background-color: #25253D;
            padding: 20px;
            border: 1px solid #A855F7;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        .stats-table, .skew-table, .summary-table, .ranking-table, .raw-data-table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 15px;
            background-color: #25253D;
        }
        .stats-table th, .stats-table td, .skew-table th, .skew-table td, .summary-table th, .summary-table td, .ranking-table th, .ranking-table td, .raw-data-table th, .raw-data-table td {
            border: 1px solid #A855F7;
            padding: 10px;
            text-align: left;
            color: #FFFFFF;
        }
        .stats-table th, .skew-table th, .summary-table th, .ranking-table th, .raw-data-table th {
            background-color: #373758;
            font-weight: bold;
            cursor: pointer;
        }
        .stats-table th:hover, .raw-data-table th:hover, .ranking-table th:hover {
            background-color: #4B4B6F;
        }
        canvas {
            max-width: 100%;
            border-radius: 4px;
            background-color: #25253D;
        }
        .header {
            text-align: center;
            padding: 15px;
            background-color: #25253D;
            border-bottom: 1px solid #A855F7;
            font-size: 22px;
            font-weight: bold;
            color: #FFFFFF;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        .ticker-display {
            font-size: 24px;
            margin-bottom: 15px;
            color: #FFFFFF;
            text-align: center;
            background-color: #25253D;
            padding: 10px;
            border-radius: 4px;
        }
        .select-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .arrow-button, .toggle-button {
            background-color: #25253D;
            color: #FFFFFF;
            border: 1px solid #A855F7;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .arrow-button:hover, .toggle-button:hover {
            background-color: #D8B4FE;
        }
        #historic-error {
            color: #F87171;
            padding: 10px;
            text-align: center;
        }
        .line-swatch {
            display: inline-block;
            vertical-align: middle;
            margin-right: 5px;
        }
        .overview-container {
            display: flex;
            gap: 20px;
        }
        .overview-container .chart-container {
            flex: 1;
        }
        .volatility-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
        }
        .volatility-grid .chart-container {
            margin-bottom: 0;
        }
        #call-vol-surface {
            height: 400px;
            background-color: #25253D;
        }
        .slider-container {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .slider-container input {
            width: 150px;
        }
        .error-message {
            color: #F87171;
            text-align: center;
            padding: 10px;
        }
        .ranking-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
        }
        .ranking-grid .chart-container {
            margin-bottom: 0;
        }
        #call-vol-surface {
            height: 100% !important;
            width: 100% !important;
            min-height: 400px; /* Minimum height to ensure visibility */
        }
        
        .slider-container {
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            justify-content: center;
        }
        
        .slider-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .pretty-slider {
            width: 200px;
            padding: 5px 0;
            background: linear-gradient(to right, #A855F7, #D8B4FE);
            -webkit-appearance: none;
            height: 8px;
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        
        .pretty-slider:hover {
            opacity: 1;
        }
        
        .pretty-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            background: #FFFFFF;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #A855F7;
            box-shadow: 0 0 5px rgba(168, 85, 247, 0.5);
        }
        
        .pretty-slider::-moz-range-thumb {
            width: 15px;
            height: 15px;
            background: #FFFFFF;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #A855F7;
            box-shadow: 0 0 5px rgba(168, 85, 247, 0.5);
        }
        .slider-value {
            margin-left: 10px;
            color: #D8B4FE;
            font-weight: bold;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="header">Stock Overview</div>
        <div class="select-container">
            <label for="source-select">Source: </label>
            <select id="source-select">
                <option value="nasdaq">Nasdaq</option>
                <option value="yfinance" selected>yfinance</option>
            </select>
        </div>
        <select id="date-select"></select>
        <select id="time-select"></select>
        <input type="text" id="ticker-search" list="ticker-datalist" placeholder="Search Ticker...">
        <datalist id="ticker-datalist"></datalist>
        <button class="toggle-button" onclick="toggleStatsTables()">Show Stats Tables</button>
        <a href="#overview">Overview</a>
        <a href="#volatility">Volatility</a>
        <a href="#ranking">Ranking</a>
        <a href="#data-table">Data Table</a>
    </div>
    <div class="main-content">
        <div class="ticker-display" id="ticker-display">Selected Ticker: N/A</div>
        <div id="overview" class="overview-container">
            <div class="chart-container">
                <h2>Historic Stock Price with Realised Volatility</h2>
                <div class="select-container">
                    <label for="history-select">Select History Length: </label>
                    <button class="arrow-button" onclick="changeSelect('history-select', -1)">&#9664;</button>
                    <select id="history-select">
                        <option value="1m">1-month</option>
                        <option value="3m">3-month</option>
                        <option value="6m">6-month</option>
                        <option value="1y">1-year</option>
                        <option value="5y">5-year</option>
                        <option value="all" selected>All</option>
                    </select>
                    <button class="arrow-button" onclick="changeSelect('history-select', 1)">&#9654;</button>
                </div>
                <canvas id="historic-price-chart"></canvas>
                <div id="historic-error" class="error-message" style="display: none;">No historic data available</div>
            </div>
            <div class="chart-container">
                <h2>Summary</h2>
                <table id="summary-table" class="summary-table"></table>
                <table id="skew-table" class="skew-table"></table>
            </div>
        </div>
        <div id="volatility" class="volatility-grid" style="display: none;">
            <div class="chart-container">
                <h3>Implied Volatility Smile</h3>
                <div class="select-container">
                    <label for="expiry-select">Select Expiry: </label>
                    <button class="arrow-button" onclick="changeSelect('expiry-select', -1)">&#9664;</button>
                    <select id="expiry-select"></select>
                    <button class="arrow-button" onclick="changeSelect('expiry-select', 1)">&#9654;</button>
                </div>
                <canvas id="moneyness-vs-iv-chart"></canvas>
                <div id="moneyness-error" class="error-message" style="display: none;">No data available</div>
            </div>
            <div class="chart-container">
                <h3>Implied Volatility Term Structure</h3>
                <div class="select-container">
                    <label for="moneyness-select">Select Moneyness: </label>
                    <button class="arrow-button" onclick="changeSelect('moneyness-select', -1)">&#9664;</button>
                    <select id="moneyness-select"></select>
                    <button class="arrow-button" onclick="changeSelect('moneyness-select', 1)">&#9654;</button>
                </div>
                <canvas id="expiry-vs-iv-chart"></canvas>
                <div id="expiry-error" class="error-message" style="display: none;">No data available</div>
            </div>
            <div class="chart-container">
                <h3>Volatility Skewness</h3>
                <canvas id="skew-vs-expiry-chart"></canvas>
                <div id="skew-error" class="error-message" style="display: none;">No data available</div>
            </div>
            <div class="chart-container">
                <h3>Realised Volatility</h3>
                <canvas id="realised-vol-chart"></canvas>
                <div id="realised-vol-error" class="error-message" style="display: none;">No data available</div>
            </div>
            <div class="chart-container">
                <h3>Call Volatility Surface</h3>
                <div class="slider-container">
                    <div class="slider-group">
                        <label>Moneyness Range: <input type="range" id="moneyness-slider" min="0.1" max="3" step="0.1" value="0.6" class="pretty-slider" multiple data-min="0.6" data-max="2.5">
                            <span id="moneyness-value" class="slider-value">0.6 - 2.5</span></label>
                        <label>Expiry (T) Range: <input type="range" id="expiry-t-slider" min="0" max="5" step="0.1" value="0.2" class="pretty-slider" multiple data-min="0.2" data-max="5">
                            <span id="expiry-t-value" class="slider-value">0.2 - 5.0</span></label>
                    </div>
                </div>
                <div id="call-vol-surface" style="height: 100%; width: 100%;"></div>
                <div id="surface-error" class="error-message" style="display: none;">No data available</div>
            </div>
        </div>
        <div id="ranking" class="chart-container" style="display: none;">
            <h2>Ticker Ranking</h2>
            <button class="toggle-button" onclick="toggleRankingTable()">Show Data</button>
            <table id="ranking-table" class="ranking-table" style="display: none;"></table>
            <div class="ranking-grid">
                <div class="chart-container">
                    <h3>Volume</h3>
                    <canvas id="volume-chart"></canvas>
                </div>
                <div class="chart-container">
                    <h3>Open Interest</h3>
                    <canvas id="open-interest-chart"></canvas>
                </div>
            </div>
        </div>
        <div id="data-table" class="chart-container" style="display: none;">
            <h2>Data Table</h2>
            <table id="raw-data-table" class="raw-data-table"></table>
        </div>
    </div>
    <script>
        let data = [];
        let historicData = [];
        let skewData = [];
        let slopeData = [];
        let eventsData = [];
        let rawData = [];
        let rankingData = [];
        let moneynessChart, expiryChart, deltaChart, historicChart, volumeChart, openInterestChart, skewChart, realisedVolChart;
        let statsTablesVisible = false;
        let rankingTableVisible = false;
        let lastLoadDataTimestamp = null;
        let loadDataTimeout = null;

        function parseCSV(csvText) {
            try {
                const result = Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    dynamicTyping: true
                });
                return result.data;
            } catch (error) {
                console.error('Error parsing CSV:', error);
                return [];
            }
        }

        function normalizeDate(dateStr) {
            try {
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) throw new Error('Invalid date');
                return date.toLocaleDateString('en-CA');
            } catch (error) {
                console.error('Error normalizing date:', dateStr, error);
                return null;
            }
        }

        function calculateDateRange(historyLength) {
            try {
                const now = new Date();
                let fromDate = new Date();
                switch (historyLength) {
                    case '1m': fromDate.setMonth(now.getMonth() - 1); break;
                    case '3m': fromDate.setMonth(now.getMonth() - 3); break;
                    case '6m': fromDate.setMonth(now.getMonth() - 6); break;
                    case '1y': fromDate.setFullYear(now.getFullYear() - 1); break;
                    case '5y': fromDate.setFullYear(now.getFullYear() - 5); break;
                    case 'all': default: return null;
                }
                return fromDate;
            } catch (error) {
                console.error('Error calculating date range:', error);
                return null;
            }
        }

        function changeSelect(selectId, direction) {
            try {
                const select = document.getElementById(selectId);
                let newIndex = select.selectedIndex + direction;
                if (newIndex < 0) newIndex = select.options.length - 1;
                if (newIndex >= select.options.length) newIndex = 0;
                select.selectedIndex = newIndex;
                select.dispatchEvent(new Event('change', { bubbles: true }));
                console.log(`Changed ${selectId} to:`, select.value);
            } catch (error) {
                console.error('Error in changeSelect:', error);
            }
        }

        function toggleStatsTables() {
            try {
                statsTablesVisible = !statsTablesVisible;
                document.querySelectorAll('.stats-table:not(#historic-price-chart + .stats-table)').forEach(table => {
                    table.style.display = statsTablesVisible ? 'table' : 'none';
                });
                document.querySelector('.toggle-button:not(#ranking .toggle-button)').textContent = statsTablesVisible ? 'Hide Stats Tables' : 'Show Stats Tables';
                console.log(`Stats tables visibility set to: ${statsTablesVisible}`);
            } catch (error) {
                console.error('Error in toggleStatsTables:', error);
            }
        }

        function toggleRankingTable() {
            try {
                rankingTableVisible = !rankingTableVisible;
                const table = document.getElementById('ranking-table');
                table.style.display = rankingTableVisible ? 'table' : 'none';
                document.querySelector('#ranking .toggle-button').textContent = rankingTableVisible ? 'Hide Data' : 'Show Data';
                if (rankingTableVisible) updateRankingTable();
                console.log(`Ranking table visibility set to: ${rankingTableVisible}`);
            } catch (error) {
                console.error('Error in toggleRankingTable:', error);
            }
        }

        function debounce(func, wait) {
            let timeout;
            return function (...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        async function loadData(timestamp) {
            try {
                if (lastLoadDataTimestamp === timestamp) {
                    console.log(`Skipping redundant loadData for timestamp: ${timestamp}`);
                    return Promise.resolve();
                }
                lastLoadDataTimestamp = timestamp;
                clearTimeout(loadDataTimeout);
                document.getElementById('historic-error').textContent = 'Loading data...';
                document.getElementById('historic-error').style.display = 'block';
                const source = document.getElementById('source-select').value;
                const prefix = source === 'yfinance' ? '_yfinance' : '';
                let selectedTicker = document.getElementById('ticker-search').value.toUpperCase() || 'MSTR';
                console.log(`Loading data for timestamp: ${timestamp}, source: ${source}, ticker: ${selectedTicker}`);
                data = [];
                rawData = [];
                skewData = [];
                slopeData = [];
                historicData = [];
                eventsData = [];
                const checkFileExists = async (url) => {
                    try {
                        const response = await fetch(url, { method: 'HEAD' });
                        return response.ok;
                    } catch {
                        return false;
                    }
                };
                const rankingExists = await checkFileExists(`data/${timestamp}/ranking/ranking${prefix}.csv`);
                if (!rankingExists) {
                    throw new Error(`Ranking file not found: data/${timestamp}/ranking/ranking${prefix}.csv`);
                }
                const rankingResponse = await fetch(`data/${timestamp}/ranking/ranking${prefix}.csv?v=${Date.now()}`);
                rankingData = parseCSV(await rankingResponse.text());
                console.log('Ranking data loaded, size:', rankingData.length, 'sample:', rankingData.slice(0, 5));
                const tickerDatalist = document.getElementById('ticker-datalist');
                tickerDatalist.innerHTML = '';
                const uniqueTickers = [...new Set(rankingData.map(item => item.Ticker))].filter(val => val).sort();
                uniqueTickers.forEach(val => {
                    const option = document.createElement('option');
                    option.value = val;
                    tickerDatalist.appendChild(option);
                });
                if (!uniqueTickers.includes(selectedTicker)) {
                    selectedTicker = uniqueTickers.includes('MSTR') ? 'MSTR' : uniqueTickers[0] || '';
                    document.getElementById('ticker-search').value = selectedTicker;
                }
                document.getElementById('ticker-display').textContent = `Selected Ticker: ${selectedTicker || 'N/A'}`;
                console.log('Ticker search populated, selected:', selectedTicker);
                if (!selectedTicker) {
                    console.warn('No ticker selected, clearing data');
                    document.getElementById('historic-error').textContent = 'No ticker selected';
                    return Promise.resolve();
                }
                const [processedExists, rawExists, skewExists, slopeExists, historicExists, eventsExists] = await Promise.all([
                    checkFileExists(`data/${timestamp}/processed${prefix}/processed${prefix}_${selectedTicker}.csv`),
                    checkFileExists(`data/${timestamp}/raw${prefix}/raw${prefix}_${selectedTicker}.csv`),
                    checkFileExists(`data/${timestamp}/skew_metrics${prefix}/skew_metrics${prefix}_${selectedTicker}.csv`),
                    checkFileExists(`data/${timestamp}/slope_metrics${prefix}/slope_metrics${prefix}_${selectedTicker}.csv`),
                    checkFileExists(`data/${timestamp}/historic/historic_${selectedTicker}.csv`),
                    checkFileExists(`data/Events.csv`)
                ]);
                console.log('File existence check:', { processedExists, rawExists, skewExists, slopeExists, historicExists, eventsExists });
                const fetchWithErrorHandling = async (url, array) => {
                    try {
                        const response = await fetch(`${url}?v=${Date.now()}`);
                        if (!response.ok) throw new Error(`Failed to fetch ${url}: ${response.statusText}`);
                        array.splice(0, array.length, ...parseCSV(await response.text()));
                        console.log(`Data loaded from ${url}, size:`, array.length, 'sample:', array.slice(0, 5));
                    } catch (error) {
                        console.warn(`Error loading ${url}:`, error);
                        array.splice(0, array.length);
                        document.getElementById('historic-error').textContent = `Failed to load ${url}: ${error.message}`;
                    }
                };
                await Promise.all([
                    fetchWithErrorHandling(`data/${timestamp}/processed${prefix}/processed${prefix}_${selectedTicker}.csv`, data),
                    fetchWithErrorHandling(`data/${timestamp}/raw${prefix}/raw${prefix}_${selectedTicker}.csv`, rawData),
                    fetchWithErrorHandling(`data/${timestamp}/skew_metrics${prefix}/skew_metrics${prefix}_${selectedTicker}.csv`, skewData),
                    fetchWithErrorHandling(`data/${timestamp}/slope_metrics${prefix}/slope_metrics${prefix}_${selectedTicker}.csv`, slopeData),
                    fetchWithErrorHandling(`data/${timestamp}/historic/historic_${selectedTicker}.csv`, historicData).then(() => {
                        document.getElementById('historic-error').style.display = historicData.length ? 'none' : 'block';
                        if (!historicData.length) document.getElementById('historic-error').textContent = 'No historic data available';
                    }),
                    fetchWithErrorHandling(`data/Events.csv`, eventsData)
                ]);
                console.log('Data load complete:', {
                    data: data.slice(0, 5),
                    historicData: historicData.slice(0, 5),
                    skewData: skewData.slice(0, 5),
                    slopeData: slopeData.slice(0, 5),
                    rawData: rawData.slice(0, 5),
                    eventsData: eventsData.slice(0, 5),
                    rankingData: rankingData.slice(0, 5)
                });
                document.getElementById('historic-error').style.display = 'none';
                return Promise.resolve();
            } catch (error) {
                console.error('Error in loadData:', error);
                document.getElementById('ticker-search').value = '';
                document.getElementById('ticker-datalist').innerHTML = '';
                document.getElementById('ticker-display').textContent = 'Selected Ticker: N/A';
                data = [];
                rawData = [];
                skewData = [];
                slopeData = [];
                historicData = [];
                eventsData = [];
                rankingData = [];
                document.getElementById('historic-error').textContent = `Error loading data: ${error.message}`;
                return Promise.resolve();
            }
        }

        function populateTickerSearch() {
            try {
                const tickerSearch = document.getElementById('ticker-search');
                const tickerDatalist = document.getElementById('ticker-datalist');
                tickerDatalist.innerHTML = '';
                const uniqueTickers = [...new Set(rankingData.map(item => item.Ticker))].filter(val => val).sort();
                uniqueTickers.forEach(val => {
                    const option = document.createElement('option');
                    option.value = val;
                    tickerDatalist.appendChild(option);
                });
                if (uniqueTickers.length > 0 && !tickerSearch.value) {
                    tickerSearch.value = uniqueTickers.includes('MSTR') ? 'MSTR' : uniqueTickers[0];
                    document.getElementById('ticker-display').textContent = `Selected Ticker: ${tickerSearch.value.toUpperCase()}`;
                }
                console.log('Ticker search populated, selected:', tickerSearch.value);
            } catch (error) {
                console.error('Error populating ticker search:', error);
            }
        }

        function updateDropdowns() {
            try {
                const tickerSearch = document.getElementById('ticker-search');
                const selectedTicker = tickerSearch.value.toUpperCase() || 'MSTR';
                const tickerData = data.filter(item => item.Ticker && item.Ticker.toUpperCase() === selectedTicker);
                console.log('Updating dropdowns for ticker:', selectedTicker, 'Data size:', tickerData.length);
                const moneynessSelect = document.getElementById('moneyness-select');
                const expirySelect = document.getElementById('expiry-select');
                const deltaExpirySelect = document.getElementById('delta-expiry-select');
                if (!tickerData.length) {
                    console.warn('No data for dropdowns, ticker:', selectedTicker);
                    expirySelect.innerHTML = '<option value="">No expiries available</option>';
                    moneynessSelect.innerHTML = '<option value="">No moneyness available</option>';
                    deltaExpirySelect.innerHTML = '<option value="">No expiries available</option>';
                    return;
                }
                const prevMoneyness = moneynessSelect.value;
                const prevExpiry = expirySelect.value;
                const uniqueRoundedMoneyness = [...new Set(tickerData.map(item => Math.round(item.Moneyness * 100 / 10) * 0.1))]
                    .filter(val => !isNaN(val)).sort((a, b) => a - b);
                moneynessSelect.innerHTML = '';
                uniqueRoundedMoneyness.forEach(val => {
                    const option = document.createElement('option');
                    option.value = val;
                    option.text = `${(val * 100).toFixed(0)}%`;
                    moneynessSelect.appendChild(option);
                });
                const targetMoneyness = 1.0;
                let closestMoneyness = uniqueRoundedMoneyness[0];
                if (uniqueRoundedMoneyness.length > 0) {
                    closestMoneyness = uniqueRoundedMoneyness.reduce((prev, curr) =>
                        Math.abs(curr - targetMoneyness) < Math.abs(prev - targetMoneyness) ? curr : prev
                    );
                }
                if (prevMoneyness && uniqueRoundedMoneyness.map(String).includes(prevMoneyness)) {
                    moneynessSelect.value = prevMoneyness;
                } else if (uniqueRoundedMoneyness.includes(targetMoneyness)) {
                    moneynessSelect.value = targetMoneyness.toString();
                } else if (uniqueRoundedMoneyness.length > 0) {
                    moneynessSelect.value = closestMoneyness.toString();
                } else {
                    moneynessSelect.value = '';
                }
                console.log('Moneyness dropdown updated, selected:', moneynessSelect.value);
                const uniqueExpiries = [...new Set(tickerData.map(item => item.Expiry))]
                    .filter(val => val && !isNaN(new Date(val).getTime())).sort((a, b) => new Date(a) - new Date(b));
                expirySelect.innerHTML = '';
                deltaExpirySelect.innerHTML = '';
                uniqueExpiries.forEach(val => {
                    const option = document.createElement('option');
                    option.value = val;
                    option.text = new Date(val).toLocaleDateString('en-GB');
                    expirySelect.appendChild(option);
                    deltaExpirySelect.appendChild(option.cloneNode(true));
                });
                if (prevExpiry && uniqueExpiries.includes(prevExpiry)) {
                    expirySelect.value = prevExpiry;
                    deltaExpirySelect.value = prevExpiry;
                } else if (uniqueExpiries.length > 0) {
                    expirySelect.value = uniqueExpiries[0];
                    deltaExpirySelect.value = uniqueExpiries[0];
                } else {
                    expirySelect.value = '';
                    deltaExpirySelect.value = '';
                }
                console.log('Expiry dropdowns updated, selected:', expirySelect.value);
            } catch (error) {
                console.error('Error updating dropdowns:', error);
                document.getElementById('historic-error').textContent = `Error updating dropdowns: ${error.message}`;
                document.getElementById('historic-error').style.display = 'block';
            }
        }

        function updateSkewTable() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase() || 'MSTR';
                let selectedExpiry = document.getElementById('expiry-select').value;
                const filteredSkewData = skewData.filter(item => item.Ticker && item.Ticker.toUpperCase() === selectedTicker);
                const table = document.getElementById('skew-table');
                table.innerHTML = '';
                if (filteredSkewData.length === 0) {
                    const row = table.insertRow();
                    const cell = row.insertCell();
                    cell.textContent = 'No skew metrics available';
                    cell.colSpan = 6;
                    console.warn('No skew data for ticker:', selectedTicker);
                    return;
                }
                const uniqueExpiries = [...new Set(filteredSkewData.map(item => item.Expiry))]
                    .filter(val => val && !isNaN(new Date(val).getTime())).sort((a, b) => new Date(a) - new Date(b));
                if (!selectedExpiry || isNaN(new Date(selectedExpiry).getTime())) {
                    selectedExpiry = uniqueExpiries[0] || null;
                    if (selectedExpiry) {
                        document.getElementById('expiry-select').value = selectedExpiry;
                        document.getElementById('delta-expiry-select').value = selectedExpiry;
                        console.log('Set default expiry:', selectedExpiry);
                    }
                }
                let normalizedSelectedExpiry = null;
                if (selectedExpiry) {
                    try {
                        normalizedSelectedExpiry = normalizeDate(selectedExpiry);
                    } catch (e) {
                        console.warn('Invalid expiry date, using default:', e);
                        normalizedSelectedExpiry = uniqueExpiries.length > 0 ? normalizeDate(uniqueExpiries[0]) : null;
                    }
                }
                const thead = document.createElement('thead');
                const headerRow = thead.insertRow();
                ['Expiry', 'Skew 25 Delta', 'Skew 75 Delta', 'Skew Call 25/75', 'Skew Put 25/75', 'ATM 12m/3m Ratio'].forEach(text => {
                    const th = document.createElement('th');
                    th.textContent = text;
                    headerRow.appendChild(th);
                });
                table.appendChild(thead);
                const tbody = document.createElement('tbody');
                const selectedRow = normalizedSelectedExpiry ? filteredSkewData.find(item => {
                    try {
                        return normalizeDate(item.Expiry) === normalizedSelectedExpiry;
                    } catch {
                        return false;
                    }
                }) : filteredSkewData[0];
                const row = tbody.insertRow();
                if (selectedRow && selectedRow.Expiry) {
                    row.insertCell().textContent = new Date(selectedRow.Expiry).toLocaleDateString('en-GB');
                    row.insertCell().textContent = Number.isFinite(selectedRow.Skew_25_delta) ? selectedRow.Skew_25_delta.toFixed(4) : 'N/A';
                    row.insertCell().textContent = Number.isFinite(selectedRow.Skew_75_delta) ? selectedRow.Skew_75_delta.toFixed(4) : 'N/A';
                    row.insertCell().textContent = Number.isFinite(selectedRow.Skew_call_25_75) ? selectedRow.Skew_call_25_75.toFixed(4) : 'N/A';
                    row.insertCell().textContent = Number.isFinite(selectedRow.Skew_put_25_75) ? selectedRow.Skew_put_25_75.toFixed(4) : 'N/A';
                    row.insertCell().textContent = Number.isFinite(selectedRow.ATM_12m_3m_Ratio) ? selectedRow.ATM_12m_3m_Ratio.toFixed(4) : 'N/A';
                } else {
                    const cell = row.insertCell();
                    cell.textContent = 'No data for selected expiry';
                    cell.colSpan = 6;
                }
                table.appendChild(tbody);
                console.log('Skew table updated for expiry:', normalizedSelectedExpiry);
            } catch (error) {
                console.error('Error updating skew table:', error);
                const table = document.getElementById('skew-table');
                table.innerHTML = '<tr><td colspan="6">Error loading skew table</td></tr>';
            }
        }

        function updateSummaryTable() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase() || 'MSTR';
                const selectedExpiry = document.getElementById('expiry-select').value || '';
                const table = document.getElementById('summary-table');
                table.innerHTML = '';
                if (!rankingData.length) {
                    const row = table.insertRow();
                    const cell = row.insertCell();
                    cell.textContent = 'No ranking data available';
                    cell.colSpan = 4;
                    console.warn('No ranking data for summary table');
                    return;
                }
                let normalizedSelectedExpiry = null;
                if (selectedExpiry) {
                    try {
                        normalizedSelectedExpiry = normalizeDate(selectedExpiry);
                    } catch (e) {
                        console.warn('Invalid expiry date, proceeding without expiry:', e);
                    }
                }
                const thead = document.createElement('thead');
                const headerRow = thead.insertRow();
                ['Metric', 'Value', 'Metric', 'Value'].forEach(text => {
                    const th = document.createElement('th');
                    th.textContent = text;
                    headerRow.appendChild(th);
                });
                table.appendChild(thead);
                const tbody = document.createElement('tbody');
                const changeMetrics = [
                    'Close 1d (%)', 'Close 1w (%)', 'High 1d (%)', 'High 1w (%)', 'Low 1d (%)', 'Low 1w (%)',
                    'Realised Volatility 100d 1d (%)', 'Realised Volatility 100d 1w (%)', 'Volume 1d (%)',
                    'Volume 1w (%)', 'OI 1d (%)', 'OI 1w (%)', 'Weighted IV 1d (%)', 'Weighted IV 1w (%)'
                ];
                const metrics = [];
                const filteredRankingData = rankingData.find(item => item.Ticker && item.Ticker.toUpperCase() === selectedTicker);
                if (filteredRankingData) {
                    metrics.push(
                        { name: 'Ticker', value: filteredRankingData['Ticker'] || 'N/A', key: 'Ticker' },
                        { name: 'Latest Close ($)', value: Number.isFinite(filteredRankingData['Latest Close']) ? filteredRankingData['Latest Close'].toFixed(2) : 'N/A', key: 'Latest Close' },
                        { name: 'Latest High ($)', value: Number.isFinite(filteredRankingData['Latest High']) ? filteredRankingData['Latest High'].toFixed(2) : 'N/A', key: 'Latest High' },
                        { name: 'Latest Low ($)', value: Number.isFinite(filteredRankingData['Latest Low']) ? filteredRankingData['Latest Low'].toFixed(2) : 'N/A', key: 'Latest Low' },
                        { name: 'Close 1d (%)', value: Number.isFinite(filteredRankingData['Close 1d (%)']) ? filteredRankingData['Close 1d (%)'].toFixed(2) : 'N/A', key: 'Close 1d (%)' },
                        { name: 'Close 1w (%)', value: Number.isFinite(filteredRankingData['Close 1w (%)']) ? filteredRankingData['Close 1w (%)'].toFixed(2) : 'N/A', key: 'Close 1w (%)' },
                        { name: 'High 1d (%)', value: Number.isFinite(filteredRankingData['High 1d (%)']) ? filteredRankingData['High 1d (%)'].toFixed(2) : 'N/A', key: 'High 1d (%)' },
                        { name: 'High 1w (%)', value: Number.isFinite(filteredRankingData['High 1w (%)']) ? filteredRankingData['High 1w (%)'].toFixed(2) : 'N/A', key: 'High 1w (%)' },
                        { name: 'Low 1d (%)', value: Number.isFinite(filteredRankingData['Low 1d (%)']) ? filteredRankingData['Low 1d (%)'].toFixed(2) : 'N/A', key: 'Low 1d (%)' },
                        { name: 'Low 1w (%)', value: Number.isFinite(filteredRankingData['Low 1w (%)']) ? filteredRankingData['Low 1w (%)'].toFixed(2) : 'N/A', key: 'Low 1w (%)' },
                        { name: 'Realised Volatility 30d (%)', value: Number.isFinite(filteredRankingData['Realised Volatility 30d (%)']) ? filteredRankingData['Realised Volatility 30d (%)'].toFixed(2) : 'N/A', key: 'Realised Volatility 30d (%)' },
                        { name: 'Realised Volatility 60d (%)', value: Number.isFinite(filteredRankingData['Realised Volatility 60d (%)']) ? filteredRankingData['Realised Volatility 60d (%)'].toFixed(2) : 'N/A', key: 'Realised Volatility 60d (%)' },
                        { name: 'Realised Volatility 100d (%)', value: Number.isFinite(filteredRankingData['Realised Volatility 100d (%)']) ? filteredRankingData['Realised Volatility 100d (%)'].toFixed(2) : 'N/A', key: 'Realised Volatility 100d (%)' },
                        { name: 'Realised Volatility 100d 1d (%)', value: Number.isFinite(filteredRankingData['Realised Volatility 100d 1d (%)']) ? filteredRankingData['Realised Volatility 100d 1d (%)'].toFixed(2) : 'N/A', key: 'Realised Volatility 100d 1d (%)' },
                        { name: 'Realised Volatility 100d 1w (%)', value: Number.isFinite(filteredRankingData['Realised Volatility 100d 1w (%)']) ? filteredRankingData['Realised Volatility 100d 1w (%)'].toFixed(2) : 'N/A', key: 'Realised Volatility 100d 1w (%)' },
                        { name: 'Min Realised Volatility 100d (1y)', value: Number.isFinite(filteredRankingData['Min Realised Volatility 100d (1y)']) ? filteredRankingData['Min Realised Volatility 100d (1y)'].toFixed(2) : 'N/A', key: 'Min Realised Volatility 100d (1y)' },
                        { name: 'Max Realised Volatility 100d (1y)', value: Number.isFinite(filteredRankingData['Max Realised Volatility 100d (1y)']) ? filteredRankingData['Max Realised Volatility 100d (1y)'].toFixed(2) : 'N/A', key: 'Max Realised Volatility 100d (1y)' },
                        { name: 'Mean Realised Volatility 100d (1y)', value: Number.isFinite(filteredRankingData['Mean Realised Volatility 100d (1y)']) ? filteredRankingData['Mean Realised Volatility 100d (1y)'].toFixed(2) : 'N/A', key: 'Mean Realised Volatility 100d (1y)' },
                        { name: 'Rvol 100d Percentile (%)', value: Number.isFinite(filteredRankingData['Rvol 100d Percentile (%)']) ? filteredRankingData['Rvol 100d Percentile (%)'].toFixed(2) : 'N/A', key: 'Rvol 100d Percentile (%)' },
                        { name: 'Rvol 100d Z-Score Percentile (%)', value: Number.isFinite(filteredRankingData['Rvol 100d Z-Score Percentile (%)']) ? filteredRankingData['Rvol 100d Z-Score Percentile (%)'].toFixed(2) : 'N/A', key: 'Rvol 100d Z-Score Percentile (%)' },
                        { name: 'Realised Volatility 180d (%)', value: Number.isFinite(filteredRankingData['Realised Volatility 180d (%)']) ? filteredRankingData['Realised Volatility 180d (%)'].toFixed(2) : 'N/A', key: 'Realised Volatility 180d (%)' },
                        { name: 'Realised Volatility 252d (%)', value: Number.isFinite(filteredRankingData['Realised Volatility 252d (%)']) ? filteredRankingData['Realised Volatility 252d (%)'].toFixed(2) : 'N/A', key: 'Realised Volatility 252d (%)' },
                        { name: 'Weighted IV (%)', value: Number.isFinite(filteredRankingData['Weighted IV (%)']) ? filteredRankingData['Weighted IV (%)'].toFixed(2) : 'N/A', key: 'Weighted IV (%)' },
                        { name: 'Weighted IV 1d (%)', value: Number.isFinite(filteredRankingData['Weighted IV 1d (%)']) ? filteredRankingData['Weighted IV 1d (%)'].toFixed(2) : 'N/A', key: 'Weighted IV 1d (%)' },
                        { name: 'Weighted IV 1w (%)', value: Number.isFinite(filteredRankingData['Weighted IV 1w (%)']) ? filteredRankingData['Weighted IV 1w (%)'].toFixed(2) : 'N/A', key: 'Weighted IV 1w (%)' },
                        { name: 'Rvol100d - Weighted IV', value: Number.isFinite(filteredRankingData['Rvol100d - Weighted IV']) ? filteredRankingData['Rvol100d - Weighted IV'].toFixed(2) : 'N/A', key: 'Rvol100d - Weighted IV' },
                        { name: 'Volume', value: Number.isFinite(filteredRankingData['Volume']) ? parseInt(filteredRankingData['Volume']).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 }) : 'N/A', key: 'Volume' },
                        { name: 'Volume 1d (%)', value: Number.isFinite(filteredRankingData['Volume 1d (%)']) ? filteredRankingData['Volume 1d (%)'].toFixed(2) : 'N/A', key: 'Volume 1d (%)' },
                        { name: 'Volume 1w (%)', value: Number.isFinite(filteredRankingData['Volume 1w (%)']) ? filteredRankingData['Volume 1w (%)'].toFixed(2) : 'N/A', key: 'Volume 1w (%)' },
                        { name: 'Open Interest', value: Number.isFinite(filteredRankingData['Open Interest']) ? parseInt(filteredRankingData['Open Interest']).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 }) : 'N/A', key: 'Open Interest' },
                        { name: 'OI 1d (%)', value: Number.isFinite(filteredRankingData['OI 1d (%)']) ? filteredRankingData['OI 1d (%)'].toFixed(2) : 'N/A', key: 'OI 1d (%)' },
                        { name: 'OI 1w (%)', value: Number.isFinite(filteredRankingData['OI 1w (%)']) ? filteredRankingData['OI 1w (%)'].toFixed(2) : 'N/A', key: 'OI 1w (%)' }
                    );
                } else {
                    metrics.push({ name: 'Ticker', value: selectedTicker || 'N/A', key: 'Ticker' });
                    console.warn('No ranking data for ticker:', selectedTicker);
                }
                let atmRatio = 'N/A';
                const filteredSkewData = skewData.filter(item => item.Ticker && item.Ticker.toUpperCase() === selectedTicker);
                const selectedSkewRow = normalizedSelectedExpiry ? filteredSkewData.find(item => {
                    try {
                        return normalizeDate(item.Expiry) === normalizedSelectedExpiry;
                    } catch {
                        return false;
                    }
                }) : filteredSkewData[0];
                if (selectedSkewRow) {
                    atmRatio = Number.isFinite(selectedSkewRow.ATM_12m_3m_Ratio) ? selectedSkewRow.ATM_12m_3m_Ratio.toFixed(4) : 'N/A';
                }
                metrics.push({ name: 'ATM 12m/3m Ratio', value: atmRatio, key: 'ATM_12m_3m_Ratio' });
                const filteredSlopeData = slopeData.filter(item => item.Ticker && item.Ticker.toUpperCase() === selectedTicker);
                if (filteredSlopeData.length > 0) {
                    filteredSlopeData.forEach(item => {
                        metrics.push({
                            name: `IV Slope 3m/12m (${item.Type} Delta ${Number.isFinite(item.Delta) ? item.Delta.toFixed(2) : 'N/A'})`,
                            value: Number.isFinite(item.IV_Slope_3m_12m) ? item.IV_Slope_3m_12m.toFixed(4) : 'N/A',
                            key: `IV_Slope_3m_12m_${item.Type}_${item.Delta}`
                        });
                    });
                } else {
                    metrics.push({ name: 'IV Slope 3m/12m', value: 'No slope metrics available', key: 'IV_Slope_3m_12m' });
                }
                for (let i = 0; i < metrics.length; i += 2) {
                    const row = tbody.insertRow();
                    const metric1Cell = row.insertCell();
                    metric1Cell.textContent = metrics[i].name;
                    const value1Cell = row.insertCell();
                    value1Cell.textContent = metrics[i].value;
                    if (changeMetrics.includes(metrics[i].name) && Number.isFinite(parseFloat(metrics[i].value))) {
                        const val = parseFloat(metrics[i].value);
                        value1Cell.style.color = val < 0 ? '#F87171' : val > 0 ? '#10B981' : '#FFFFFF';
                    }
                    const metric2Cell = row.insertCell();
                    metric2Cell.textContent = i + 1 < metrics.length ? metrics[i + 1].name : '';
                    const value2Cell = row.insertCell();
                    value2Cell.textContent = i + 1 < metrics.length ? metrics[i + 1].value : '';
                    if (i + 1 < metrics.length && changeMetrics.includes(metrics[i + 1].name) && Number.isFinite(parseFloat(metrics[i + 1].value))) {
                        const val = parseFloat(metrics[i + 1].value);
                        value2Cell.style.color = val < 0 ? '#F87171' : val > 0 ? '#10B981' : '#FFFFFF';
                    }
                }
                table.appendChild(tbody);
                console.log('Summary table updated with metrics:', metrics.map(m => ({ name: m.name, value: m.value })));
            } catch (error) {
                console.error('Error updating summary table:', error);
                const table = document.getElementById('summary-table');
                table.innerHTML = '<tr><td colspan="4">Error loading summary table</td></tr>';
            }
        }

        function updateRankingTable() {
            try {
                const table = document.getElementById('ranking-table');
                table.innerHTML = '';
                if (!rankingData.length) {
                    const row = table.insertRow();
                    const cell = row.insertCell();
                    cell.textContent = 'No ranking data available';
                    cell.colSpan = 33;
                    console.warn('No ranking data for ranking table');
                    return;
                }
                const columns = [
                    'Rank',
                    'Ticker',
                    'Latest Close',
                    'Latest High',
                    'Latest Low',
                    'Close 1d (%)',
                    'Close 1w (%)',
                    'High 1d (%)',
                    'High 1w (%)',
                    'Low 1d (%)',
                    'Low 1w (%)',
                    'Realised Volatility 30d (%)',
                    'Realised Volatility 60d (%)',
                    'Realised Volatility 100d (%)',
                    'Realised Volatility 100d 1d (%)',
                    'Realised Volatility 100d 1w (%)',
                    'Min Realised Volatility 100d (1y)',
                    'Max Realised Volatility 100d (1y)',
                    'Mean Realised Volatility 100d (1y)',
                    'Rvol 100d Percentile (%)',
                    'Rvol 100d Z-Score Percentile (%)',
                    'Realised Volatility 180d (%)',
                    'Realised Volatility 252d (%)',
                    'Weighted IV (%)',
                    'Weighted IV 1d (%)',
                    'Weighted IV 1w (%)',
                    'Rvol100d - Weighted IV',
                    'Volume',
                    'Volume 1d (%)',
                    'Volume 1w (%)',
                    'Open Interest',
                    'OI 1d (%)',
                    'OI 1w (%)'
                ];
                const sortedData = [...rankingData].sort((a, b) => {
                    const aValue = Number.isFinite(a['Open Interest']) ? parseInt(a['Open Interest']) : -Infinity;
                    const bValue = Number.isFinite(b['Open Interest']) ? parseInt(b['Open Interest']) : -Infinity;
                    return bValue - aValue;
                });
                sortedData.forEach((item, index) => {
                    item.CalculatedRank = index + 1;
                });
                const thead = document.createElement('thead');
                const headerRow = thead.insertRow();
                columns.forEach((text, index) => {
                    const th = document.createElement('th');
                    th.textContent = text;
                    th.dataset.column = text;
                    th.dataset.order = 'desc';
                    th.addEventListener('click', () => sortTable('ranking-table', index));
                    headerRow.appendChild(th);
                });
                table.appendChild(thead);
                const tbody = document.createElement('tbody');
                sortedData.forEach(item => {
                    const row = tbody.insertRow();
                    columns.forEach(col => {
                        const cell = row.insertCell();
                        let value = col === 'Rank' ? item.CalculatedRank : item[col];
                        if (col === 'Rank') {
                            value = Number.isFinite(value) ? parseInt(value) : 'N/A';
                        } else if (col === 'Volume' || col === 'Open Interest') {
                            value = Number.isFinite(value) ? parseInt(value).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 }) : 'N/A';
                        } else if (Number.isFinite(value)) {
                            value = value.toFixed(2);
                        } else {
                            value = value === 'N/A' || value == null ? 'N/A' : value;
                        }
                        cell.textContent = value;
                        if ((col.includes('(%)') || col.includes('Rvol') || col.includes('Weighted IV') || col === 'Rvol100d - Weighted IV') && Number.isFinite(parseFloat(item[col]))) {
                            const val = parseFloat(item[col]);
                            cell.style.color = val < 0 ? '#F87171' : val > 0 ? '#10B981' : '#FFFFFF';
                        }
                    });
                });
                table.appendChild(tbody);
                console.log('Ranking table updated successfully');
            } catch (error) {
                console.error('Error updating ranking table:', error);
                const table = document.getElementById('ranking-table');
                table.innerHTML = '<tr><td colspan="33">Error loading ranking table</td></tr>';
            }
        }

        function updateRawDataTable() {
            try {
                const table = document.getElementById('raw-data-table');
                table.innerHTML = '';
                if (rawData.length === 0) {
                    const row = table.insertRow();
                    const cell = row.insertCell();
                    cell.textContent = 'No raw data available';
                    cell.colSpan = 10;
                    console.warn('No raw data for raw data table');
                    return;
                }
                const thead = document.createElement('thead');
                const headerRow = thead.insertRow();
                const columns = Object.keys(rawData[0]);
                columns.forEach((text, index) => {
                    const th = document.createElement('th');
                    th.textContent = text;
                    th.dataset.column = text;
                    th.dataset.order = 'desc';
                    th.addEventListener('click', () => sortTable('raw-data-table', index));
                    headerRow.appendChild(th);
                });
                table.appendChild(thead);
                const tbody = document.createElement('tbody');
                rawData.forEach(item => {
                    const row = tbody.insertRow();
                    columns.forEach(col => {
                        const cell = row.insertCell();
                        let value = item[col];
                        if (Number.isFinite(value)) {
                            if (col === 'Volume' || col === 'Open Interest') {
                                value = parseInt(value).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
                            } else {
                                value = value.toFixed(2);
                            }
                        } else {
                            value = value || 'N/A';
                        }
                        cell.textContent = value;
                    });
                });
                table.appendChild(tbody);
            } catch (error) {
                console.error('Error updating raw data table:', error);
                const table = document.getElementById('raw-data-table');
                table.innerHTML = '<tr><td colspan="10">Error loading raw data table</td></tr>';
            }
        }

        function sortTable(tableId, columnIndex) {
            try {
                const table = document.getElementById(tableId);
                const header = table.querySelector('thead tr').children[columnIndex];
                const column = header.dataset.column;
                const order = header.dataset.order === 'desc' ? 'asc' : 'desc';
                header.dataset.order = order;
                const tbody = table.querySelector('tbody');
                const rows = Array.from(tbody.querySelectorAll('tr'));
                rows.sort((a, b) => {
                    let aValue = a.children[columnIndex].textContent;
                    let bValue = b.children[columnIndex].textContent;
                    if (aValue === 'N/A') return 1;
                    if (bValue === 'N/A') return -1;
                    if (column === 'Volume' || column === 'Open Interest') {
                        aValue = parseInt(aValue.replace(/,/g, '')) || -Infinity;
                        bValue = parseInt(bValue.replace(/,/g, '')) || -Infinity;
                    } else if (column === 'Rank') {
                        aValue = parseInt(aValue);
                        bValue = parseInt(bValue);
                    } else {
                        aValue = parseFloat(aValue) || aValue;
                        bValue = parseFloat(bValue) || bValue;
                    }
                    if (typeof aValue === 'number' && typeof bValue === 'number') {
                        return order === 'desc' ? bValue - aValue : aValue - bValue;
                    }
                    return order === 'desc' ? bValue.localeCompare(aValue) : aValue.localeCompare(bValue);
                });
                tbody.innerHTML = '';
                rows.forEach(row => tbody.appendChild(row));
            } catch (error) {
                console.error('Error sorting table:', error);
            }
        }

        function updateMoneynessVsIV() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const selectedExpiry = document.getElementById('expiry-select').value;
                const filteredData = data.filter(item => item.Ticker === selectedTicker && item.Expiry === selectedExpiry);
                const errorDiv = document.getElementById('moneyness-error');
                errorDiv.style.display = 'none';
                if (!filteredData.length) {
                    console.warn('No data for Moneyness vs. IV chart:', { ticker: selectedTicker, expiry: selectedExpiry });
                    if (moneynessChart) moneynessChart.destroy();
                    errorDiv.textContent = 'No data for selected ticker and expiry';
                    errorDiv.style.display = 'block';
                    return;
                }
                const datasets = [
                    {
                        label: 'Calls Smoothed IV',
                        data: aggregateDataByX(filteredData.filter(item => item.Type === 'Call'), 'Moneyness', 'Smoothed_IV'),
                        borderColor: '#FFFF00', // Yellow
                        backgroundColor: 'rgba(255, 255, 0, 0.2)', // Yellow shade
                        pointRadius: 1,
                        fill: true,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Puts Smoothed IV',
                        data: aggregateDataByX(filteredData.filter(item => item.Type === 'Put'), 'Moneyness', 'Smoothed_IV'),
                        borderColor: '#A020F0', // Purple
                        backgroundColor: 'rgba(160, 32, 240, 0.2)', // Purple shade
                        pointRadius: 1,
                        fill: true,
                        showLine: true,
                        borderDash: [5, 5],
                        yAxisID: 'y'
                    }
                ];
                if (moneynessChart) moneynessChart.destroy();
                const canvas = document.getElementById('moneyness-vs-iv-chart');
                if (!canvas.getContext('2d')) {
                    throw new Error('Canvas context not available for moneyness-vs-iv-chart');
                }
                moneynessChart = new Chart(canvas.getContext('2d'), {
                    type: 'line',
                    data: { datasets },
                    options: {
                        plugins: { legend: { labels: { color: '#FFFFFF' } } },
                        scales: {
                            x: {
                                type: 'linear',
                                title: { display: true, text: 'Moneyness (%)', color: '#FFFFFF' },
                                min: 0,
                                max: 200,
                                grid: { color: '#A855F7' },
                                ticks: { color: '#FFFFFF' }
                            },
                            y: {
                                title: { display: true, text: 'Volatility (%)', color: '#FFFFFF' },
                                beginAtZero: true,
                                grid: { color: '#A855F7' },
                                ticks: { color: '#FFFFFF' }
                            }
                        },
                        backgroundColor: '#1A1A2E'
                    }
                });
                createStatsTable(moneynessChart, 'moneyness-vs-iv-chart');
            } catch (error) {
                console.error('Error updating Moneyness vs. IV chart:', error);
                document.getElementById('moneyness-error').textContent = `Error rendering chart: ${error.message}`;
                document.getElementById('moneyness-error').style.display = 'block';
            }
        }

        function updateExpiryVsIV() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const selectedMoneyness = parseFloat(document.getElementById('moneyness-select').value);
                const filteredData = data.filter(item => item.Ticker === selectedTicker && Math.round(item.Moneyness * 100 / 10) * 0.1 === selectedMoneyness);
                const errorDiv = document.getElementById('expiry-error');
                errorDiv.style.display = 'none';
                if (!filteredData.length) {
                    console.warn('No data for Expiry vs. IV chart:', { ticker: selectedTicker, moneyness: selectedMoneyness });
                    if (expiryChart) expiryChart.destroy();
                    errorDiv.textContent = 'No data for selected ticker and moneyness';
                    errorDiv.style.display = 'block';
                    return;
                }
                const datasets = [
                    {
                        label: 'Calls Smoothed IV',
                        data: aggregateDataByX(filteredData.filter(item => item.Type === 'Call'), 'Expiry', 'Smoothed_IV'),
                        borderColor: '#FFFF00', // Yellow
                        backgroundColor: 'rgba(255, 255, 0, 0.2)', // Yellow shade
                        pointRadius: 1,
                        fill: true,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Puts Smoothed IV',
                        data: aggregateDataByX(filteredData.filter(item => item.Type === 'Put'), 'Expiry', 'Smoothed_IV'),
                        borderColor: '#A020F0', // Purple
                        backgroundColor: 'rgba(160, 32, 240, 0.2)', // Purple shade
                        pointRadius: 1,
                        fill: true,
                        showLine: true,
                        borderDash: [5, 5],
                        yAxisID: 'y'
                    }
                ];
                if (expiryChart) expiryChart.destroy();
                const canvas = document.getElementById('expiry-vs-iv-chart');
                if (!canvas.getContext('2d')) {
                    throw new Error('Canvas context not available for expiry-vs-iv-chart');
                }
                expiryChart = new Chart(canvas.getContext('2d'), {
                    type: 'line',
                    data: { datasets },
                    options: {
                        plugins: { legend: { labels: { color: '#FFFFFF' } } },
                        scales: {
                            x: {
                                type: 'time',
                                time: { unit: 'day' },
                                title: { display: true, text: 'Expiry Date', color: '#FFFFFF' },
                                grid: { color: '#A855F7' },
                                ticks: { color: '#FFFFFF' }
                            },
                            y: {
                                title: { display: true, text: 'Volatility (%)', color: '#FFFFFF' },
                                beginAtZero: true,
                                grid: { color: '#A855F7' },
                                ticks: { color: '#FFFFFF' }
                            }
                        },
                        backgroundColor: '#1A1A2E'
                    }
                });
                createStatsTable(expiryChart, 'expiry-vs-iv-chart');
            } catch (error) {
                console.error('Error updating Expiry vs. IV chart:', error);
                document.getElementById('expiry-error').textContent = `Error rendering chart: ${error.message}`;
                document.getElementById('expiry-error').style.display = 'block';
            }
        }

        function updateSkewVsExpiry() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const filteredSkewData = skewData.filter(item => item.Ticker && item.Ticker.toUpperCase() === selectedTicker);
                const errorDiv = document.getElementById('skew-error');
                errorDiv.style.display = 'none';
                if (!filteredSkewData.length) {
                    console.warn('No data for Skew vs. Expiry chart:', { ticker: selectedTicker });
                    if (skewChart) skewChart.destroy();
                    errorDiv.textContent = 'No skew data available';
                    errorDiv.style.display = 'block';
                    return;
                }
                const datasets = [
                    {
                        label: 'Skew 25 Delta',
                        data: aggregateDataByX(filteredSkewData, 'Expiry', 'Skew_25_delta'),
                        borderColor: '#FFA500', // Orange
                        backgroundColor: '#FFA500',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    }
                ];
                if (skewChart) skewChart.destroy();
                const canvas = document.getElementById('skew-vs-expiry-chart');
                if (!canvas.getContext('2d')) {
                    throw new Error('Canvas context not available for skew-vs-expiry-chart');
                }
                skewChart = new Chart(canvas.getContext('2d'), {
                    type: 'line',
                    data: { datasets },
                    options: {
                        plugins: { legend: { labels: { color: '#FFFFFF' } } },
                        scales: {
                            x: {
                                type: 'time',
                                time: { unit: 'day' },
                                title: { display: true, text: 'Expiry Date', color: '#FFFFFF' },
                                grid: { color: '#A855F7' },
                                ticks: { color: '#FFFFFF' }
                            },
                            y: {
                                title: { display: true, text: 'Skew', color: '#FFFFFF' },
                                beginAtZero: false,
                                grid: { color: '#A855F7' },
                                ticks: { color: '#FFFFFF' }
                            }
                        },
                        backgroundColor: '#1A1A2E'
                    }
                });
                createStatsTable(skewChart, 'skew-vs-expiry-chart');
            } catch (error) {
                console.error('Error updating Skew vs Expiry chart:', error);
                document.getElementById('skew-error').textContent = `Error rendering chart: ${error.message}`;
                document.getElementById('skew-error').style.display = 'block';
            }
        }

        function updateRealisedVolChart() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const errorDiv = document.getElementById('realised-vol-error');
                errorDiv.style.display = 'none';
                let filteredHistoric = historicData.filter(item => item.Ticker === selectedTicker && item.Date);
                if (!filteredHistoric.length) {
                    console.warn('No data for Realised Volatility chart:', { ticker: selectedTicker });
                    if (realisedVolChart) realisedVolChart.destroy();
                    errorDiv.textContent = 'No historic data available';
                    errorDiv.style.display = 'block';
                    return;
                }
                filteredHistoric.sort((a, b) => new Date(a.Date) - new Date(b.Date));
                const dates = filteredHistoric.map(item => new Date(item.Date));
                const volColumns = [
                    'Realised_Vol_Close_30', 'Realized_Vol_Close_30',
                    'Realised_Vol_Close_60', 'Realized_Vol_Close_60',
                    'Realised_Vol_Close_100', 'Realized_Vol_Close_100',
                    'Realised_Vol_Close_180', 'Realized_Vol_Close_180',
                    'Realised_Vol_Close_252', 'Realized_Vol_Close_252'
                ];
                const availableVolColumns = volColumns.filter(col => filteredHistoric[0].hasOwnProperty(col));
                const vol30 = filteredHistoric.map(item => {
                    const col = availableVolColumns.find(c => c.includes('30')) || 'Realised_Vol_Close_30';
                    return Number.isFinite(item[col]) ? parseFloat(item[col]) : null;
                }).filter(v => v !== null);
                const vol60 = filteredHistoric.map(item => {
                    const col = availableVolColumns.find(c => c.includes('60')) || 'Realised_Vol_Close_60';
                    return Number.isFinite(item[col]) ? parseFloat(item[col]) : null;
                }).filter(v => v !== null);
                const vol90 = filteredHistoric.map(item => {
                    const col = availableVolColumns.find(c => c.includes('100')) || 'Realised_Vol_Close_100';
                    return Number.isFinite(item[col]) ? parseFloat(item[col]) : null;
                }).filter(v => v !== null);
                const vol180 = filteredHistoric.map(item => {
                    const col = availableVolColumns.find(c => c.includes('180')) || 'Realised_Vol_Close_180';
                    return Number.isFinite(item[col]) ? parseFloat(item[col]) : null;
                }).filter(v => v !== null);
                const vol360 = filteredHistoric.map(item => {
                    const col = availableVolColumns.find(c => c.includes('252')) || 'Realised_Vol_Close_252';
                    return Number.isFinite(item[col]) ? parseFloat(item[col]) : null;
                }).filter(v => v !== null);
                const datasets = [
                    {
                        label: '30-day Realised Vol (%)',
                        data: vol30.map((v, i) => ({ x: dates[i], y: v })),
                        borderColor: '#0000FF', // Blue
                        backgroundColor: 'rgba(0, 0, 255, 0.2)', // Blue shade
                        pointRadius: 1,
                        fill: true,
                        showLine: true,
                        yAxisID: 'y'
                    },
                    {
                        label: '60-day Realised Vol (%)',
                        data: vol60.map((v, i) => ({ x: dates[i], y: v })),
                        borderColor: '#008000', // Green
                        backgroundColor: 'rgba(0, 128, 0, 0.2)', // Green shade
                        pointRadius: 1,
                        fill: true,
                        showLine: true,
                        yAxisID: 'y'
                    },
                    {
                        label: '100-day Realised Vol (%)',
                        data: vol90.map((v, i) => ({ x: dates[i], y: v })),
                        borderColor: '#FF0000', // Red
                        backgroundColor: 'rgba(255, 0, 0, 0.2)', // Red shade
                        pointRadius: 1,
                        fill: true,
                        showLine: true,
                        yAxisID: 'y'
                    },
                    {
                        label: '180-day Realised Vol (%)',
                        data: vol180.map((v, i) => ({ x: dates[i], y: v })),
                        borderColor: '#FFA500', // Orange
                        backgroundColor: 'rgba(255, 165, 0, 0.2)', // Orange shade
                        pointRadius: 1,
                        fill: true,
                        showLine: true,
                        yAxisID: 'y'
                    },
                    {
                        label: '252-day Realised Vol (%)',
                        data: vol360.map((v, i) => ({ x: dates[i], y: v })),
                        borderColor: '#A020F0', // Purple
                        backgroundColor: 'rgba(160, 32, 240, 0.2)', // Purple shade
                        pointRadius: 1,
                        fill: true,
                        showLine: true,
                        yAxisID: 'y'
                    }
                ];
                if (realisedVolChart) realisedVolChart.destroy();
                const canvas = document.getElementById('realised-vol-chart');
                if (!canvas.getContext('2d')) {
                    throw new Error('Canvas context not available for realised-vol-chart');
                }
                realisedVolChart = new Chart(canvas.getContext('2d'), {
                    type: 'line',
                    data: { datasets },
                    options: {
                        plugins: { legend: { labels: { color: '#FFFFFF' } } },
                        scales: {
                            x: {
                                type: 'time',
                                time: { unit: 'month' },
                                title: { display: true, text: 'Date', color: '#FFFFFF' },
                                grid: { color: '#A855F7' },
                                ticks: { color: '#FFFFFF' }
                            },
                            y: {
                                title: { display: true, text: 'Realised Volatility (%)', color: '#FFFFFF' },
                                beginAtZero: false,
                                grid: { color: '#A855F7' },
                                ticks: { color: '#FFFFFF' }
                            }
                        },
                        backgroundColor: '#1A1A2E'
                    }
                });
                createStatsTable(realisedVolChart, 'realised-vol-chart');
            } catch (error) {
                console.error('Error updating Realised Volatility chart:', error);
                document.getElementById('realised-vol-error').textContent = `Error rendering chart: ${error.message}`;
                document.getElementById('realised-vol-error').style.display = 'block';
            }
        }

        function prepareSurfaceData(filteredData, zKey) {
            try {
                const datasetDate = new Date(document.getElementById('date-select').value.replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3'));
                const moneynessMin = parseFloat(document.getElementById('moneyness-min-slider').value);
                const moneynessMax = parseFloat(document.getElementById('moneyness-max-slider').value);
                const expiryTMin = parseFloat(document.getElementById('expiry-t-min-slider').value);
                const expiryTMax = parseFloat(document.getElementById('expiry-t-max-slider').value);
                const tFilteredData = filteredData.filter(item => {
                    const t = calculateTimeToExpiry(item.Expiry, datasetDate);
                    const moneyness = item.Moneyness;
                    return t !== null && Number.isFinite(t) && t >= expiryTMin && t <= expiryTMax && moneyness >= moneynessMin && moneyness <= moneynessMax;
                });
                const moneynessValues = [...new Set(tFilteredData.map(item => Math.round(item.Moneyness * 10) * 0.1))]
                    .filter(val => !isNaN(val) && val >= moneynessMin && val <= moneynessMax)
                    .sort((a, b) => a - b);
                const expiryValues = [...new Set(tFilteredData.map(item => normalizeDate(item.Expiry)))]
                    .filter(val => {
                        const t = calculateTimeToExpiry(val, datasetDate);
                        return t !== null && t >= expiryTMin && t <= expiryTMax;
                    })
                    .sort((a, b) => new Date(a) - new Date(b));
                const zData = [];
                moneynessValues.forEach(() => zData.push(new Array(expiryValues.length).fill(null)));
                tFilteredData.forEach(item => {
                    const moneynessIndex = moneynessValues.indexOf(Math.round(item.Moneyness * 10) * 0.1);
                    const expiryIndex = expiryValues.indexOf(normalizeDate(item.Expiry));
                    if (moneynessIndex >= 0 && expiryIndex >= 0 && Number.isFinite(item[zKey])) {
                        zData[moneynessIndex][expiryIndex] = item[zKey] * 100;
                    }
                });
                const expiryTimes = expiryValues.map(date => calculateTimeToExpiry(date, datasetDate));
                interpolateAlongExpiry(zData, expiryTimes);
                interpolateAlongMoneyness(zData, moneynessValues);
                const zValues = zData.flat().filter(v => Number.isFinite(v));
                const minZ = zValues.length > 0 ? Math.min(...zValues) : 0;
                const maxZ = zValues.length > 0 ? Math.max(...zValues) : 0;
                return {
                    x: expiryValues,
                    y: moneynessValues.map(val => val * 100),
                    z: zData,
                    minZ: minZ,
                    maxZ: maxZ
                };
            } catch (error) {
                console.error('Error preparing surface data:', error);
                return { x: [], y: [], z: [], minZ: 0, maxZ: 0 };
            }
        }

        function calculateTimeToExpiry(expiryDate, referenceDate) {
            try {
                const expiry = new Date(expiryDate);
                const ref = new Date(referenceDate);
                const diffMs = expiry - ref;
                return diffMs / (365 * 24 * 60 * 60 * 1000);
            } catch (error) {
                console.error('Error calculating time to expiry:', error);
                return null;
            }
        }

        function interpolateAlongExpiry(zData, expiryTimes) {
            for (let y = 0; y < zData.length; y++) {
                const row = zData[y];
                const known = [];
                for (let x = 0; x < row.length; x++) {
                    if (row[x] !== null && Number.isFinite(row[x])) {
                        known.push({ t: expiryTimes[x], val: row[x], idx: x });
                    }
                }
                if (known.length < 2) continue;
                known.sort((a, b) => a.t - b.t);
                for (let i = 0; i < known.length - 1; i++) {
                    const start = known[i];
                    const end = known[i + 1];
                    const dt = end.t - start.t;
                    if (dt <= 0) continue;
                    for (let idx = start.idx + 1; idx < end.idx; idx++) {
                        const curr_t = expiryTimes[idx];
                        const frac = (curr_t - start.t) / dt;
                        row[idx] = start.val + frac * (end.val - start.val);
                    }
                }
            }
        }
        
        function interpolateAlongMoneyness(zData, moneynessValues) {
            for (let x = 0; x < zData[0].length; x++) {
                const col = zData.map(row => row[x]);
                const known = [];
                for (let y = 0; y < col.length; y++) {
                    if (col[y] !== null && Number.isFinite(col[y])) {
                        known.push({ m: moneynessValues[y], val: col[y], idx: y });
                    }
                }
                if (known.length < 2) continue;
                known.sort((a, b) => a.m - b.m);
                for (let i = 0; i < known.length - 1; i++) {
                    const start = known[i];
                    const end = known[i + 1];
                    const dm = end.m - start.m;
                    if (dm <= 0) continue;
                    for (let idx = start.idx + 1; idx < end.idx; idx++) {
                        const curr_m = moneynessValues[idx];
                        const frac = (curr_m - start.m) / dm;
                        zData[idx][x] = start.val + frac * (end.val - start.val);
                    }
                }
            }
        }
        
        function updateCallVolSurface() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const filteredData = data.filter(item => item.Ticker === selectedTicker && item.Type === 'Call');
                const errorDiv = document.getElementById('surface-error');
                errorDiv.style.display = 'none';
                console.log('Updating Call Volatility Surface for ticker:', selectedTicker, 'Filtered data size:', filteredData.length);
                const surfaceData = prepareSurfaceData(filteredData, 'IV_mid');
                console.log('Surface data:', {
                    x: surfaceData.x.slice(0, 5),
                    y: surfaceData.y.slice(0, 5),
                    z: surfaceData.z.map(row => row.slice(0, 5)),
                    minZ: surfaceData.minZ,
                    maxZ: surfaceData.maxZ
                });
                if (!surfaceData.x.length || !surfaceData.y.length || !surfaceData.z.length) {
                    Plotly.purge('call-vol-surface');
                    errorDiv.textContent = 'No data for volatility surface';
                    errorDiv.style.display = 'block';
                    return;
                }
                const minZ = surfaceData.minZ;
                const maxZ = surfaceData.maxZ;
                const colorscale = [
                    [0, '#440154'],
                    [0.1, '#482878'],
                    [0.2, '#3e4989'],
                    [0.3, '#31688e'],
                    [0.4, '#26828e'],
                    [0.5, '#1f9e89'],
                    [0.6, '#35b779'],
                    [0.7, '#6ece58'],
                    [0.8, '#b5de2b'],
                    [0.9, '#fde725']
                ];
                const numTicks = 6;
                const tickInterval = (maxZ - minZ) / (numTicks - 1);
                const tickvals = [];
                const ticktext = [];
                for (let i = 0; i < numTicks; i++) {
                    const val = minZ + i * tickInterval;
                    tickvals.push(val);
                    ticktext.push(val.toFixed(0));
                }
                const plotData = [{
                    x: surfaceData.x,
                    y: surfaceData.y,
                    z: surfaceData.z,
                    type: 'surface',
                    colorscale: 'Viridis',
                    cmin: minZ,
                    cmax: maxZ,
                    showscale: true,
                    colorbar: {
                        title: 'Volatility (%)',
                        titleside: 'right',
                        titlefont: { color: '#FFFFFF' },
                        tickfont: { color: '#FFFFFF' },
                        tickvals: tickvals,
                        ticktext: ticktext
                    }
                }];
                const layout = {
                    title: { text: 'Call Implied Volatility Surface (%)', font: { color: '#FFFFFF', size: 16 }, y: 0.95 },
                    scene: {
                        xaxis: { title: 'Expiry', type: 'date', tickformat: '%Y-%m-%d', color: '#FFFFFF', autorange: true },
                        yaxis: { title: 'Moneyness (%)', color: '#FFFFFF', autorange: true },
                        zaxis: { title: 'Volatility (%)', color: '#FFFFFF', range: [minZ, maxZ], autorange: false },
                        aspectmode: 'auto',
                        bgcolor: '#1A1A2E'
                    },
                    margin: { l: 0, r: 0, b: 0, t: 50 },
                    width: '100%',
                    height: '100%',
                    paper_bgcolor: '#1A1A2E',
                    plot_bgcolor: '#1A1A2E'
                };
                Plotly.newPlot('call-vol-surface', plotData, layout);
                document.getElementById('moneyness-value').textContent = `${document.getElementById('moneyness-slider').dataset.min} - ${document.getElementById('moneyness-slider').dataset.max}`;
                document.getElementById('expiry-t-value').textContent = `${document.getElementById('expiry-t-slider').dataset.min} - ${document.getElementById('expiry-t-slider').dataset.max}`;
                const moneynessSlider = document.getElementById('moneyness-slider');
                const expiryTSlider = document.getElementById('expiry-t-slider');
                [moneynessSlider, expiryTSlider].forEach(slider => {
                    slider.addEventListener('input', () => {
                        updateCallVolSurface();
                        document.getElementById(slider.id.replace('-slider', '-value')).textContent = `${slider.dataset.min} - ${slider.dataset.max}`;
                    });
                });
            } catch (error) {
                console.error('Error updating Call Volatility Surface:', error);
                Plotly.purge('call-vol-surface');
                document.getElementById('surface-error').textContent = `Error rendering volatility surface: ${error.message}`;
                document.getElementById('surface-error').style.display = 'block';
            }
        }
        
        function updateHistoricChart() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const historyLength = document.getElementById('history-select').value;
                const errorDiv = document.getElementById('historic-error');
                errorDiv.style.display = 'none';
                console.log('Updating Historic chart for ticker:', selectedTicker, 'History length:', historyLength, 'historicData columns:', historicData.length > 0 ? Object.keys(historicData[0]) : []);
                if (!historicData || historicData.length === 0) {
                    if (historicChart) historicChart.destroy();
                    errorDiv.textContent = 'No historic data available';
                    errorDiv.style.display = 'block';
                    return;
                }
                let filteredHistoric = historicData.filter(item => item.Ticker === selectedTicker && item.Date && Number.isFinite(item.Close));
                if (filteredHistoric.length === 0) {
                    if (historicChart) historicChart.destroy();
                    errorDiv.textContent = 'No valid historic data for selected ticker';
                    errorDiv.style.display = 'block';
                    return;
                }
                filteredHistoric.sort((a, b) => new Date(a.Date) - new Date(b.Date));
                const fromDate = calculateDateRange(historyLength);
                const minHistoricDate = new Date(Math.min(...filteredHistoric.map(item => new Date(item.Date))));
                const maxHistoricDate = new Date(Math.max(...filteredHistoric.map(item => new Date(item.Date))));
                if (fromDate) {
                    filteredHistoric = filteredHistoric.filter(item => new Date(item.Date) >= fromDate);
                }
                const dates = filteredHistoric.map(item => new Date(item.Date));
                const datasets = [
                    {
                        label: 'Stock Price',
                        data: filteredHistoric.map((item, i) => ({ x: dates[i], y: parseFloat(item.Close) })),
                        borderColor: '#FFFF00', // Yellow
                        backgroundColor: '#FFFF00',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        yAxisID: 'y'
                    }
                ];
                const annotations = eventsData
                    .filter(event => {
                        if (!event.Start_Date || !event.End_Date) return false;
                        const startDate = new Date(event.Start_Date);
                        const endDate = new Date(event.End_Date);
                        if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) return false;
                        if (!(event.Ticker === 'ALL' || event.Ticker === selectedTicker)) return false;
                        if (startDate > maxHistoricDate || endDate < minHistoricDate) return false;
                        if (fromDate && endDate < fromDate) return false;
                        return true;
                    })
                    .map((event, index) => ({
                        type: 'box',
                        xMin: new Date(Math.max(new Date(event.Start_Date), fromDate || minHistoricDate)),
                        xMax: new Date(Math.min(new Date(event.End_Date), maxHistoricDate)),
                        yMin: 'y',
                        yMax: 'y',
                        backgroundColor: event.Impact === 'dip' ? 'rgba(248, 113, 113, 0.2)' : 'rgba(74, 222, 128, 0.2)',
                        borderColor: event.Impact === 'dip' ? 'rgba(248, 113, 113, 0.5)' : 'rgba(74, 222, 128, 0.5)',
                        borderWidth: 1,
                        label: {
                            content: event.Event || 'Unknown Event',
                            display: true,
                            position: 'center',
                            color: '#FFFFFF',
                            font: { size: 12 },
                            rotation: 90
                        }
                    }));
                if (historicChart) historicChart.destroy();
                const canvas = document.getElementById('historic-price-chart');
                if (!canvas.getContext('2d')) {
                    throw new Error('Canvas context not available for historic-price-chart');
                }
                historicChart = new Chart(canvas.getContext('2d'), {
                    type: 'line',
                    data: { datasets },
                    options: {
                        plugins: {
                            legend: { labels: { color: '#FFFFFF' } },
                            annotation: { annotations }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: { unit: 'month' },
                                title: { display: true, text: 'Date', color: '#FFFFFF' },
                                grid: { color: '#A855F7' },
                                ticks: { color: '#FFFFFF' }
                            },
                            y: {
                                title: { display: true, text: 'Stock Price ($)', color: '#FFFFFF' },
                                beginAtZero: false,
                                grid: { color: '#A855F7' },
                                ticks: { color: '#FFFFFF' }
                            }
                        },
                        backgroundColor: '#1A1A2E'
                    }
                });
                document.getElementById('historic-error').style.display = 'none';
                createStatsTable(historicChart, 'historic-price-chart');
            } catch (error) {
                console.error('Error updating Historic chart:', error);
                document.getElementById('historic-error').textContent = `Error rendering historic chart: ${error.message}`;
                document.getElementById('historic-error').style.display = 'block';
            }
        }
        
        function updateVolumeChart() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const uniqueTickers = [...new Set(rankingData.map(item => item.Ticker))].filter(val => val).sort();
                const volumes = uniqueTickers.map(ticker => {
                    const tickerData = rankingData.find(item => item.Ticker === ticker);
                    return tickerData && Number.isFinite(tickerData['Volume']) ? parseInt(tickerData['Volume']) : 0;
                });
                const backgroundColors = uniqueTickers.map(ticker => ticker === selectedTicker ? '#FFFF00' : '#00BFFF');
                if (volumeChart) volumeChart.destroy();
                const canvas = document.getElementById('volume-chart');
                if (!canvas.getContext('2d')) {
                    throw new Error('Canvas context not available for volume-chart');
                }
                volumeChart = new Chart(canvas.getContext('2d'), {
                    type: 'bar',
                    data: {
                        labels: uniqueTickers,
                        datasets: [{
                            label: 'Total Volume',
                            data: volumes,
                            backgroundColor: backgroundColors,
                            borderColor: backgroundColors,
                            borderWidth: 1
                        }]
                    },
                    options: {
                        plugins: { legend: { labels: { color: '#FFFFFF' } } },
                        scales: {
                            x: { title: { display: true, text: 'Ticker', color: '#FFFFFF' }, grid: { color: '#FFFFFF33' }, ticks: { color: '#FFFFFF' } },
                            y: {
                                title: { display: true, text: 'Volume', color: '#FFFFFF' },
                                beginAtZero: true,
                                grid: { color: '#FFFFFF33' },
                                ticks: {
                                    color: '#FFFFFF',
                                    callback: value => Number(value).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 })
                                }
                            }
                        },
                        backgroundColor: '#1C2526'
                    }
                });
                console.log('Volume chart updated for tickers:', uniqueTickers);
            } catch (error) {
                console.error('Error updating volume chart:', error);
                document.getElementById('historic-error').textContent = `Error rendering volume chart: ${error.message}`;
                document.getElementById('historic-error').style.display = 'block';
            }
        }
        
        function updateOpenInterestChart() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const uniqueTickers = [...new Set(rankingData.map(item => item.Ticker))].filter(val => val).sort();
                const openInterests = uniqueTickers.map(ticker => {
                    const tickerData = rankingData.find(item => item.Ticker === ticker);
                    return tickerData && Number.isFinite(tickerData['Open Interest']) ? parseInt(tickerData['Open Interest']) : 0;
                });
                const backgroundColors = uniqueTickers.map(ticker => ticker === selectedTicker ? '#FFFF00' : '#00BFFF');
                if (openInterestChart) openInterestChart.destroy();
                const canvas = document.getElementById('open-interest-chart');
                if (!canvas.getContext('2d')) {
                    throw new Error('Canvas context not available for open-interest-chart');
                }
                openInterestChart = new Chart(canvas.getContext('2d'), {
                    type: 'bar',
                    data: {
                        labels: uniqueTickers,
                        datasets: [{
                            label: 'Total Open Interest',
                            data: openInterests,
                            backgroundColor: backgroundColors,
                            borderColor: backgroundColors,
                            borderWidth: 1
                        }]
                    },
                    options: {
                        plugins: { legend: { labels: { color: '#FFFFFF' } } },
                        scales: {
                            x: { title: { display: true, text: 'Ticker', color: '#FFFFFF' }, grid: { color: '#FFFFFF33' }, ticks: { color: '#FFFFFF' } },
                            y: {
                                title: { display: true, text: 'Open Interest', color: '#FFFFFF' },
                                beginAtZero: true,
                                grid: { color: '#FFFFFF33' },
                                ticks: {
                                    color: '#FFFFFF',
                                    callback: value => Number(value).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 })
                                }
                            }
                        },
                        backgroundColor: '#1C2526'
                    }
                });
                console.log('Open Interest chart updated for tickers:', uniqueTickers);
            } catch (error) {
                console.error('Error updating open interest chart:', error);
                document.getElementById('historic-error').textContent = `Error rendering open interest chart: ${error.message}`;
                document.getElementById('historic-error').style.display = 'block';
            }
        }
        
        function aggregateDataByX(data, xKey, yKey) {
            try {
                const grouped = data.reduce((acc, item) => {
                    const xValue = xKey === 'Expiry' ? new Date(item[xKey]).toISOString() : item[xKey];
                    const yValue = item[yKey];
                    if (!acc[xValue]) acc[xValue] = { sum: 0, count: 0 };
                    if (!isNaN(yValue) && yValue !== null) {
                        acc[xValue].sum += yValue;
                        acc[xValue].count += 1;
                    }
                    return acc;
                }, {});
                return Object.keys(grouped).map(x => {
                    const group = grouped[x];
                    if (group.count > 0) {
                        return {
                            x: xKey === 'Expiry' ? new Date(x) : parseFloat(x) * (xKey === 'Moneyness' || xKey === 'Delta' ? 100 : 1),
                            y: (group.sum / group.count) * 100
                        };
                    }
                }).filter(point => point).sort((a, b) => a.x - b.x);
            } catch (error) {
                console.error('Error aggregating data:', error);
                return [];
            }
        }
        
        function createStatsTable(chart, canvasId) {
            try {
                const container = document.getElementById(canvasId).parentNode;
                let existingTable = container.querySelector('.stats-table');
                if (existingTable) existingTable.remove();
                const table = document.createElement('table');
                table.className = 'stats-table';
                table.style.display = canvasId === 'historic-price-chart' ? 'table' : (statsTablesVisible ? 'table' : 'none');
                const thead = table.createTHead();
                const headerRow = thead.insertRow();
                ['Label', 'Last', 'Min', 'Max', 'Mean', 'SD', 'SD Change'].forEach(text => {
                    const th = document.createElement('th');
                    th.textContent = text;
                    headerRow.appendChild(th);
                });
                const tbody = table.createTBody();
                chart.data.datasets.forEach(dataset => {
                    if (!dataset.data.length) return;
                    const ys = dataset.data.map(point => point.y).filter(y => !isNaN(y));
                    if (!ys.length) return;
                    const last = ys[ys.length - 1];
                    const min = Math.min(...ys);
                    const max = Math.max(...ys);
                    const mean = ys.reduce((a, b) => a + b, 0) / ys.length;
                    const sd = Math.sqrt(ys.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / (ys.length - 1)) || 0;
                    const sdChanges = ys.slice(1).map((y, i) => y - ys[i]);
                    const sdChange = sdChanges.length > 0 ? Math.sqrt(sdChanges.reduce((a, b) => a + Math.pow(b, 2), 0) / (sdChanges.length - 1)) || 0 : 0;
                    const row = tbody.insertRow();
                    const labelTd = row.insertCell();
                    const swatch = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    swatch.setAttribute('width', '20');
                    swatch.setAttribute('height', '10');
                    swatch.setAttribute('class', 'line-swatch');
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', '0');
                    line.setAttribute('y1', '5');
                    line.setAttribute('x2', '20');
                    line.setAttribute('y2', '5');
                    line.setAttribute('stroke', dataset.borderColor);
                    line.setAttribute('stroke-width', '2');
                    if (dataset.borderDash && dataset.borderDash.length > 0) {
                        line.setAttribute('stroke-dasharray', dataset.borderDash.join(' '));
                    }
                    swatch.appendChild(line);
                    labelTd.appendChild(swatch);
                    labelTd.appendChild(document.createTextNode(` ${dataset.label}`));
                    row.insertCell().textContent = last.toFixed(2);
                    row.insertCell().textContent = min.toFixed(2);
                    row.insertCell().textContent = max.toFixed(2);
                    row.insertCell().textContent = mean.toFixed(2);
                    row.insertCell().textContent = sd.toFixed(2);
                    row.insertCell().textContent = sdChange.toFixed(2);
                });
                container.appendChild(table);
            } catch (error) {
                console.error('Error creating stats table:', error);
                document.getElementById('historic-error').textContent = `Error creating stats table: ${error.message}`;
                document.getElementById('historic-error').style.display = 'block';
            }
        }
        
        function updateSection(sectionId) {
            try {
                console.log('Updating section:', sectionId);
                const sections = ['overview', 'volatility', 'ranking', 'data-table'];
                sections.forEach(id => {
                    const element = document.getElementById(id);
                    if (id === sectionId) {
                        element.style.display = id === 'overview' ? 'flex' : id === 'volatility' ? 'grid' : 'block';
                    } else {
                        element.style.display = 'none';
                    }
                });
                updateCharts();
            } catch (error) {
                console.error('Error updating section:', error);
                document.getElementById('historic-error').textContent = `Error navigating to section: ${error.message}`;
                document.getElementById('historic-error').style.display = 'block';
            }
        }
        
        function updateCharts() {
            try {
                console.log('Updating all charts and tables');
                updateMoneynessVsIV();
                updateExpiryVsIV();
                updateSkewVsExpiry();
                updateRealisedVolChart();
                updateCallVolSurface();
                updateSkewTable();
                updateSummaryTable();
                updateVolumeChart();
                updateOpenInterestChart();
                updateHistoricChart();
                updateRawDataTable();
            } catch (error) {
                console.error('Error updating charts:', error);
                document.getElementById('historic-error').textContent = `Error updating charts: ${error.message}`;
                document.getElementById('historic-error').style.display = 'block';
            }
        }
        
        function addKeyboardNavigation() {
            try {
                const chartConfigs = [
                    { canvasId: 'moneyness-vs-iv-chart', selectId: 'expiry-select' },
                    { canvasId: 'expiry-vs-iv-chart', selectId: 'moneyness-select' },
                    { canvasId: 'skew-vs-expiry-chart', selectId: null },
                    { canvasId: 'realised-vol-chart', selectId: null },
                    { canvasId: 'volume-chart', selectId: 'ticker-search' },
                    { canvasId: 'open-interest-chart', selectId: 'ticker-search' },
                    { canvasId: 'historic-price-chart', selectId: 'history-select' }
                ];
                chartConfigs.forEach(config => {
                    const canvas = document.getElementById(config.canvasId);
                    const select = config.selectId ? document.getElementById(config.selectId) : null;
                    if (select) {
                        canvas.addEventListener('keydown', (event) => {
                            if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
                                event.preventDefault();
                                let newIndex = select.selectedIndex + (event.key === 'ArrowLeft' ? -1 : 1);
                                if (newIndex < 0) newIndex = select.options.length - 1;
                                if (newIndex >= select.options.length) newIndex = 0;
                                select.selectedIndex = newIndex;
                                select.dispatchEvent(new Event('change', { bubbles: true }));
                            }
                        });
                    }
                });
                const expirySelect = document.getElementById('expiry-select');
                document.getElementById('moneyness-select').addEventListener('change', () => {
                    console.log('Moneyness select changed to:', document.getElementById('moneyness-select').value);
                    updateCharts();
                });
                document.getElementById('history-select').addEventListener('change', () => {
                    console.log('History length changed to:', document.getElementById('history-select').value);
                    updateHistoricChart();
                });
                document.getElementById('source-select').addEventListener('change', () => {
                    console.log('Data source changed to:', document.getElementById('source-select').value);
                    const dateSelect = document.getElementById('date-select');
                    const timeSelect = document.getElementById('time-select');
                    loadData(dateSelect.value + '_' + timeSelect.value);
                });
                expirySelect.addEventListener('change', () => {
                    console.log('Expiry select changed to:', expirySelect.value);
                    updateCharts();
                });
            } catch (error) {
                console.error('Error adding keyboard navigation:', error);
                document.getElementById('historic-error').textContent = `Error setting up keyboard navigation: ${error.message}`;
                document.getElementById('historic-error').style.display = 'block';
            }
        }
        
        function updateTimeOptions(selectedDate, dates) {
            try {
                const timeSelect = document.getElementById('time-select');
                timeSelect.innerHTML = '';
                const formattedSelectedDate = selectedDate.replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3');
                const availableTimes = dates
                    .filter(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$1-$2-$3') === formattedSelectedDate)
                    .map(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$4:$5'))
                    .sort();
                const uniqueTimes = [...new Set(availableTimes)];
                uniqueTimes.forEach(timePart => {
                    const option = document.createElement('option');
                    option.value = timePart.replace(':', '');
                    option.textContent = timePart;
                    timeSelect.appendChild(option);
                });
                if (timeSelect.options.length > 0) {
                    timeSelect.value = timeSelect.options[0].value;
                    timeSelect.dispatchEvent(new Event('change', { bubbles: true }));
                } else {
                    console.warn('No times available for selected date:', formattedSelectedDate);
                    document.getElementById('historic-error').textContent = 'No times available for selected date';
                    document.getElementById('historic-error').style.display = 'block';
                }
                console.log('Time options updated:', uniqueTimes);
            } catch (error) {
                console.error('Error updating time options:', error);
                document.getElementById('historic-error').textContent = `Error updating time options: ${error.message}`;
                document.getElementById('historic-error').style.display = 'block';
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            try {
                if (typeof Chart === 'undefined' || typeof Plotly === 'undefined' || typeof Papa === 'undefined') {
                    console.error('Required libraries (Chart.js, Plotly, or PapaParse) not loaded');
                    document.getElementById('historic-error').textContent = 'Failed to load required libraries';
                    document.getElementById('historic-error').style.display = 'block';
                    return;
                }
                const dateSelect = document.getElementById('date-select');
                const timeSelect = document.getElementById('time-select');
                const tickerSearch = document.getElementById('ticker-search');
                const sourceSelect = document.getElementById('source-select');
                const validateTimestamp = async (timestamp) => {
                    const source = sourceSelect.value;
                    const prefix = source === 'yfinance' ? '_yfinance' : '';
                    try {
                        const response = await fetch(`data/${timestamp}/ranking/ranking${prefix}.csv?v=${Date.now()}`, { method: 'HEAD' });
                        return response.ok ? timestamp : null;
                    } catch {
                        return null;
                    }
                };
                const getLatestValidTimestamp = async (dates) => {
                    const timestamps = dates.sort((a, b) => b.localeCompare(a));
                    for (const ts of timestamps) {
                        if (await validateTimestamp(ts)) return ts;
                    }
                    console.warn('No valid timestamps found, using fallback');
                    return '20250827_2136';
                };
                fetch('data/dates.json?v=' + Date.now())
                    .then(response => {
                        if (!response.ok) throw new Error('Failed to load dates.json');
                        return response.json();
                    })
                    .then(async dates => {
                        const uniqueDates = [...new Set(dates.map(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$1-$2-$3')))].sort((a, b) => b.localeCompare(a));
                        dateSelect.innerHTML = '';
                        uniqueDates.forEach(datePart => {
                            const option = document.createElement('option');
                            option.value = datePart.replace(/-/g, '');
                            option.textContent = datePart;
                            dateSelect.appendChild(option);
                        });
                        const loadInitialData = async () => {
                            let timestamp = await getLatestValidTimestamp(dates);
                            if (dateSelect.options.length > 0) {
                                dateSelect.value = timestamp.slice(0, 8);
                                await updateTimeOptions(dateSelect.value, dates);
                                timestamp = dateSelect.value + '_' + (timeSelect.options.length > 0 ? timeSelect.value : '2136');
                            }
                            console.log('Loading initial data with timestamp:', timestamp);
                            await loadData(timestamp);
                            updateDropdowns();
                            updateSection('overview');
                            console.log('Initial data and Overview loaded for timestamp:', timestamp);
                        };
                        await loadInitialData();
                        dateSelect.addEventListener('change', async (e) => {
                            console.log('Date select changed to:', e.target.value);
                            await updateTimeOptions(e.target.value, dates);
                            const timestamp = e.target.value + '_' + (timeSelect.options.length > 0 ? timeSelect.value : '2136');
                            if (await validateTimestamp(timestamp)) {
                                await loadData(timestamp);
                                updateDropdowns();
                                const currentSection = document.querySelector('.overview-container[style*="flex"], .volatility-grid[style*="grid"], .chart-container[style*="block"]');
                                const sectionId = currentSection ? currentSection.id : 'overview';
                                updateSection(sectionId);
                                console.log('Updated section after date change:', sectionId);
                            } else {
                                console.warn('Invalid timestamp:', timestamp);
                                document.getElementById('historic-error').textContent = 'Invalid date selected';
                                document.getElementById('historic-error').style.display = 'block';
                            }
                        });
                        timeSelect.addEventListener('change', async (e) => {
                            console.log('Time select changed to:', e.target.value);
                            const timestamp = dateSelect.value + '_' + e.target.value;
                            if (await validateTimestamp(timestamp)) {
                                await loadData(timestamp);
                                updateDropdowns();
                                const currentSection = document.querySelector('.overview-container[style*="flex"], .volatility-grid[style*="grid"], .chart-container[style*="block"]');
                                const sectionId = currentSection ? currentSection.id : 'overview';
                                updateSection(sectionId);
                                console.log('Updated section after time change:', sectionId);
                            } else {
                                console.warn('Invalid timestamp:', timestamp);
                                document.getElementById('historic-error').textContent = 'Invalid time selected';
                                document.getElementById('historic-error').style.display = 'block';
                            }
                        });
                        tickerSearch.addEventListener('input', debounce(async () => {
                            console.log('Ticker changed to:', tickerSearch.value);
                            document.getElementById('ticker-display').textContent = `Selected Ticker: ${tickerSearch.value.toUpperCase() || 'N/A'}`;
                            const timestamp = dateSelect.value + '_' + (timeSelect.options.length > 0 ? timeSelect.value : '2136');
                            if (await validateTimestamp(timestamp)) {
                                await loadData(timestamp);
                                updateDropdowns();
                                const currentSection = document.querySelector('.overview-container[style*="flex"], .volatility-grid[style*="grid"], .chart-container[style*="block"]');
                                const sectionId = currentSection ? currentSection.id : 'overview';
                                updateSection(sectionId);
                                console.log('Updated section after ticker change:', sectionId);
                            } else {
                                console.warn('Invalid timestamp:', timestamp);
                                document.getElementById('historic-error').textContent = 'Invalid data timestamp';
                                document.getElementById('historic-error').style.display = 'block';
                            }
                        }, 500));
                        sourceSelect.addEventListener('change', async () => {
                            console.log('Source changed to:', sourceSelect.value);
                            const timestamp = dateSelect.value + '_' + (timeSelect.options.length > 0 ? timeSelect.value : '2136');
                            if (await validateTimestamp(timestamp)) {
                                await loadData(timestamp);
                                updateDropdowns();
                                const currentSection = document.querySelector('.overview-container[style*="flex"], .volatility-grid[style*="grid"], .chart-container[style*="block"]');
                                const sectionId = currentSection ? currentSection.id : 'overview';
                                updateSection(sectionId);
                                console.log('Updated section after source change:', sectionId);
                            } else {
                                console.warn('Invalid timestamp:', timestamp);
                                document.getElementById('historic-error').textContent = 'Invalid data timestamp';
                                document.getElementById('historic-error').style.display = 'block';
                            }
                        });
                        const links = document.querySelectorAll('.sidebar a');
                        links.forEach(link => {
                            link.addEventListener('click', async (e) => {
                                e.preventDefault();
                                const targetId = link.getAttribute('href').substring(1);
                                console.log(`Navigating to section: ${targetId}`);
                                const timestamp = dateSelect.value + '_' + (timeSelect.options.length > 0 ? timeSelect.value : '2136');
                                if (await validateTimestamp(timestamp)) {
                                    await loadData(timestamp);
                                    updateDropdowns();
                                    updateSection(targetId);
                                } else {
                                    console.warn('Invalid timestamp on navigation:', timestamp);
                                    document.getElementById('historic-error').textContent = 'Invalid data timestamp';
                                    document.getElementById('historic-error').style.display = 'block';
                                }
                            });
                        });
                        const overviewContainer = document.getElementById('overview');
                        overviewContainer.style.display = 'flex';
                        document.getElementById('volatility').style.display = 'none';
                        document.getElementById('ranking').style.display = 'none';
                        document.getElementById('data-table').style.display = 'none';
                        console.log('Initial load: Showing Overview');
                        addKeyboardNavigation();
                    })
                    .catch(error => {
                        console.error('Error loading dates:', error);
                        document.getElementById('historic-error').textContent = `Failed to load date options: ${error.message}`;
                        document.getElementById('historic-error').style.display = 'block';
                    });
            } catch (error) {
                console.error('Error in DOMContentLoaded:', error);
                document.getElementById('historic-error').textContent = `Error initializing page: ${error.message}`;
                document.getElementById('historic-error').style.display = 'block';
            }
        });
    </script>
</body>
</html>
