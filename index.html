<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Stock Overview</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.2.1/dist/chartjs-plugin-annotation.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #1A1A2E; /* Off-black with purple tint */
            color: #FFFFFF;
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            font-size: 14px;
        }
        .sidebar {
            width: 250px;
            background: #25253D; /* Slightly lighter purple-gray */
            padding: 20px;
            border-right: 1px solid #A855F7; /* Purple */
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.5);
        }
        .sidebar a {
            color: #A855F7; /* Purple */
            text-decoration: none;
            display: block;
            padding: 12px 15px;
            font-size: 16px;
            transition: color 0.3s ease, background-color 0.3s ease;
            border-radius: 4px;
        }
        .sidebar a:hover {
            color: #FFFFFF;
            background-color: #D8B4FE; /* Light purple */
            text-decoration: none;
        }
        .sidebar select, .sidebar input {
            width: 100%;
            padding: 8px;
            background-color: #25253D; /* Slightly lighter purple-gray */
            color: #FFFFFF;
            border: 1px solid #A855F7; /* Purple */
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }
        .sidebar select:focus, .sidebar input:focus {
            border-color: #D8B4FE; /* Light purple */
            outline: none;
        }
        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #1A1A2E; /* Off-black with purple tint */
        }
        .chart-container {
            background-color: #25253D; /* Slightly lighter purple-gray */
            padding: 20px;
            border: 1px solid #A855F7; /* Purple */
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        .stats-table, .skew-table, .summary-table, .ranking-table, .raw-data-table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 15px;
            background-color: #25253D; /* Slightly lighter purple-gray */
        }
        .stats-table th, .stats-table td, .skew-table th, .skew-table td, .summary-table th, .summary-table td, .ranking-table th, .ranking-table td, .raw-data-table th, .raw-data-table td {
            border: 1px solid #A855F7; /* Purple */
            padding: 10px;
            text-align: left;
            color: #FFFFFF;
        }
        .stats-table th, .skew-table th, .summary-table th, .ranking-table th, .raw-data-table th {
            background-color: #373758; /* Darker purple-gray */
            font-weight: bold;
            cursor: pointer;
        }
        .stats-table th:hover, .raw-data-table th:hover, .ranking-table th:hover {
            background-color: #4B4B6F; /* Slightly lighter purple-gray */
        }
        canvas {
            max-width: 100%;
            border-radius: 4px;
            background-color: #25253D; /* Slightly lighter purple-gray */
        }
        .header {
            text-align: center;
            padding: 15px;
            background-color: #25253D; /* Slightly lighter purple-gray */
            border-bottom: 1px solid #A855F7; /* Purple */
            font-size: 22px;
            font-weight: bold;
            color: #FFFFFF;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        .ticker-display {
            font-size: 24px;
            margin-bottom: 15px;
            color: #FFFFFF;
            text-align: center;
            background-color: #25253D; /* Slightly lighter purple-gray */
            padding: 10px;
            border-radius: 4px;
        }
        .select-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .arrow-button, .toggle-button {
            background-color: #25253D; /* Slightly lighter purple-gray */
            color: #FFFFFF;
            border: 1px solid #A855F7; /* Purple */
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .arrow-button:hover, .toggle-button:hover {
            background-color: #D8B4FE; /* Light purple */
        }
        #historic-error {
            color: #F87171; /* Red for visibility */
            padding: 10px;
            text-align: center;
        }
        .line-swatch {
            display: inline-block;
            vertical-align: middle;
            margin-right: 5px;
        }
        .overview-container {
            display: flex;
            gap: 20px;
        }
        .overview-container .chart-container {
            flex: 1;
        }
        .volatility-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
        }
        .volatility-grid .chart-container {
            margin-bottom: 0;
        }
        #call-vol-surface {
            height: 400px;
            background-color: #25253D; /* Slightly lighter purple-gray */
        }
        .slider-container {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .slider-container input {
            width: 150px;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="header">Stock Overview</div>
        <div class="select-container">
            <label for="source-select">Source: </label>
            <select id="source-select">
                <option value="nasdaq">Nasdaq</option>
                <option value="yfinance" selected>yfinance</option>
            </select>
        </div>
        <select id="date-select"></select>
        <select id="time-select"></select>
        <input type="text" id="ticker-search" list="ticker-datalist" placeholder="Search Ticker...">
        <datalist id="ticker-datalist"></datalist>
        <button class="toggle-button" onclick="toggleStatsTables()">Show Stats Tables</button>
        <a href="#overview">Overview</a>
        <a href="#volatility">Volatility</a>
        <a href="#ranking">Ranking</a>
        <a href="#data-table">Data Table</a>
    </div>
    <div class="main-content">
        <div class="ticker-display" id="ticker-display">Selected Ticker: N/A</div>
        <div id="overview" class="overview-container">
            <div class="chart-container">
                <h2>Historic Stock Price with Realised Volatility</h2>
                <div class="select-container">
                    <label for="history-select">Select History Length: </label>
                    <button class="arrow-button" onclick="changeSelect('history-select', -1)">&#9664;</button>
                    <select id="history-select">
                        <option value="1m">1-month</option>
                        <option value="3m">3-month</option>
                        <option value="6m">6-month</option>
                        <option value="1y">1-year</option>
                        <option value="5y">5-year</option>
                        <option value="all" selected>All</option>
                    </select>
                    <button class="arrow-button" onclick="changeSelect('history-select', 1)">&#9654;</button>
                </div>
                <canvas id="historic-price-chart"></canvas>
                <div id="historic-error" style="display: none;">No historic data available</div>
            </div>
            <div class="chart-container">
                <h2>Summary</h2>
                <table id="summary-table" class="summary-table"></table>
                <table id="skew-table" class="skew-table"></table>
            </div>
        </div>
        <div id="volatility" class="volatility-grid" style="display: none;">
            <div class="chart-container">
                <h3>Moneyness vs. IV</h3>
                <div class="select-container">
                    <label for="expiry-select">Select Expiry: </label>
                    <button class="arrow-button" onclick="changeSelect('expiry-select', -1)">&#9664;</button>
                    <select id="expiry-select"></select>
                    <button class="arrow-button" onclick="changeSelect('expiry-select', 1)">&#9654;</button>
                </div>
                <canvas id="moneyness-vs-iv-chart"></canvas>
            </div>
            <div class="chart-container">
                <h3>Expiry vs. IV</h3>
                <div class="select-container">
                    <label for="moneyness-select">Select Moneyness: </label>
                    <button class="arrow-button" onclick="changeSelect('moneyness-select', -1)">&#9664;</button>
                    <select id="moneyness-select"></select>
                    <button class="arrow-button" onclick="changeSelect('moneyness-select', 1)">&#9654;</button>
                </div>
                <canvas id="expiry-vs-iv-chart"></canvas>
            </div>
            <div class="chart-container">
                <h3>Delta vs. IV</h3>
                <div class="select-container">
                    <label for="delta-expiry-select">Select Expiry: </label>
                    <button class="arrow-button" onclick="changeSelect('delta-expiry-select', -1)">&#9664;</button>
                    <select id="delta-expiry-select"></select>
                    <button class="arrow-button" onclick="changeSelect('delta-expiry-select', 1)">&#9654;</button>
                </div>
                <canvas id="delta-vs-iv-chart"></canvas>
            </div>
            <div class="chart-container">
                <h3>Call Volatility Surface</h3>
                <div id="call-vol-surface"></div>
                <div class="slider-container">
                    <label>Rotate X: <input type="range" id="rotate-x-slider" min="0" max="360" value="30"></label>
                    <label>Rotate Z: <input type="range" id="rotate-z-slider" min="0" max="360" value="30"></label>
                </div>
            </div>
        </div>
        <div id="ranking" class="chart-container" style="display: none;">
            <h2>Ticker Ranking</h2>
            <button class="toggle-button" onclick="toggleRankingTable()">Show Data</button>
            <table id="ranking-table" class="ranking-table" style="display: none;"></table>
            <canvas id="volume-chart"></canvas>
            <canvas id="open-interest-chart"></canvas>
        </div>
        <div id="data-table" class="chart-container" style="display: none;">
            <h2>Data Table</h2>
            <table id="raw-data-table" class="raw-data-table"></table>
        </div>
    </div>
    <script>
        let data = [];
        let historicData = [];
        let skewData = [];
        let slopeData = [];
        let eventsData = [];
        let rawData = [];
        let rankingData = [];
        let moneynessChart, expiryChart, deltaChart, historicChart, volumeChart, openInterestChart;
        let statsTablesVisible = false;
        let rankingTableVisible = false;

        function parseCSV(csvText) {
            try {
                const result = Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    dynamicTyping: true
                });
                return result.data;
            } catch (error) {
                console.error('Error parsing CSV:', error);
                return [];
            }
        }

        function normalizeDate(dateStr) {
            try {
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) throw new Error('Invalid date');
                return date.toLocaleDateString('en-CA');
            } catch (error) {
                console.error('Error normalizing date:', dateStr, error);
                return null;
            }
        }

        function calculateDateRange(historyLength) {
            try {
                const now = new Date();
                let fromDate = new Date();
                switch (historyLength) {
                    case '1m': fromDate.setMonth(now.getMonth() - 1); break;
                    case '3m': fromDate.setMonth(now.getMonth() - 3); break;
                    case '6m': fromDate.setMonth(now.getMonth() - 6); break;
                    case '1y': fromDate.setFullYear(now.getFullYear() - 1); break;
                    case '5y': fromDate.setFullYear(now.getFullYear() - 5); break;
                    case 'all': default: return null;
                }
                return fromDate;
            } catch (error) {
                console.error('Error calculating date range:', error);
                return null;
            }
        }

        function changeSelect(selectId, direction) {
            try {
                const select = document.getElementById(selectId);
                let newIndex = select.selectedIndex + direction;
                if (newIndex < 0) newIndex = select.options.length - 1;
                if (newIndex >= select.options.length) newIndex = 0;
                select.selectedIndex = newIndex;
                select.dispatchEvent(new Event('change', { bubbles: true }));
                console.log(`Changed ${selectId} to:`, select.value);
            } catch (error) {
                console.error('Error in changeSelect:', error);
            }
        }

        function toggleStatsTables() {
            try {
                statsTablesVisible = !statsTablesVisible;
                document.querySelectorAll('.stats-table:not(#historic-price-chart + .stats-table)').forEach(table => {
                    table.style.display = statsTablesVisible ? 'table' : 'none';
                });
                document.querySelector('.toggle-button:not(#ranking .toggle-button)').textContent = statsTablesVisible ? 'Hide Stats Tables' : 'Show Stats Tables';
                console.log(`Stats tables visibility set to: ${statsTablesVisible}`);
            } catch (error) {
                console.error('Error in toggleStatsTables:', error);
            }
        }

        function toggleRankingTable() {
            try {
                rankingTableVisible = !rankingTableVisible;
                const table = document.getElementById('ranking-table');
                table.style.display = rankingTableVisible ? 'table' : 'none';
                document.querySelector('#ranking .toggle-button').textContent = rankingTableVisible ? 'Hide Data' : 'Show Data';
                if (rankingTableVisible) updateRankingTable();
                console.log(`Ranking table visibility set to: ${rankingTableVisible}`);
            } catch (error) {
                console.error('Error in toggleRankingTable:', error);
            }
        }

        async function loadData(timestamp) {
            try {
                const source = document.getElementById('source-select').value;
                const prefix = source === 'yfinance' ? '_yfinance' : '';
                let selectedTicker = document.getElementById('ticker-search').value.toUpperCase() || 'MSTR';
                console.log(`Loading data for timestamp: ${timestamp}, source: ${source}, ticker: ${selectedTicker}`);

                const checkFileExists = async (url) => {
                    try {
                        const response = await fetch(url, { method: 'HEAD' });
                        return response.ok;
                    } catch {
                        return false;
                    }
                };

                const rankingExists = await checkFileExists(`data/${timestamp}/ranking/ranking${prefix}.csv`);
                if (!rankingExists) {
                    throw new Error(`Ranking file not found: data/${timestamp}/ranking/ranking${prefix}.csv`);
                }

                const rankingResponse = await fetch(`data/${timestamp}/ranking/ranking${prefix}.csv?v=${Date.now()}`);
                rankingData = parseCSV(await rankingResponse.text());
                console.log('Ranking data loaded, size:', rankingData.length, 'sample:', rankingData.slice(0, 5).map(item => ({ Ticker: item.Ticker, 'Realised Volatility 30d (%)': item['Realised Volatility 30d (%)'] })));

                const tickerDatalist = document.getElementById('ticker-datalist');
                tickerDatalist.innerHTML = '';
                const uniqueTickers = [...new Set(rankingData.map(item => item.Ticker))].filter(val => val).sort();
                uniqueTickers.forEach(val => {
                    const option = document.createElement('option');
                    option.value = val;
                    tickerDatalist.appendChild(option);
                });

                if (!uniqueTickers.includes(selectedTicker)) {
                    selectedTicker = uniqueTickers.includes('MSTR') ? 'MSTR' : uniqueTickers[0] || '';
                    document.getElementById('ticker-search').value = selectedTicker;
                }
                document.getElementById('ticker-display').textContent = `Selected Ticker: ${selectedTicker || 'N/A'}`;
                console.log('Ticker search populated, selected:', selectedTicker);

                if (!selectedTicker) {
                    console.warn('No ticker selected, clearing data');
                    data = [];
                    rawData = [];
                    skewData = [];
                    slopeData = [];
                    historicData = [];
                    eventsData = [];
                    return Promise.resolve();
                }

                const [processedExists, rawExists, skewExists, slopeExists, historicExists, eventsExists] = await Promise.all([
                    checkFileExists(`data/${timestamp}/processed${prefix}/processed${prefix}_${selectedTicker}.csv`),
                    checkFileExists(`data/${timestamp}/raw${prefix}/raw${prefix}_${selectedTicker}.csv`),
                    checkFileExists(`data/${timestamp}/skew_metrics${prefix}/skew_metrics${prefix}_${selectedTicker}.csv`),
                    checkFileExists(`data/${timestamp}/slope_metrics${prefix}/slope_metrics${prefix}_${selectedTicker}.csv`),
                    checkFileExists(`data/${timestamp}/historic/historic_${selectedTicker}.csv`),
                    checkFileExists(`data/Events.csv`)
                ]);

                console.log('File existence check:', { processedExists, rawExists, skewExists, slopeExists, historicExists, eventsExists });

                const fetchWithErrorHandling = async (url, array) => {
                    try {
                        const response = await fetch(`${url}?v=${Date.now()}`);
                        if (!response.ok) throw new Error(`Failed to fetch ${url}`);
                        array.splice(0, array.length, ...parseCSV(await response.text()));
                        console.log(`Data loaded from ${url}, size:`, array.length, 'sample:', array.slice(0, 5));
                    } catch (error) {
                        console.warn(`Error loading ${url}:`, error);
                        array.splice(0, array.length);
                    }
                };

                await Promise.all([
                    fetchWithErrorHandling(`data/${timestamp}/processed${prefix}/processed${prefix}_${selectedTicker}.csv`, data),
                    fetchWithErrorHandling(`data/${timestamp}/raw${prefix}/raw${prefix}_${selectedTicker}.csv`, rawData),
                    fetchWithErrorHandling(`data/${timestamp}/skew_metrics${prefix}/skew_metrics${prefix}_${selectedTicker}.csv`, skewData),
                    fetchWithErrorHandling(`data/${timestamp}/slope_metrics${prefix}/slope_metrics${prefix}_${selectedTicker}.csv`, slopeData),
                    fetchWithErrorHandling(`data/${timestamp}/historic/historic_${selectedTicker}.csv`, historicData).then(() => {
                        document.getElementById('historic-error').style.display = historicData.length ? 'none' : 'block';
                    }),
                    fetchWithErrorHandling(`data/Events.csv`, eventsData)
                ]);

                console.log('Data load complete:', {
                    dataSize: data.length,
                    historicDataSize: historicData.length,
                    skewDataSize: skewData.length,
                    slopeDataSize: slopeData.length,
                    rawDataSize: rawData.length,
                    eventsDataSize: eventsData.length
                });

                updateDropdowns();
                return Promise.resolve();
            } catch (error) {
                console.error('Error in loadData:', error);
                document.getElementById('ticker-search').value = '';
                document.getElementById('ticker-datalist').innerHTML = '';
                document.getElementById('ticker-display').textContent = 'Selected Ticker: N/A';
                data = [];
                rawData = [];
                skewData = [];
                slopeData = [];
                historicData = [];
                eventsData = [];
                rankingData = [];
                updateDropdowns();
                return Promise.resolve();
            }
        }
        
        function populateTickerSearch() {
            try {
                const tickerSearch = document.getElementById('ticker-search');
                const tickerDatalist = document.getElementById('ticker-datalist');
                tickerDatalist.innerHTML = '';
                const uniqueTickers = [...new Set(rankingData.map(item => item.Ticker))].filter(val => val).sort();
                uniqueTickers.forEach(val => {
                    const option = document.createElement('option');
                    option.value = val;
                    tickerDatalist.appendChild(option);
                });
                if (uniqueTickers.length > 0 && !tickerSearch.value) {
                    tickerSearch.value = uniqueTickers.includes('COIN') ? 'COIN' : uniqueTickers[0];
                    document.getElementById('ticker-display').textContent = `Selected Ticker: ${tickerSearch.value.toUpperCase()}`;
                }
                console.log('Ticker search populated, selected:', tickerSearch.value);
            } catch (error) {
                console.error('Error populating ticker search:', error);
            }
        }

        function updateDropdowns() {
            try {
                const tickerSearch = document.getElementById('ticker-search');
                const selectedTicker = tickerSearch.value.toUpperCase();
                const tickerData = data.filter(item => item.Ticker === selectedTicker);
                console.log('Updating dropdowns for ticker:', selectedTicker, 'Data size:', tickerData.length);

                const moneynessSelect = document.getElementById('moneyness-select');
                const expirySelect = document.getElementById('expiry-select');
                const deltaExpirySelect = document.getElementById('delta-expiry-select');

                const prevMoneyness = moneynessSelect.value;
                const prevExpiry = expirySelect.value;

                const uniqueRoundedMoneyness = [...new Set(tickerData.map(item => Math.round(item.Moneyness * 100 / 10) * 0.1))]
                    .filter(val => !isNaN(val)).sort((a, b) => a - b);
                moneynessSelect.innerHTML = '';
                uniqueRoundedMoneyness.forEach(val => {
                    const option = document.createElement('option');
                    option.value = val;
                    option.text = `${(val * 100).toFixed(0)}%`;
                    moneynessSelect.appendChild(option);
                });

                const targetMoneyness = 1.0;
                let closestMoneyness = uniqueRoundedMoneyness[0];
                if (uniqueRoundedMoneyness.length > 0) {
                    closestMoneyness = uniqueRoundedMoneyness.reduce((prev, curr) =>
                        Math.abs(curr - targetMoneyness) < Math.abs(prev - targetMoneyness) ? curr : prev
                    );
                }

                if (prevMoneyness && uniqueRoundedMoneyness.map(String).includes(prevMoneyness)) {
                    moneynessSelect.value = prevMoneyness;
                } else if (uniqueRoundedMoneyness.includes(targetMoneyness)) {
                    moneynessSelect.value = targetMoneyness.toString();
                } else if (uniqueRoundedMoneyness.length > 0) {
                    moneynessSelect.value = closestMoneyness.toString();
                }
                console.log('Moneyness dropdown updated, selected:', moneynessSelect.value);

                const uniqueExpiries = [...new Set(tickerData.map(item => item.Expiry))]
                    .filter(val => val).sort((a, b) => new Date(a) - new Date(b));
                expirySelect.innerHTML = '';
                deltaExpirySelect.innerHTML = '';
                uniqueExpiries.forEach(val => {
                    const option = document.createElement('option');
                    option.value = val;
                    option.text = new Date(val).toLocaleDateString('en-GB');
                    expirySelect.appendChild(option);
                    deltaExpirySelect.appendChild(option.cloneNode(true));
                });

                if (prevExpiry && uniqueExpiries.includes(prevExpiry)) {
                    expirySelect.value = prevExpiry;
                    deltaExpirySelect.value = prevExpiry;
                } else if (expirySelect.options.length > 0) {
                    expirySelect.value = expirySelect.options[0].value;
                    deltaExpirySelect.value = expirySelect.options[0].value;
                }
                console.log('Expiry dropdowns updated, selected:', expirySelect.value);
            } catch (error) {
                console.error('Error updating dropdowns:', error);
            }
        }

        function updateSkewTable() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const selectedExpiry = document.getElementById('expiry-select').value;
                const normalizedSelectedExpiry = normalizeDate(selectedExpiry);
                const table = document.getElementById('skew-table');
                table.innerHTML = '';
                const filteredSkewData = skewData.filter(item => item.Ticker === selectedTicker);
                console.log('Updating skew table for ticker:', selectedTicker, 'Expiry:', normalizedSelectedExpiry, 'Skew data size:', filteredSkewData.length);

                if (filteredSkewData.length === 0) {
                    const row = table.insertRow();
                    const cell = row.insertCell();
                    cell.textContent = 'No skew metrics available';
                    cell.colSpan = 6;
                    return;
                }

                const thead = document.createElement('thead');
                const headerRow = thead.insertRow();
                ['Expiry', 'Skew 25 Delta', 'Skew 75 Delta', 'Skew Call 25/75', 'Skew Put 25/75', 'ATM 12m/3m Ratio'].forEach(text => {
                    const th = document.createElement('th');
                    th.textContent = text;
                    headerRow.appendChild(th);
                });
                table.appendChild(thead);

                const tbody = document.createElement('tbody');
                const selectedRow = filteredSkewData.find(item => normalizeDate(item.Expiry) === normalizedSelectedExpiry);
                const row = tbody.insertRow();
                if (selectedRow) {
                    row.insertCell().textContent = new Date(selectedRow.Expiry).toLocaleDateString('en-GB');
                    row.insertCell().textContent = Number.isFinite(selectedRow.Skew_25_delta) ? selectedRow.Skew_25_delta.toFixed(4) : 'N/A';
                    row.insertCell().textContent = Number.isFinite(selectedRow.Skew_75_delta) ? selectedRow.Skew_75_delta.toFixed(4) : 'N/A';
                    row.insertCell().textContent = Number.isFinite(selectedRow.Skew_call_25_75) ? selectedRow.Skew_call_25_75.toFixed(4) : 'N/A';
                    row.insertCell().textContent = Number.isFinite(selectedRow.Skew_put_25_75) ? selectedRow.Skew_put_25_75.toFixed(4) : 'N/A';
                    row.insertCell().textContent = Number.isFinite(selectedRow.ATM_12m_3m_Ratio) ? selectedRow.ATM_12m_3m_Ratio.toFixed(4) : 'N/A';
                } else {
                    const cell = row.insertCell();
                    cell.textContent = 'No data for selected expiry';
                    cell.colSpan = 6;
                }
                table.appendChild(tbody);
            } catch (error) {
                console.error('Error updating skew table:', error);
            }
        }

        function updateSummaryTable() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const selectedExpiry = document.getElementById('expiry-select').value || '';
                let normalizedSelectedExpiry = null;
                if (selectedExpiry) {
                    try {
                        normalizedSelectedExpiry = normalizeDate(selectedExpiry);
                    } catch (e) {
                        console.warn('Invalid expiry date, proceeding without expiry:', e);
                    }
                }
                const table = document.getElementById('summary-table');
                table.innerHTML = '';
                console.log('Updating summary table for ticker:', selectedTicker, 'Expiry:', normalizedSelectedExpiry, 'rankingData sample:', rankingData.slice(0, 5).map(item => ({ Ticker: item.Ticker, 'Realised Volatility 30d (%)': item['Realised Volatility 30d (%)'] })));

                const thead = document.createElement('thead');
                const headerRow = thead.insertRow();
                ['Metric', 'Value', 'Metric', 'Value'].forEach(text => {
                    const th = document.createElement('th');
                    th.textContent = text;
                    headerRow.appendChild(th);
                });
                table.appendChild(thead);

                const tbody = document.createElement('tbody');
                const changeMetrics = [
                    'Close 1d (%)', 'Close 1w (%)', 'High 1d (%)', 'High 1w (%)', 'Low 1d (%)', 'Low 1w (%)',
                    'Realised Volatility 100d 1d (%)', 'Realised Volatility 100d 1w (%)', 'Volume 1d (%)',
                    'Volume 1w (%)', 'OI 1d (%)', 'OI 1w (%)', 'Weighted IV 1d (%)', 'Weighted IV 1w (%)'
                ];

                const metrics = [];
                const filteredRankingData = rankingData.find(item => item.Ticker === selectedTicker);
                if (filteredRankingData) {
                    metrics.push(
                        { name: 'Ticker', value: filteredRankingData['Ticker'] || 'N/A', key: 'Ticker' },
                        { name: 'Latest Close ($)', value: Number.isFinite(filteredRankingData['Latest Close']) ? filteredRankingData['Latest Close'].toFixed(2) : 'N/A', key: 'Latest Close' },
                        { name: 'Latest High ($)', value: Number.isFinite(filteredRankingData['Latest High']) ? filteredRankingData['Latest High'].toFixed(2) : 'N/A', key: 'Latest High' },
                        { name: 'Latest Low ($)', value: Number.isFinite(filteredRankingData['Latest Low']) ? filteredRankingData['Latest Low'].toFixed(2) : 'N/A', key: 'Latest Low' },
                        { name: 'Close 1d (%)', value: Number.isFinite(filteredRankingData['Close 1d (%)']) ? filteredRankingData['Close 1d (%)'].toFixed(2) : 'N/A', key: 'Close 1d (%)' },
                        { name: 'Close 1w (%)', value: Number.isFinite(filteredRankingData['Close 1w (%)']) ? filteredRankingData['Close 1w (%)'].toFixed(2) : 'N/A', key: 'Close 1w (%)' },
                        { name: 'High 1d (%)', value: Number.isFinite(filteredRankingData['High 1d (%)']) ? filteredRankingData['High 1d (%)'].toFixed(2) : 'N/A', key: 'High 1d (%)' },
                        { name: 'High 1w (%)', value: Number.isFinite(filteredRankingData['High 1w (%)']) ? filteredRankingData['High 1w (%)'].toFixed(2) : 'N/A', key: 'High 1w (%)' },
                        { name: 'Low 1d (%)', value: Number.isFinite(filteredRankingData['Low 1d (%)']) ? filteredRankingData['Low 1d (%)'].toFixed(2) : 'N/A', key: 'Low 1d (%)' },
                        { name: 'Low 1w (%)', value: Number.isFinite(filteredRankingData['Low 1w (%)']) ? filteredRankingData['Low 1w (%)'].toFixed(2) : 'N/A', key: 'Low 1w (%)' },
                        { name: 'Realised Volatility 30d (%)', value: Number.isFinite(filteredRankingData['Realised Volatility 30d (%)']) ? filteredRankingData['Realised Volatility 30d (%)'].toFixed(2) : 'N/A', key: 'Realised Volatility 30d (%)' },
                        { name: 'Realised Volatility 60d (%)', value: Number.isFinite(filteredRankingData['Realised Volatility 60d (%)']) ? filteredRankingData['Realised Volatility 60d (%)'].toFixed(2) : 'N/A', key: 'Realised Volatility 60d (%)' },
                        { name: 'Realised Volatility 100d (%)', value: Number.isFinite(filteredRankingData['Realised Volatility 100d (%)']) ? filteredRankingData['Realised Volatility 100d (%)'].toFixed(2) : 'N/A', key: 'Realised Volatility 100d (%)' },
                        { name: 'Realised Volatility 100d 1d (%)', value: Number.isFinite(filteredRankingData['Realised Volatility 100d 1d (%)']) ? filteredRankingData['Realised Volatility 100d 1d (%)'].toFixed(2) : 'N/A', key: 'Realised Volatility 100d 1d (%)' },
                        { name: 'Realised Volatility 100d 1w (%)', value: Number.isFinite(filteredRankingData['Realised Volatility 100d 1w (%)']) ? filteredRankingData['Realised Volatility 100d 1w (%)'].toFixed(2) : 'N/A', key: 'Realised Volatility 100d 1w (%)' },
                        { name: 'Min Realised Volatility 100d (1y)', value: Number.isFinite(filteredRankingData['Min Realised Volatility 100d (1y)']) ? filteredRankingData['Min Realised Volatility 100d (1y)'].toFixed(2) : 'N/A', key: 'Min Realised Volatility 100d (1y)' },
                        { name: 'Max Realised Volatility 100d (1y)', value: Number.isFinite(filteredRankingData['Max Realised Volatility 100d (1y)']) ? filteredRankingData['Max Realised Volatility 100d (1y)'].toFixed(2) : 'N/A', key: 'Max Realised Volatility 100d (1y)' },
                        { name: 'Mean Realised Volatility 100d (1y)', value: Number.isFinite(filteredRankingData['Mean Realised Volatility 100d (1y)']) ? filteredRankingData['Mean Realised Volatility 100d (1y)'].toFixed(2) : 'N/A', key: 'Mean Realised Volatility 100d (1y)' },
                        { name: 'Rvol 100d Percentile (%)', value: Number.isFinite(filteredRankingData['Rvol 100d Percentile (%)']) ? filteredRankingData['Rvol 100d Percentile (%)'].toFixed(2) : 'N/A', key: 'Rvol 100d Percentile (%)' },
                        { name: 'Rvol 100d Z-Score Percentile (%)', value: Number.isFinite(filteredRankingData['Rvol 100d Z-Score Percentile (%)']) ? filteredRankingData['Rvol 100d Z-Score Percentile (%)'].toFixed(2) : 'N/A', key: 'Rvol 100d Z-Score Percentile (%)' },
                        { name: 'Realised Volatility 180d (%)', value: Number.isFinite(filteredRankingData['Realised Volatility 180d (%)']) ? filteredRankingData['Realised Volatility 180d (%)'].toFixed(2) : 'N/A', key: 'Realised Volatility 180d (%)' },
                        { name: 'Realised Volatility 252d (%)', value: Number.isFinite(filteredRankingData['Realised Volatility 252d (%)']) ? filteredRankingData['Realised Volatility 252d (%)'].toFixed(2) : 'N/A', key: 'Realised Volatility 252d (%)' },
                        { name: 'Weighted IV (%)', value: Number.isFinite(filteredRankingData['Weighted IV (%)']) ? filteredRankingData['Weighted IV (%)'].toFixed(2) : 'N/A', key: 'Weighted IV (%)' },
                        { name: 'Weighted IV 1d (%)', value: Number.isFinite(filteredRankingData['Weighted IV 1d (%)']) ? filteredRankingData['Weighted IV 1d (%)'].toFixed(2) : 'N/A', key: 'Weighted IV 1d (%)' },
                        { name: 'Weighted IV 1w (%)', value: Number.isFinite(filteredRankingData['Weighted IV 1w (%)']) ? filteredRankingData['Weighted IV 1w (%)'].toFixed(2) : 'N/A', key: 'Weighted IV 1w (%)' },
                        { name: 'Rvol100d - Weighted IV', value: Number.isFinite(filteredRankingData['Rvol100d - Weighted IV']) ? filteredRankingData['Rvol100d - Weighted IV'].toFixed(2) : 'N/A', key: 'Rvol100d - Weighted IV' },
                        { name: 'Volume', value: Number.isFinite(filteredRankingData['Volume']) ? parseInt(filteredRankingData['Volume']).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 }) : 'N/A', key: 'Volume' },
                        { name: 'Volume 1d (%)', value: Number.isFinite(filteredRankingData['Volume 1d (%)']) ? filteredRankingData['Volume 1d (%)'].toFixed(2) : 'N/A', key: 'Volume 1d (%)' },
                        { name: 'Volume 1w (%)', value: Number.isFinite(filteredRankingData['Volume 1w (%)']) ? filteredRankingData['Volume 1w (%)'].toFixed(2) : 'N/A', key: 'Volume 1w (%)' },
                        { name: 'Open Interest', value: Number.isFinite(filteredRankingData['Open Interest']) ? parseInt(filteredRankingData['Open Interest']).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 }) : 'N/A', key: 'Open Interest' },
                        { name: 'OI 1d (%)', value: Number.isFinite(filteredRankingData['OI 1d (%)']) ? filteredRankingData['OI 1d (%)'].toFixed(2) : 'N/A', key: 'OI 1d (%)' },
                        { name: 'OI 1w (%)', value: Number.isFinite(filteredRankingData['OI 1w (%)']) ? filteredRankingData['OI 1w (%)'].toFixed(2) : 'N/A', key: 'OI 1w (%)' }
                    );
                } else {
                    metrics.push({ name: 'Ticker', value: selectedTicker || 'N/A', key: 'Ticker' });
                    console.warn('No ranking data for ticker:', selectedTicker);
                }

                let atmRatio = 'N/A';
                const filteredSkewData = skewData.filter(item => item.Ticker === selectedTicker);
                const selectedSkewRow = normalizedSelectedExpiry ? filteredSkewData.find(item => {
                    try {
                        return normalizeDate(item.Expiry) === normalizedSelectedExpiry;
                    } catch {
                        return false;
                    }
                }) : filteredSkewData[0];
                if (selectedSkewRow) {
                    atmRatio = Number.isFinite(selectedSkewRow.ATM_12m_3m_Ratio) ? selectedSkewRow.ATM_12m_3m_Ratio.toFixed(4) : 'N/A';
                }
                metrics.push({ name: 'ATM 12m/3m Ratio', value: atmRatio, key: 'ATM_12m_3m_Ratio' });

                const filteredSlopeData = slopeData.filter(item => item.Ticker === selectedTicker);
                if (filteredSlopeData.length > 0) {
                    filteredSlopeData.forEach(item => {
                        metrics.push({
                            name: `IV Slope 3m/12m (${item.Type} Delta ${Number.isFinite(item.Delta) ? item.Delta.toFixed(2) : 'N/A'})`,
                            value: Number.isFinite(item.IV_Slope_3m_12m) ? item.IV_Slope_3m_12m.toFixed(4) : 'N/A',
                            key: `IV_Slope_3m_12m_${item.Type}_${item.Delta}`
                        });
                    });
                } else {
                    metrics.push({ name: 'IV Slope 3m/12m', value: 'No slope metrics available', key: 'IV_Slope_3m_12m' });
                }

                for (let i = 0; i < metrics.length; i += 2) {
                    const row = tbody.insertRow();
                    const metric1Cell = row.insertCell();
                    metric1Cell.textContent = metrics[i].name;
                    const value1Cell = row.insertCell();
                    value1Cell.textContent = metrics[i].value;
                    if (changeMetrics.includes(metrics[i].name) && Number.isFinite(parseFloat(metrics[i].value))) {
                        const val = parseFloat(metrics[i].value);
                        value1Cell.style.color = val < 0 ? '#F87171' : val > 0 ? '#10B981' : '#FFFFFF';
                    }
                    const metric2Cell = row.insertCell();
                    metric2Cell.textContent = i + 1 < metrics.length ? metrics[i + 1].name : '';
                    const value2Cell = row.insertCell();
                    value2Cell.textContent = i + 1 < metrics.length ? metrics[i + 1].value : '';
                    if (i + 1 < metrics.length && changeMetrics.includes(metrics[i + 1].name) && Number.isFinite(parseFloat(metrics[i + 1].value))) {
                        const val = parseFloat(metrics[i + 1].value);
                        value2Cell.style.color = val < 0 ? '#F87171' : val > 0 ? '#10B981' : '#FFFFFF';
                    }
                }
                table.appendChild(tbody);
                console.log('Summary table updated with metrics:', metrics.map(m => ({ name: m.name, value: m.value })));
            } catch (error) {
                console.error('Error updating summary table:', error);
                const tbody = document.createElement('tbody');
                const row = tbody.insertRow();
                const cell = row.insertCell();
                cell.textContent = 'No data available';
                cell.colSpan = 4;
                table.appendChild(tbody);
            }
        }
        
        function updateRankingTable() {
            try {
                const table = document.getElementById('ranking-table');
                table.innerHTML = '';
                console.log('Updating ranking table with data:', rankingData);

                const columns = [
                    'Rank',
                    'Ticker',
                    'Latest Close',
                    'Latest High',
                    'Latest Low',
                    'Close 1d (%)',
                    'Close 1w (%)',
                    'High 1d (%)',
                    'High 1w (%)',
                    'Low 1d (%)',
                    'Low 1w (%)',
                    'Realised Volatility 30d (%)',
                    'Realised Volatility 60d (%)',
                    'Realised Volatility 100d (%)',
                    'Realised Volatility 100d 1d (%)',
                    'Realised Volatility 100d 1w (%)',
                    'Min Realised Volatility 100d (1y)',
                    'Max Realised Volatility 100d (1y)',
                    'Mean Realised Volatility 100d (1y)',
                    'Rvol 100d Percentile (%)',
                    'Rvol 100d Z-Score Percentile (%)',
                    'Realised Volatility 180d (%)',
                    'Realised Volatility 252d (%)',
                    'Weighted IV (%)',
                    'Weighted IV 1d (%)',
                    'Weighted IV 1w (%)',
                    'Rvol100d - Weighted IV',
                    'Volume',
                    'Volume 1d (%)',
                    'Volume 1w (%)',
                    'Open Interest',
                    'OI 1d (%)',
                    'OI 1w (%)'
                ];

                const sortedData = [...rankingData].sort((a, b) => {
                    const aValue = Number.isFinite(a['Open Interest']) ? parseInt(a['Open Interest']) : -Infinity;
                    const bValue = Number.isFinite(b['Open Interest']) ? parseInt(b['Open Interest']) : -Infinity;
                    return bValue - aValue;
                });
                sortedData.forEach((item, index) => {
                    item.CalculatedRank = index + 1;
                });

                console.log('Sample ranks:', sortedData.slice(0, 5).map(item => ({ Ticker: item.Ticker, Rank: item.CalculatedRank })));

                const thead = document.createElement('thead');
                const headerRow = thead.insertRow();
                columns.forEach((text, index) => {
                    const th = document.createElement('th');
                    th.textContent = text;
                    th.dataset.column = text;
                    th.dataset.order = 'desc';
                    th.addEventListener('click', () => sortTable('ranking-table', index));
                    headerRow.appendChild(th);
                });
                table.appendChild(thead);

                const tbody = document.createElement('tbody');
                sortedData.forEach(item => {
                    const row = tbody.insertRow();
                    columns.forEach(col => {
                        const cell = row.insertCell();
                        let value = col === 'Rank' ? item.CalculatedRank : item[col];
                        if (col === 'Rank') {
                            value = Number.isFinite(value) ? parseInt(value) : 'N/A';
                        } else if (col === 'Volume' || col === 'Open Interest') {
                            value = Number.isFinite(value) ? parseInt(value).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 }) : 'N/A';
                        } else if (Number.isFinite(value)) {
                            value = value.toFixed(2);
                        } else {
                            value = value === 'N/A' || value == null ? 'N/A' : value;
                        }
                        cell.textContent = value;
                        if ((col.includes('(%)') || col.includes('Rvol') || col.includes('Weighted IV') || col === 'Rvol100d - Weighted IV') && Number.isFinite(parseFloat(item[col]))) {
                            const val = parseFloat(item[col]);
                            cell.style.color = val < 0 ? '#F87171' : val > 0 ? '#10B981' : '#FFFFFF';
                        }
                    });
                });
                table.appendChild(tbody);
                console.log('Ranking table updated successfully');
            } catch (error) {
                console.error('Error updating ranking table:', error);
                const tbody = document.createElement('tbody');
                const row = tbody.insertRow();
                const cell = row.insertCell();
                cell.textContent = 'No ranking data available';
                cell.colSpan = 33;
                table.appendChild(tbody);
            }
        }

        function updateRawDataTable() {
            try {
                const table = document.getElementById('raw-data-table');
                table.innerHTML = '';
                console.log('Updating raw data table');

                if (rawData.length === 0) {
                    const row = table.insertRow();
                    const cell = row.insertCell();
                    cell.textContent = 'No raw data available';
                    cell.colSpan = 10;
                    return;
                }

                const thead = document.createElement('thead');
                const headerRow = thead.insertRow();
                const columns = Object.keys(rawData[0]);
                columns.forEach((text, index) => {
                    const th = document.createElement('th');
                    th.textContent = text;
                    th.dataset.column = text;
                    th.dataset.order = 'desc';
                    th.addEventListener('click', () => sortTable('raw-data-table', index));
                    headerRow.appendChild(th);
                });
                table.appendChild(thead);

                const tbody = document.createElement('tbody');
                rawData.forEach(item => {
                    const row = tbody.insertRow();
                    columns.forEach(col => {
                        const cell = row.insertCell();
                        let value = item[col];
                        if (Number.isFinite(value)) {
                            if (col === 'Volume' || col === 'Open Interest') {
                                value = parseInt(value).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
                            } else {
                                value = value.toFixed(2);
                            }
                        } else {
                            value = value || 'N/A';
                        }
                        cell.textContent = value;
                    });
                });
                table.appendChild(tbody);
            } catch (error) {
                console.error('Error updating raw data table:', error);
                const tbody = document.createElement('tbody');
                const row = tbody.insertRow();
                const cell = row.insertCell();
                cell.textContent = 'No raw data available';
                cell.colSpan = 10;
                table.appendChild(tbody);
            }
        }

        function sortTable(tableId, columnIndex) {
            try {
                const table = document.getElementById(tableId);
                const header = table.querySelector('thead tr').children[columnIndex];
                const column = header.dataset.column;
                const order = header.dataset.order === 'desc' ? 'asc' : 'desc';
                header.dataset.order = order;

                const tbody = table.querySelector('tbody');
                const rows = Array.from(tbody.querySelectorAll('tr'));
                rows.sort((a, b) => {
                    let aValue = a.children[columnIndex].textContent;
                    let bValue = b.children[columnIndex].textContent;
                    if (aValue === 'N/A') return 1;
                    if (bValue === 'N/A') return -1;
                    if (column === 'Volume' || column === 'Open Interest') {
                        aValue = parseInt(aValue.replace(/,/g, '')) || -Infinity;
                        bValue = parseInt(bValue.replace(/,/g, '')) || -Infinity;
                    } else if (column === 'Rank') {
                        aValue = parseInt(aValue);
                        bValue = parseInt(bValue);
                    } else {
                        aValue = parseFloat(aValue) || aValue;
                        bValue = parseFloat(bValue) || bValue;
                    }
                    if (typeof aValue === 'number' && typeof bValue === 'number') {
                        return order === 'desc' ? bValue - aValue : aValue - bValue;
                    }
                    return order === 'desc' ? bValue.localeCompare(aValue) : aValue.localeCompare(bValue);
                });

                tbody.innerHTML = '';
                rows.forEach(row => tbody.appendChild(row));
            } catch (error) {
                console.error('Error sorting table:', error);
            }
        }

        function updateMoneynessVsIV() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const selectedExpiry = document.getElementById('expiry-select').value;
                const filteredData = data.filter(item => item.Ticker === selectedTicker && item.Expiry === selectedExpiry);
                console.log('Updating Moneyness vs. IV chart for ticker:', selectedTicker, 'Expiry:', selectedExpiry, 'Filtered data size:', filteredData.length);

                const datasets = [
                    {
                        label: 'Calls Implied Volatility Mid',
                        data: aggregateDataByX(filteredData.filter(item => item.Type === 'Call'), 'Moneyness', 'IV_mid'),
                        borderColor: '#A855F7',
                        backgroundColor: '#A855F7',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Puts Implied Volatility Mid',
                        data: aggregateDataByX(filteredData.filter(item => item.Type === 'Put'), 'Moneyness', 'IV_mid'),
                        borderColor: '#A855F7',
                        backgroundColor: '#A855F7',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [5, 5],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Calls Smoothed IV',
                        data: aggregateDataByX(filteredData.filter(item => item.Type === 'Call'), 'Moneyness', 'Smoothed_IV'),
                        borderColor: '#D8B4FE',
                        backgroundColor: '#D8B4FE',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Puts Smoothed IV',
                        data: aggregateDataByX(filteredData.filter(item => item.Type === 'Put'), 'Moneyness', 'Smoothed_IV'),
                        borderColor: '#D8B4FE',
                        backgroundColor: '#D8B4FE',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [5, 5],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Call Local Vol',
                        data: aggregateDataByX(filteredData.filter(item => item.Type === 'Call' && item['Call Local Vol'] > 0), 'Moneyness', 'Call Local Vol'),
                        borderColor: '#10B981',
                        backgroundColor: '#10B981',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Put Local Vol',
                        data: aggregateDataByX(filteredData.filter(item => item.Type === 'Put' && item['Put Local Vol'] > 0), 'Moneyness', 'Put Local Vol'),
                        borderColor: '#10B981',
                        backgroundColor: '#10B981',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [5, 5],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Realised Vol 100d',
                        data: aggregateDataByX(filteredData, 'Moneyness', 'Realised_Vol_100d'),
                        borderColor: '#FBBF24',
                        backgroundColor: '#FBBF24',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    }
                ];

                if (moneynessChart) moneynessChart.destroy();
                moneynessChart = new Chart(document.getElementById('moneyness-vs-iv-chart').getContext('2d'), {
                    type: 'line',
                    data: { datasets },
                    options: {
                        plugins: { legend: { labels: { color: '#FFFFFF' } } },
                        scales: {
                            x: {
                                type: 'linear',
                                title: { display: true, text: 'Moneyness (%)', color: '#FFFFFF' },
                                min: 0,
                                max: 200,
                                grid: { color: '#A855F7' },
                                ticks: { color: '#FFFFFF' }
                            },
                            y: {
                                title: { display: true, text: 'Volatility (%)', color: '#FFFFFF' },
                                beginAtZero: true,
                                grid: { color: '#A855F7' },
                                ticks: { color: '#FFFFFF' }
                            }
                        },
                        backgroundColor: '#1A1A2E'
                    }
                });
                createStatsTable(moneynessChart, 'moneyness-vs-iv-chart');
            } catch (error) {
                console.error('Error updating Moneyness vs. IV chart:', error);
            }
        }

        function updateExpiryVsIV() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const selectedMoneyness = parseFloat(document.getElementById('moneyness-select').value);
                const filteredData = data.filter(item => item.Ticker === selectedTicker && Math.round(item.Moneyness * 100 / 10) * 0.1 === selectedMoneyness);
                console.log('Updating Expiry vs. IV chart for ticker:', selectedTicker, 'Moneyness:', selectedMoneyness, 'Filtered data size:', filteredData.length);

                const datasets = [
                    {
                        label: 'Calls Implied Volatility Mid',
                        data: aggregateDataByX(filteredData.filter(item => item.Type === 'Call'), 'Expiry', 'IV_mid'),
                        borderColor: '#A855F7',
                        backgroundColor: '#A855F7',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Puts Implied Volatility Mid',
                        data: aggregateDataByX(filteredData.filter(item => item.Type === 'Put'), 'Expiry', 'IV_mid'),
                        borderColor: '#A855F7',
                        backgroundColor: '#A855F7',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [5, 5],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Calls Smoothed IV',
                        data: aggregateDataByX(filteredData.filter(item => item.Type === 'Call'), 'Expiry', 'Smoothed_IV'),
                        borderColor: '#D8B4FE',
                        backgroundColor: '#D8B4FE',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [5, 5],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Puts Smoothed IV',
                        data: aggregateDataByX(filteredData.filter(item => item.Type === 'Put'), 'Expiry', 'Smoothed_IV'),
                        borderColor: '#D8B4FE',
                        backgroundColor: '#D8B4FE',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [10, 5],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Call Local Vol',
                        data: aggregateDataByX(filteredData.filter(item => item.Type === 'Call' && item['Call Local Vol'] > 0), 'Expiry', 'Call Local Vol'),
                        borderColor: '#10B981',
                        backgroundColor: '#10B981',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Put Local Vol',
                        data: aggregateDataByX(filteredData.filter(item => item.Type === 'Put' && item['Put Local Vol'] > 0), 'Expiry', 'Put Local Vol'),
                        borderColor: '#10B981',
                        backgroundColor: '#10B981',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [5, 5],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Realised Vol 100d',
                        data: aggregateDataByX(filteredData, 'Expiry', 'Realised_Vol_100d'),
                        borderColor: '#FBBF24',
                        backgroundColor: '#FBBF24',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    }
                ];

                if (expiryChart) expiryChart.destroy();
                expiryChart = new Chart(document.getElementById('expiry-vs-iv-chart').getContext('2d'), {
                    type: 'line',
                    data: { datasets },
                    options: {
                        plugins: { legend: { labels: { color: '#FFFFFF' } } },
                        scales: {
                            x: {
                                type: 'time',
                                time: { unit: 'day' },
                                title: { display: true, text: 'Expiry Date', color: '#FFFFFF' },
                                grid: { color: '#A855F7' },
                                ticks: { color: '#FFFFFF' }
                            },
                            y: {
                                title: { display: true, text: 'Volatility (%)', color: '#FFFFFF' },
                                beginAtZero: true,
                                grid: { color: '#A855F7' },
                                ticks: { color: '#FFFFFF' }
                            }
                        },
                        backgroundColor: '#1A1A2E'
                    }
                });
                createStatsTable(expiryChart, 'expiry-vs-iv-chart');
            } catch (error) {
                console.error('Error updating Expiry vs. IV chart:', error);
            }
        }

        function updateDeltaVsIV() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const selectedExpiry = document.getElementById('delta-expiry-select').value;
                const filteredData = data.filter(item => item.Ticker === selectedTicker && item.Expiry === selectedExpiry);
                console.log('Updating Delta vs. IV chart for ticker:', selectedTicker, 'Expiry:', selectedExpiry, 'Filtered data size:', filteredData.length);

                const datasets = [
                    {
                        label: 'Calls Implied Volatility Mid',
                        data: aggregateDataByX(filteredData.filter(item => item.Type === 'Call'), 'Delta', 'IV_mid'),
                        borderColor: '#A855F7',
                        backgroundColor: '#A855F7',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Puts Implied Volatility Mid',
                        data: aggregateDataByX(filteredData.filter(item => item.Type === 'Put'), 'Delta', 'IV_mid'),
                        borderColor: '#A855F7',
                        backgroundColor: '#A855F7',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [5, 5],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Calls Smoothed IV',
                        data: aggregateDataByX(filteredData.filter(item => item.Type === 'Call'), 'Delta', 'Smoothed_IV'),
                        borderColor: '#D8B4FE',
                        backgroundColor: '#D8B4FE',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [5, 5],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Puts Smoothed IV',
                        data: aggregateDataByX(filteredData.filter(item => item.Type === 'Put'), 'Delta', 'Smoothed_IV'),
                        borderColor: '#D8B4FE',
                        backgroundColor: '#D8B4FE',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [10, 5],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Call Local Vol',
                        data: aggregateDataByX(filteredData.filter(item => item.Type === 'Call' && item['Call Local Vol'] > 0), 'Delta', 'Call Local Vol'),
                        borderColor: '#10B981',
                        backgroundColor: '#10B981',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Put Local Vol',
                        data: aggregateDataByX(filteredData.filter(item => item.Type === 'Put' && item['Put Local Vol'] > 0), 'Delta', 'Put Local Vol'),
                        borderColor: '#10B981',
                        backgroundColor: '#10B981',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [5, 5],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Realised Vol 100d',
                        data: aggregateDataByX(filteredData, 'Delta', 'Realised_Vol_100d'),
                        borderColor: '#FBBF24',
                        backgroundColor: '#FBBF24',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y'
                    }
                ];

                if (deltaChart) deltaChart.destroy();
                deltaChart = new Chart(document.getElementById('delta-vs-iv-chart').getContext('2d'), {
                    type: 'line',
                    data: { datasets },
                    options: {
                        plugins: { legend: { labels: { color: '#FFFFFF' } } },
                        scales: {
                            x: {
                                type: 'linear',
                                title: { display: true, text: 'Delta (%)', color: '#FFFFFF' },
                                min: -100,
                                max: 100,
                                grid: { color: '#A855F7' },
                                ticks: { color: '#FFFFFF', callback: value => Math.abs(value).toFixed(0) }
                            },
                            y: {
                                title: { display: true, text: 'Volatility (%)', color: '#FFFFFF' },
                                beginAtZero: true,
                                grid: { color: '#A855F7' },
                                ticks: { color: '#FFFFFF' }
                            }
                        },
                        backgroundColor: '#1A1A2E'
                    }
                });
                createStatsTable(deltaChart, 'delta-vs-iv-chart');
            } catch (error) {
                console.error('Error updating Delta vs. IV chart:', error);
            }
        }

        function prepareSurfaceData(filteredData, zKey) {
            try {
                const datasetDate = new Date(document.getElementById('date-select').value.replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3'));
                const tFilteredData = filteredData.filter(item => {
                    const t = calculateTimeToExpiry(item.Expiry, datasetDate);
                    return t !== null && Number.isFinite(t);
                });
                const moneynessValues = [...new Set(tFilteredData.map(item => Math.round(item.Moneyness * 10) * 0.1))]
                    .filter(val => !isNaN(val)).sort((a, b) => a - b);
                const expiryValues = [...new Set(tFilteredData.map(item => normalizeDate(item.Expiry)))]
                    .filter(val => val).sort();
                const zData = [];
                moneynessValues.forEach(() => zData.push(new Array(expiryValues.length).fill(null)));
                tFilteredData.forEach(item => {
                    const moneynessIndex = moneynessValues.indexOf(Math.round(item.Moneyness * 10) * 0.1);
                    const expiryIndex = expiryValues.indexOf(normalizeDate(item.Expiry));
                    if (moneynessIndex >= 0 && expiryIndex >= 0 && Number.isFinite(item[zKey])) {
                        zData[moneynessIndex][expiryIndex] = item[zKey] * 100;
                    }
                });
                const expiryTimes = expiryValues.map(date => calculateTimeToExpiry(date, datasetDate));
                interpolateAlongExpiry(zData, expiryTimes);
                interpolateAlongMoneyness(zData, moneynessValues);
                const zValues = zData.flat().filter(v => Number.isFinite(v));
                const minZ = zValues.length > 0 ? Math.min(...zValues) : 0;
                const maxZ = zValues.length > 0 ? Math.max(...zValues) : 0;
                return {
                    x: expiryValues,
                    y: moneynessValues.map(val => val * 100),
                    z: zData,
                    minZ: minZ,
                    maxZ: maxZ
                };
            } catch (error) {
                console.error('Error preparing surface data:', error);
                return { x: [], y: [], z: [], minZ: 0, maxZ: 0 };
            }
        }

        function calculateTimeToExpiry(expiryDate, referenceDate) {
            try {
                const expiry = new Date(expiryDate);
                const ref = new Date(referenceDate);
                const diffMs = expiry - ref;
                return diffMs / (365 * 24 * 60 * 60 * 1000); // Convert to years
            } catch (error) {
                console.error('Error calculating time to expiry:', error);
                return null;
            }
        }

        function interpolateAlongExpiry(zData, expiryTimes) {
            for (let y = 0; y < zData.length; y++) {
                const row = zData[y];
                const known = [];
                for (let x = 0; x < row.length; x++) {
                    if (row[x] !== null && Number.isFinite(row[x])) {
                        known.push({t: expiryTimes[x], val: row[x], idx: x});
                    }
                }
                if (known.length < 2) continue;
                known.sort((a, b) => a.t - b.t);
                for (let i = 0; i < known.length - 1; i++) {
                    const start = known[i];
                    const end = known[i + 1];
                    const dt = end.t - start.t;
                    if (dt <= 0) continue;
                    for (let idx = start.idx + 1; idx < end.idx; idx++) {
                        const curr_t = expiryTimes[idx];
                        const frac = (curr_t - start.t) / dt;
                        row[idx] = start.val + frac * (end.val - start.val);
                    }
                }
            }
        }

        function interpolateAlongMoneyness(zData, moneynessValues) {
            for (let x = 0; x < zData[0].length; x++) {
                const col = zData.map(row => row[x]);
                const known = [];
                for (let y = 0; y < col.length; y++) {
                    if (col[y] !== null && Number.isFinite(col[y])) {
                        known.push({m: moneynessValues[y], val: col[y], idx: y});
                    }
                }
                if (known.length < 2) continue;
                known.sort((a, b) => a.m - b.m);
                for (let i = 0; i < known.length - 1; i++) {
                    const start = known[i];
                    const end = known[i + 1];
                    const dm = end.m - start.m;
                    if (dm <= 0) continue;
                    for (let idx = start.idx + 1; idx < end.idx; idx++) {
                        const curr_m = moneynessValues[idx];
                        const frac = (curr_m - start.m) / dm;
                        zData[idx][x] = start.val + frac * (end.val - start.val);
                    }
                }
            }
        }

        function updateCallVolSurface() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const filteredData = data.filter(item => item.Ticker === selectedTicker && item.Type === 'Call');
                console.log('Updating Call Volatility Surface for ticker:', selectedTicker, 'Filtered data size:', filteredData.length);

                const surfaceData = prepareSurfaceData(filteredData, 'IV_mid');
                const minZ = surfaceData.minZ;
                const maxZ = surfaceData.maxZ;
                const colorscale = [
                    [0, 'rgb(0,0,255)'],
                    [0.25, 'rgb(0,255,255)'],
                    [0.5, 'rgb(0,255,0)'],
                    [0.75, 'rgb(255,255,0)'],
                    [1, 'rgb(255,0,0)']
                ];
                const numTicks = 6;
                const tickInterval = (maxZ - minZ) / (numTicks - 1);
                const tickvals = [];
                const ticktext = [];
                for (let i = 0; i < numTicks; i++) {
                    const val = minZ + i * tickInterval;
                    tickvals.push(val);
                    ticktext.push(val.toFixed(0));
                }
                const plotData = [{
                    x: surfaceData.x,
                    y: surfaceData.y,
                    z: surfaceData.z,
                    type: 'surface',
                    colorscale: colorscale,
                    cmin: minZ,
                    cmax: maxZ,
                    showscale: true,
                    colorbar: {
                        title: 'Volatility (%)',
                        titleside: 'right',
                        titlefont: { color: '#FFFFFF' },
                        tickfont: { color: '#FFFFFF' },
                        tickvals: tickvals,
                        ticktext: ticktext
                    }
                }];
                const layout = {
                    title: { text: 'Call Implied Volatility Surface (%)', font: { color: '#FFFFFF', size: 16 }, y: 0.95 },
                    scene: {
                        xaxis: { title: 'Expiry', type: 'date', tickformat: '%Y-%m-%d', color: '#FFFFFF' },
                        yaxis: { title: 'Moneyness (%)', color: '#FFFFFF' },
                        zaxis: { title: 'Volatility (%)', color: '#FFFFFF', range: [minZ, maxZ], autorange: false },
                        aspectmode: 'manual',
                        aspectratio: { x: 1, y: 1, z: 0.5 },
                        bgcolor: '#1A1A2E'
                    },
                    margin: { l: 30, r: 30, b: 30, t: 50 },
                    paper_bgcolor: '#1A1A2E',
                    plot_bgcolor: '#1A1A2E'
                };
                Plotly.newPlot('call-vol-surface', plotData, layout);
                const rotateXSlider = document.getElementById('rotate-x-slider');
                const rotateZSlider = document.getElementById('rotate-z-slider');
                rotateXSlider.addEventListener('input', () => updateCamera());
                rotateZSlider.addEventListener('input', () => updateCamera());
                function updateCamera() {
                    const xAngle = parseInt(rotateXSlider.value);
                    const zAngle = parseInt(rotateZSlider.value);
                    const x = 2 * Math.sin(xAngle * Math.PI / 180);
                    const y = 2 * Math.cos(xAngle * Math.PI / 180);
                    const z = 2 * Math.sin(zAngle * Math.PI / 180);
                    Plotly.update('call-vol-surface', {}, { scene: { camera: { eye: { x, y, z } } } });
                }
            } catch (error) {
                console.error('Error updating Call Volatility Surface:', error);
                Plotly.purge('call-vol-surface');
            }
        }

        function updateHistoricChart() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const historyLength = document.getElementById('history-select').value;
                console.log('Updating Historic chart for ticker:', selectedTicker, 'History length:', historyLength, 'historicData columns:', historicData.length > 0 ? Object.keys(historicData[0]) : []);

                if (!historicData || historicData.length === 0) {
                    if (historicChart) historicChart.destroy();
                    document.getElementById('historic-error').style.display = 'block';
                    document.getElementById('historic-error').textContent = 'No historic data available';
                    return;
                }

                let filteredHistoric = historicData.filter(item => item.Ticker === selectedTicker && item.Date && Number.isFinite(item.Close));
                if (filteredHistoric.length === 0) {
                    if (historicChart) historicChart.destroy();
                    document.getElementById('historic-error').style.display = 'block';
                    document.getElementById('historic-error').textContent = 'No valid historic data for selected ticker';
                    return;
                }

                filteredHistoric.sort((a, b) => new Date(a.Date) - new Date(b.Date));
                const fromDate = calculateDateRange(historyLength);
                const minHistoricDate = new Date(Math.min(...filteredHistoric.map(item => new Date(item.Date))));
                const maxHistoricDate = new Date(Math.max(...filteredHistoric.map(item => new Date(item.Date))));

                if (fromDate) {
                    filteredHistoric = filteredHistoric.filter(item => new Date(item.Date) >= fromDate);
                }

                const dates = filteredHistoric.map(item => new Date(item.Date));
                const volColumns = [
                    'Realised_Vol_Close_30', 'Realized_Vol_Close_30',
                    'Realised_Vol_Close_60', 'Realized_Vol_Close_60',
                    'Realised_Vol_Close_100', 'Realized_Vol_Close_100',
                    'Realised_Vol_Close_180', 'Realized_Vol_Close_180',
                    'Realised_Vol_Close_252', 'Realized_Vol_Close_252'
                ];
                const availableVolColumns = volColumns.filter(col => filteredHistoric[0].hasOwnProperty(col));
                console.log('Available volatility columns:', availableVolColumns);

                const vol30 = filteredHistoric.map(item => {
                    const col = availableVolColumns.find(c => c.includes('30')) || 'Realised_Vol_Close_30';
                    return Number.isFinite(item[col]) ? parseFloat(item[col]) : null;
                }).filter(v => v !== null);
                const vol60 = filteredHistoric.map(item => {
                    const col = availableVolColumns.find(c => c.includes('60')) || 'Realised_Vol_Close_60';
                    return Number.isFinite(item[col]) ? parseFloat(item[col]) : null;
                }).filter(v => v !== null);
                const vol90 = filteredHistoric.map(item => {
                    const col = availableVolColumns.find(c => c.includes('100')) || 'Realised_Vol_Close_100';
                    return Number.isFinite(item[col]) ? parseFloat(item[col]) : null;
                }).filter(v => v !== null);
                const vol180 = filteredHistoric.map(item => {
                    const col = availableVolColumns.find(c => c.includes('180')) || 'Realised_Vol_Close_180';
                    return Number.isFinite(item[col]) ? parseFloat(item[col]) : null;
                }).filter(v => v !== null);
                const vol360 = filteredHistoric.map(item => {
                    const col = availableVolColumns.find(c => c.includes('252')) || 'Realised_Vol_Close_252';
                    return Number.isFinite(item[col]) ? parseFloat(item[col]) : null;
                }).filter(v => v !== null);

                console.log('Historic chart data sample:', {
                    dates: dates.slice(0, 5),
                    prices: filteredHistoric.slice(0, 5).map(item => item.Close),
                    vol30: vol30.slice(0, 5),
                    vol60: vol60.slice(0, 5),
                    vol90: vol90.slice(0, 5)
                });

                const datasets = [
                    {
                        label: 'Stock Price',
                        data: filteredHistoric.map((item, i) => ({ x: dates[i], y: parseFloat(item.Close) })),
                        borderColor: '#A855F7',
                        backgroundColor: '#A855F7',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        yAxisID: 'y'
                    },
                    {
                        label: '30-day Realised Vol (%)',
                        data: vol30.map((v, i) => ({ x: dates[i], y: v })),
                        borderColor: '#D8B4FE',
                        backgroundColor: '#D8B4FE',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y1'
                    },
                    {
                        label: '60-day Realised Vol (%)',
                        data: vol60.map((v, i) => ({ x: dates[i], y: v })),
                        borderColor: '#9333EA',
                        backgroundColor: '#9333EA',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y1'
                    },
                    {
                        label: '100-day Realised Vol (%)',
                        data: vol90.map((v, i) => ({ x: dates[i], y: v })),
                        borderColor: '#F87171',
                        backgroundColor: '#F87171',
                        pointRadius: 5,
                        pointStyle: 'crossRot',
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y1'
                    },
                    {
                        label: '180-day Realised Vol (%)',
                        data: vol180.map((v, i) => ({ x: dates[i], y: v })),
                        borderColor: '#FBBF24',
                        backgroundColor: '#FBBF24',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y1'
                    },
                    {
                        label: '252-day Realised Vol (%)',
                        data: vol360.map((v, i) => ({ x: dates[i], y: v })),
                        borderColor: '#10B981',
                        backgroundColor: '#10B981',
                        pointRadius: 1,
                        fill: false,
                        showLine: true,
                        borderDash: [],
                        yAxisID: 'y1'
                    }
                ];

                const annotations = eventsData
                    .filter(event => {
                        if (!event.Start_Date || !event.End_Date) return false;
                        const startDate = new Date(event.Start_Date);
                        const endDate = new Date(event.End_Date);
                        if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) return false;
                        if (!(event.Ticker === 'ALL' || event.Ticker === selectedTicker)) return false;
                        if (startDate > maxHistoricDate || endDate < minHistoricDate) return false;
                        if (fromDate && endDate < fromDate) return false;
                        return true;
                    })
                    .map((event, index) => ({
                        type: 'box',
                        xMin: new Date(Math.max(new Date(event.Start_Date), fromDate || minHistoricDate)),
                        xMax: new Date(Math.min(new Date(event.End_Date), maxHistoricDate)),
                        yMin: 'y',
                        yMax: 'y',
                        backgroundColor: event.Impact === 'dip' ? 'rgba(248, 113, 113, 0.2)' : 'rgba(74, 222, 128, 0.2)',
                        borderColor: event.Impact === 'dip' ? 'rgba(248, 113, 113, 0.5)' : 'rgba(74, 222, 128, 0.5)',
                        borderWidth: 1,
                        label: {
                            content: event.Event || 'Unknown Event',
                            display: true,
                            position: 'center',
                            color: '#FFFFFF',
                            font: { size: 12 },
                            rotation: 90
                        }
                    }));

                if (historicChart) historicChart.destroy();
                historicChart = new Chart(document.getElementById('historic-price-chart').getContext('2d'), {
                    type: 'line',
                    data: { datasets },
                    options: {
                        plugins: {
                            legend: { labels: { color: '#FFFFFF' } },
                            annotation: { annotations }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: { unit: 'month' },
                                title: { display: true, text: 'Date', color: '#FFFFFF' },
                                grid: { color: '#A855F7' },
                                ticks: { color: '#FFFFFF' }
                            },
                            y: {
                                title: { display: true, text: 'Stock Price ($)', color: '#FFFFFF' },
                                beginAtZero: false,
                                grid: { color: '#A855F7' },
                                ticks: { color: '#FFFFFF' }
                            },
                            y1: {
                                type: 'linear',
                                position: 'right',
                                title: { display: true, text: 'Realised Volatility (%)', color: '#FFFFFF' },
                                beginAtZero: false,
                                grid: { color: '#A855F7' },
                                ticks: { color: '#FFFFFF' }
                            }
                        },
                        backgroundColor: '#1A1A2E'
                    }
                });
                document.getElementById('historic-error').style.display = 'none';
                createStatsTable(historicChart, 'historic-price-chart');
            } catch (error) {
                console.error('Error updating Historic chart:', error);
                document.getElementById('historic-error').style.display = 'block';
                document.getElementById('historic-error').textContent = 'Error loading historic chart';
            }
        }
        
        function updateVolumeChart() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const uniqueTickers = [...new Set(rankingData.map(item => item.Ticker))].filter(val => val).sort();
                const volumes = uniqueTickers.map(ticker => {
                    const tickerData = rankingData.find(item => item.Ticker === ticker);
                    return tickerData && Number.isFinite(tickerData['Volume']) ? parseInt(tickerData['Volume']) : 0;
                });
                const backgroundColors = uniqueTickers.map(ticker => ticker === selectedTicker ? '#FFFF00' : '#00BFFF');
                if (volumeChart) volumeChart.destroy();
                volumeChart = new Chart(document.getElementById('volume-chart').getContext('2d'), {
                    type: 'bar',
                    data: {
                        labels: uniqueTickers,
                        datasets: [{
                            label: 'Total Volume',
                            data: volumes,
                            backgroundColor: backgroundColors,
                            borderColor: backgroundColors,
                            borderWidth: 1
                        }]
                    },
                    options: {
                        plugins: { legend: { labels: { color: '#FFFFFF' } } },
                        scales: {
                            x: { title: { display: true, text: 'Ticker', color: '#FFFFFF' }, grid: { color: '#FFFFFF33' }, ticks: { color: '#FFFFFF' } },
                            y: {
                                title: { display: true, text: 'Volume', color: '#FFFFFF' },
                                beginAtZero: true,
                                grid: { color: '#FFFFFF33' },
                                ticks: {
                                    color: '#FFFFFF',
                                    callback: value => Number(value).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 })
                                }
                            }
                        },
                        backgroundColor: '#1C2526'
                    }
                });
                console.log('Volume chart updated for tickers:', uniqueTickers);
            } catch (error) {
                console.error('Error updating volume chart:', error);
            }
        }

        function updateOpenInterestChart() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const uniqueTickers = [...new Set(rankingData.map(item => item.Ticker))].filter(val => val).sort();
                const openInterests = uniqueTickers.map(ticker => {
                    const tickerData = rankingData.find(item => item.Ticker === ticker);
                    return tickerData && Number.isFinite(tickerData['Open Interest']) ? parseInt(tickerData['Open Interest']) : 0;
                });
                const backgroundColors = uniqueTickers.map(ticker => ticker === selectedTicker ? '#FFFF00' : '#00BFFF');
                if (openInterestChart) openInterestChart.destroy();
                openInterestChart = new Chart(document.getElementById('open-interest-chart').getContext('2d'), {
                    type: 'bar',
                    data: {
                        labels: uniqueTickers,
                        datasets: [{
                            label: 'Total Open Interest',
                            data: openInterests,
                            backgroundColor: backgroundColors,
                            borderColor: backgroundColors,
                            borderWidth: 1
                        }]
                    },
                    options: {
                        plugins: { legend: { labels: { color: '#FFFFFF' } } },
                        scales: {
                            x: { title: { display: true, text: 'Ticker', color: '#FFFFFF' }, grid: { color: '#FFFFFF33' }, ticks: { color: '#FFFFFF' } },
                            y: {
                                title: { display: true, text: 'Open Interest', color: '#FFFFFF' },
                                beginAtZero: true,
                                grid: { color: '#FFFFFF33' },
                                ticks: {
                                    color: '#FFFFFF',
                                    callback: value => Number(value).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 })
                                }
                            }
                        },
                        backgroundColor: '#1C2526'
                    }
                });
                console.log('Open Interest chart updated for tickers:', uniqueTickers);
            } catch (error) {
                console.error('Error updating open interest chart:', error);
            }
        }

        function aggregateDataByX(data, xKey, yKey) {
            try {
                const grouped = data.reduce((acc, item) => {
                    const xValue = xKey === 'Expiry' ? new Date(item[xKey]).toISOString() : item[xKey];
                    const yValue = item[yKey];
                    if (!acc[xValue]) acc[xValue] = { sum: 0, count: 0 };
                    if (!isNaN(yValue) && yValue !== null) {
                        acc[xValue].sum += yValue;
                        acc[xValue].count += 1;
                    }
                    return acc;
                }, {});
                return Object.keys(grouped).map(x => {
                    const group = grouped[x];
                    if (group.count > 0) {
                        return {
                            x: xKey === 'Expiry' ? new Date(x) : parseFloat(x) * (xKey === 'Moneyness' || xKey === 'Delta' ? 100 : 1),
                            y: (group.sum / group.count) * 100
                        };
                    }
                }).filter(point => point).sort((a, b) => a.x - b.x);
            } catch (error) {
                console.error('Error aggregating data:', error);
                return [];
            }
        }

        function createStatsTable(chart, canvasId) {
            try {
                const container = document.getElementById(canvasId).parentNode;
                let existingTable = container.querySelector('.stats-table');
                if (existingTable) existingTable.remove();
                const table = document.createElement('table');
                table.className = 'stats-table';
                table.style.display = canvasId === 'historic-price-chart' ? 'table' : (statsTablesVisible ? 'table' : 'none');
                const thead = table.createTHead();
                const headerRow = thead.insertRow();
                ['Label', 'Last', 'Min', 'Max', 'Mean', 'SD', 'SD Change'].forEach(text => {
                    const th = document.createElement('th');
                    th.textContent = text;
                    headerRow.appendChild(th);
                });
                const tbody = table.createTBody();
                chart.data.datasets.forEach(dataset => {
                    if (!dataset.data.length) return;
                    const ys = dataset.data.map(point => point.y).filter(y => !isNaN(y));
                    if (!ys.length) return;
                    const last = ys[ys.length - 1];
                    const min = Math.min(...ys);
                    const max = Math.max(...ys);
                    const mean = ys.reduce((a, b) => a + b, 0) / ys.length;
                    const sd = Math.sqrt(ys.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / (ys.length - 1)) || 0;
                    const sdChanges = ys.slice(1).map((y, i) => y - ys[i]);
                    const sdChange = sdChanges.length > 0 ? Math.sqrt(sdChanges.reduce((a, b) => a + Math.pow(b, 2), 0) / (sdChanges.length - 1)) || 0 : 0;
                    const row = tbody.insertRow();
                    const labelTd = row.insertCell();
                    const swatch = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    swatch.setAttribute('width', '20');
                    swatch.setAttribute('height', '10');
                    swatch.setAttribute('class', 'line-swatch');
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', '0');
                    line.setAttribute('y1', '5');
                    line.setAttribute('x2', '20');
                    line.setAttribute('y2', '5');
                    line.setAttribute('stroke', dataset.borderColor);
                    line.setAttribute('stroke-width', '2');
                    if (dataset.borderDash && dataset.borderDash.length > 0) {
                        line.setAttribute('stroke-dasharray', dataset.borderDash.join(' '));
                    }
                    swatch.appendChild(line);
                    labelTd.appendChild(swatch);
                    labelTd.appendChild(document.createTextNode(` ${dataset.label}`));
                    row.insertCell().textContent = last.toFixed(2);
                    row.insertCell().textContent = min.toFixed(2);
                    row.insertCell().textContent = max.toFixed(2);
                    row.insertCell().textContent = mean.toFixed(2);
                    row.insertCell().textContent = sd.toFixed(2);
                    row.insertCell().textContent = sdChange.toFixed(2);
                });
                container.appendChild(table);
            } catch (error) {
                console.error('Error creating stats table:', error);
            }
        }

        function updateCharts() {
            try {
                console.log('Updating all charts and tables');
                updateMoneynessVsIV();
                updateExpiryVsIV();
                updateDeltaVsIV();
                updateCallVolSurface();
                updateSkewTable();
                updateSummaryTable();
                updateVolumeChart();
                updateOpenInterestChart();
                updateHistoricChart();
                updateRawDataTable();
            } catch (error) {
                console.error('Error updating charts:', error);
            }
        }

        function addKeyboardNavigation() {
            try {
                const chartConfigs = [
                    { canvasId: 'moneyness-vs-iv-chart', selectId: 'expiry-select' },
                    { canvasId: 'expiry-vs-iv-chart', selectId: 'moneyness-select' },
                    { canvasId: 'delta-vs-iv-chart', selectId: 'delta-expiry-select' },
                    { canvasId: 'volume-chart', selectId: 'ticker-search' },
                    { canvasId: 'open-interest-chart', selectId: 'ticker-search' },
                    { canvasId: 'historic-price-chart', selectId: 'history-select' }
                ];

                chartConfigs.forEach(config => {
                    const canvas = document.getElementById(config.canvasId);
                    const select = document.getElementById(config.selectId);
                    canvas.addEventListener('keydown', (event) => {
                        if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
                            event.preventDefault();
                            let newIndex = select.selectedIndex + (event.key === 'ArrowLeft' ? -1 : 1);
                            if (newIndex < 0) newIndex = select.options.length - 1;
                            if (newIndex >= select.options.length) newIndex = 0;
                            select.selectedIndex = newIndex;
                            select.dispatchEvent(new Event('change', { bubbles: true }));
                        }
                    });
                });

                const expirySelect = document.getElementById('expiry-select');
                const deltaExpirySelect = document.getElementById('delta-expiry-select');
                expirySelect.addEventListener('change', () => {
                    console.log('Expiry select changed to:', expirySelect.value);
                    deltaExpirySelect.value = expirySelect.value;
                    updateCharts();
                });
                deltaExpirySelect.addEventListener('change', () => {
                    console.log('Delta expiry select changed to:', deltaExpirySelect.value);
                    expirySelect.value = deltaExpirySelect.value;
                    updateCharts();
                });
                document.getElementById('moneyness-select').addEventListener('change', () => {
                    console.log('Moneyness select changed to:', document.getElementById('moneyness-select').value);
                    updateCharts();
                });
                document.getElementById('history-select').addEventListener('change', () => {
                    console.log('History length changed to:', document.getElementById('history-select').value);
                    updateHistoricChart();
                });
                document.getElementById('source-select').addEventListener('change', () => {
                    console.log('Data source changed to:', document.getElementById('source-select').value);
                    const dateSelect = document.getElementById('date-select');
                    const timeSelect = document.getElementById('time-select');
                    loadData(dateSelect.value + '_' + timeSelect.value);
                });
            } catch (error) {
                console.error('Error adding keyboard navigation:', error);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            try {
                const dateSelect = document.getElementById('date-select');
                const timeSelect = document.getElementById('time-select');
                const tickerSearch = document.getElementById('ticker-search');
                const sourceSelect = document.getElementById('source-select');

                const validateTimestamp = async (timestamp) => {
                    const source = sourceSelect.value;
                    const prefix = source === 'yfinance' ? '_yfinance' : '';
                    try {
                        const response = await fetch(`data/${timestamp}/ranking/ranking${prefix}.csv?v=${Date.now()}`, { method: 'HEAD' });
                        return response.ok ? timestamp : null;
                    } catch {
                        return null;
                    }
                };

                const getLatestValidTimestamp = async (dates) => {
                    const timestamps = dates.sort((a, b) => b.localeCompare(a));
                    for (const ts of timestamps) {
                        if (await validateTimestamp(ts)) return ts;
                    }
                    return '20250827_2136'; // Fallback
                };

                fetch('data/dates.json?v=' + Date.now())
                    .then(response => {
                        if (!response.ok) throw new Error('Failed to load dates.json');
                        return response.json();
                    })
                    .then(async dates => {
                        const uniqueDates = [...new Set(dates.map(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$1-$2-$3')))].sort((a, b) => b.localeCompare(a));
                        dateSelect.innerHTML = '';
                        uniqueDates.forEach(datePart => {
                            const option = document.createElement('option');
                            option.value = datePart.replace(/-/g, '');
                            option.textContent = datePart;
                            dateSelect.appendChild(option);
                        });

                        const loadInitialData = async () => {
                            let timestamp = await getLatestValidTimestamp(dates);
                            if (dateSelect.options.length > 0) {
                                dateSelect.value = timestamp.slice(0, 8);
                                await updateTimeOptions(dateSelect.value, dates);
                                timestamp = dateSelect.value + '_' + (timeSelect.options.length > 0 ? timeSelect.value : '2136');
                            }
                            console.log('Loading initial data with timestamp:', timestamp);
                            await loadData(timestamp);
                            updateDropdowns();
                            updateHistoricChart();
                            updateSummaryTable();
                            updateSkewTable();
                            console.log('Initial data and Overview loaded for timestamp:', timestamp);
                        };

                        await loadInitialData();

                        dateSelect.addEventListener('change', async (e) => {
                            console.log('Date select changed to:', e.target.value);
                            await updateTimeOptions(e.target.value, dates);
                            const timestamp = e.target.value + '_' + (timeSelect.options.length > 0 ? timeSelect.value : '2136');
                            if (await validateTimestamp(timestamp)) {
                                await loadData(timestamp);
                                updateDropdowns();
                                const currentSection = document.querySelector('.overview-container[style*="flex"], .volatility-grid[style*="grid"], .chart-container[style*="block"]');
                                const sectionId = currentSection ? currentSection.id : 'overview';
                                updateSection(sectionId);
                                console.log('Updated section after date change:', sectionId);
                            } else {
                                console.warn('Invalid timestamp:', timestamp);
                                document.getElementById('historic-error').style.display = 'block';
                                document.getElementById('historic-error').textContent = 'Invalid date selected';
                            }
                        });

                        timeSelect.addEventListener('change', async (e) => {
                            console.log('Time select changed to:', e.target.value);
                            const timestamp = dateSelect.value + '_' + e.target.value;
                            if (await validateTimestamp(timestamp)) {
                                await loadData(timestamp);
                                updateDropdowns();
                                const currentSection = document.querySelector('.overview-container[style*="flex"], .volatility-grid[style*="grid"], .chart-container[style*="block"]');
                                const sectionId = currentSection ? currentSection.id : 'overview';
                                updateSection(sectionId);
                                console.log('Updated section after time change:', sectionId);
                            } else {
                                console.warn('Invalid timestamp:', timestamp);
                                document.getElementById('historic-error').style.display = 'block';
                                document.getElementById('historic-error').textContent = 'Invalid time selected';
                            }
                        });

                        tickerSearch.addEventListener('input', async () => {
                            console.log('Ticker changed to:', tickerSearch.value);
                            document.getElementById('ticker-display').textContent = `Selected Ticker: ${tickerSearch.value.toUpperCase() || 'N/A'}`;
                            const timestamp = dateSelect.value + '_' + (timeSelect.options.length > 0 ? timeSelect.value : '2136');
                            if (await validateTimestamp(timestamp)) {
                                await loadData(timestamp);
                                updateDropdowns();
                                const currentSection = document.querySelector('.overview-container[style*="flex"], .volatility-grid[style*="grid"], .chart-container[style*="block"]');
                                const sectionId = currentSection ? currentSection.id : 'overview';
                                updateSection(sectionId);
                                console.log('Updated section after ticker change:', sectionId);
                            } else {
                                console.warn('Invalid timestamp:', timestamp);
                                document.getElementById('historic-error').style.display = 'block';
                                document.getElementById('historic-error').textContent = 'Invalid data timestamp';
                            }
                        });

                        sourceSelect.addEventListener('change', async () => {
                            console.log('Source changed to:', sourceSelect.value);
                            const timestamp = dateSelect.value + '_' + (timeSelect.options.length > 0 ? timeSelect.value : '2136');
                            if (await validateTimestamp(timestamp)) {
                                await loadData(timestamp);
                                updateDropdowns();
                                const currentSection = document.querySelector('.overview-container[style*="flex"], .volatility-grid[style*="grid"], .chart-container[style*="block"]');
                                const sectionId = currentSection ? currentSection.id : 'overview';
                                updateSection(sectionId);
                                console.log('Updated section after source change:', sectionId);
                            } else {
                                console.warn('Invalid timestamp:', timestamp);
                                document.getElementById('historic-error').style.display = 'block';
                                document.getElementById('historic-error').textContent = 'Invalid data timestamp';
                            }
                        });

                        const updateSection = (targetId) => {
                            const target = document.getElementById(targetId);
                            document.querySelectorAll('.overview-container, .volatility-grid, .chart-container').forEach(container => {
                                container.style.display = 'none';
                            });
                            console.log(`Updating section: ${targetId}, data sizes:`, {
                                data: data.length,
                                historicData: historicData.length,
                                skewData: skewData.length,
                                rankingData: rankingData.length
                            });
                            if (targetId === 'overview') {
                                target.style.display = 'flex';
                                console.log('Showing Overview with flex layout');
                                if (historicData.length) updateHistoricChart();
                                if (rankingData.length) updateSummaryTable();
                                if (skewData.length) updateSkewTable();
                                console.log('Updated Overview charts and tables');
                            } else if (targetId === 'volatility') {
                                target.style.display = 'grid';
                                console.log('Showing Volatility with grid layout');
                                if (data.length) {
                                    updateMoneynessVsIV();
                                    updateExpiryVsIV();
                                    updateDeltaVsIV();
                                    updateCallVolSurface();
                                } else {
                                    console.warn('No data available for Volatility charts');
                                    document.getElementById('historic-error').style.display = 'block';
                                    document.getElementById('historic-error').textContent = 'No data available for volatility charts';
                                }
                                console.log('Updated Volatility charts');
                            } else if (targetId === 'ranking') {
                                target.style.display = 'block';
                                console.log('Showing Ranking with block layout');
                                if (rankingData.length) {
                                    updateVolumeChart();
                                    updateOpenInterestChart();
                                    updateRankingTable();
                                }
                                console.log('Updated Ranking table');
                            } else if (targetId === 'data-table') {
                                target.style.display = 'block';
                                console.log('Showing Data Table with block layout');
                                if (rawData.length) updateRawDataTable();
                                console.log('Updated Data Table');
                            }
                        };

                        const links = document.querySelectorAll('.sidebar a');
                        links.forEach(link => {
                            link.addEventListener('click', async (e) => {
                                e.preventDefault();
                                const targetId = link.getAttribute('href').substring(1);
                                console.log(`Navigating to section: ${targetId}`);
                                const timestamp = dateSelect.value + '_' + (timeSelect.options.length > 0 ? timeSelect.value : '2136');
                                if (await validateTimestamp(timestamp)) {
                                    await loadData(timestamp);
                                    updateDropdowns();
                                    updateSection(targetId);
                                } else {
                                    console.warn('Invalid timestamp on navigation:', timestamp);
                                    document.getElementById('historic-error').style.display = 'block';
                                    document.getElementById('historic-error').textContent = 'Invalid data timestamp';
                                }
                            });
                        });

                        const overviewContainer = document.getElementById('overview');
                        overviewContainer.style.display = 'flex';
                        console.log('Initial load: Showing Overview');
                        addKeyboardNavigation();
                    })
                    .catch(error => {
                        console.error('Error loading dates:', error);
                        document.getElementById('historic-error').style.display = 'block';
                        document.getElementById('historic-error').textContent = 'Failed to load date options';
                    });
            } catch (error) {
                console.error('Error in DOMContentLoaded:', error);
            }
        });

        function updateTimeOptions(selectedDate, dates) {
            try {
                const timeSelect = document.getElementById('time-select');
                timeSelect.innerHTML = '';
                const formattedSelectedDate = selectedDate.replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3');
                const availableTimes = dates
                    .filter(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$1-$2-$3') === formattedSelectedDate)
                    .map(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$4:$5'))
                    .sort();
                const uniqueTimes = [...new Set(availableTimes)];
                uniqueTimes.forEach(timePart => {
                    const option = document.createElement('option');
                    option.value = timePart.replace(':', '');
                    option.textContent = timePart;
                    timeSelect.appendChild(option);
                });
                if (timeSelect.options.length > 0) {
                    timeSelect.value = timeSelect.options[0].value;
                    timeSelect.dispatchEvent(new Event('change', { bubbles: true }));
                } else {
                    console.warn('No times available for selected date:', formattedSelectedDate);
                }
                console.log('Time options updated:', uniqueTimes);
            } catch (error) {
                console.error('Error updating time options:', error);
            }
        }
    </script>
</body>
</html>  
