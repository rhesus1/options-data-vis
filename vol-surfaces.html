<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Volatility Surfaces</title>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nouislider@15.6.0/dist/nouislider.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nouislider@15.6.0/dist/nouislider.min.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #1C2526;
            color: #FFFFFF;
            margin: 0;
            padding: 0;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5px;
        }
        .controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }
        select, input {
            padding: 4px;
            background-color: #2E3537;
            color: #FFFFFF;
            border: 1px solid #FFFFFF;
            border-radius: 4px;
        }
        #ticker-search {
            width: 180px;
        }
        #ticker-datalist {
            background-color: #2E3537;
            color: #FFFFFF;
        }
        .nav-link {
            color: #00BFFF;
            text-decoration: none;
            padding: 4px;
            display: inline-block;
        }
        .nav-link:hover {
            text-decoration: underline;
        }
        .plot-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 5px;
            width: 100%;
            max-width: 1000px;
        }
        .plot-container {
            width: 100%;
            height: 600px;
            margin: 5px 0;
        }
        .plot-container h2 {
            margin: 5px 0;
            font-size: 1.2em;
        }
        #error-message {
            color: #FF6666;
            padding: 5px;
            display: none;
        }
        #min-t-slider {
            width: 150px;
        }
        #min-t-value {
            font-size: 0.9em;
        }
        #moneyness-range-slider {
            width: 150px;
            margin: 10px;
        }
        #moneyness-range-values {
            font-size: 0.9em;
        }
        .noUi-handle {
            background: #FFFFFF;
            border: 1px solid #2E3537;
        }
        .noUi-connect {
            background: #00BFFF;
        }
        .noUi-target {
            background: #2E3537;
            border: 1px solid #FFFFFF;
            box-shadow: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div>
            <a href="index.html" class="nav-link">Back to Charts</a>
            <a href="data-table.html" class="nav-link">View Data Table</a>
        </div>
        <div class="controls">
            <label for="source-select">Source: </label>
            <select id="source-select">
                <option value="nasdaq">Nasdaq</option>
                <option value="yfinance" selected>yfinance</option>
            </select>
            <label for="date-select">Date: </label>
            <select id="date-select"></select>
            <label for="time-select">Time: </label>
            <select id="time-select"></select>
            <label for="ticker-search">Ticker: </label>
            <input type="text" id="ticker-search" list="ticker-datalist" placeholder="Search ticker...">
            <datalist id="ticker-datalist"></datalist>
            <label for="min-t-slider">Min T (years): </label>
            <input type="range" id="min-t-slider" min="0" max="5" step="0.1" value="0.5">
            <span id="min-t-value">0.5</span>
            <label for="moneyness-range-slider">Moneyness Range (%): </label>
            <div id="moneyness-range-slider"></div>
            <span id="moneyness-range-values">50 - 200</span>
        </div>
        <div id="error-message">No data available for selected ticker</div>
        <div class="plot-grid">
            <div class="plot-container" id="iv-mid-calls"><h2>IV Mid (Calls)</h2></div>
            <div class="plot-container" id="iv-mid-puts"><h2>IV Mid (Puts)</h2></div>
            <div class="plot-container" id="smoothed-iv-calls"><h2>Smoothed IV (Calls)</h2></div>
            <div class="plot-container" id="smoothed-iv-puts"><h2>Smoothed IV (Puts)</h2></div>
            <div class="plot-container" id="local-vol-calls"><h2>Local Volatility (Calls)</h2></div>
            <div class="plot-container" id="local-vol-puts"><h2>Local Volatility (Puts)</h2></div>
        </div>
    </div>
    <script>
        let data = [];
        let datasetDate = null;
        let maxT = 5;
        let maxMoneyness = 2; // Default, updated in loadData
        let selectedMinT = 0.5; // Default T
        let selectedMinMoneyness = 0.5; // Default min Moneyness
        let selectedMaxMoneyness = 2; // Default max Moneyness
        function parseCSV(csvText) {
            try {
                const result = Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    dynamicTyping: true
                });
                return result.data;
            } catch (error) {
                console.error('Error parsing CSV:', error);
                return [];
            }
        }
        function normalizeDate(dateStr) {
            try {
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) throw new Error('Invalid date');
                return date.toISOString().split('T')[0];
            } catch (error) {
                console.error('Error normalizing date:', dateStr, error);
                return null;
            }
        }
        function calculateTimeToExpiry(expiryDate, referenceDate) {
            try {
                const expiry = new Date(expiryDate);
                const ref = new Date(referenceDate);
                const diffMs = expiry - ref;
                return diffMs / (365 * 24 * 60 * 60 * 1000); // Convert to years
            } catch (error) {
                console.error('Error calculating time to expiry:', error);
                return null;
            }
        }
        function interpolateAlongExpiry(zData, expiryTimes) {
            for (let y = 0; y < zData.length; y++) {
                const row = zData[y];
                const known = [];
                for (let x = 0; x < row.length; x++) {
                    if (row[x] !== null && Number.isFinite(row[x])) {
                        known.push({t: expiryTimes[x], val: row[x], idx: x});
                    }
                }
                if (known.length < 2) continue;
                known.sort((a, b) => a.t - b.t);
                for (let i = 0; i < known.length - 1; i++) {
                    const start = known[i];
                    const end = known[i + 1];
                    const dt = end.t - start.t;
                    if (dt <= 0) continue;
                    for (let idx = start.idx + 1; idx < end.idx; idx++) {
                        const curr_t = expiryTimes[idx];
                        const frac = (curr_t - start.t) / dt;
                        row[idx] = start.val + frac * (end.val - start.val);
                    }
                }
            }
        }
        function interpolateAlongMoneyness(zData, moneynessValues) {
            for (let x = 0; x < zData[0].length; x++) {
                const col = zData.map(row => row[x]);
                const known = [];
                for (let y = 0; y < col.length; y++) {
                    if (col[y] !== null && Number.isFinite(col[y])) {
                        known.push({m: moneynessValues[y], val: col[y], idx: y});
                    }
                }
                if (known.length < 2) continue;
                known.sort((a, b) => a.m - b.m);
                for (let i = 0; i < known.length - 1; i++) {
                    const start = known[i];
                    const end = known[i + 1];
                    const dm = end.m - start.m;
                    if (dm <= 0) continue;
                    for (let idx = start.idx + 1; idx < end.idx; idx++) {
                        const curr_m = moneynessValues[idx];
                        const frac = (curr_m - start.m) / dm;
                        zData[idx][x] = start.val + frac * (end.val - start.val);
                    }
                }
            }
        }
        document.addEventListener('DOMContentLoaded', () => {
            try {
                const dateSelect = document.getElementById('date-select');
                const timeSelect = document.getElementById('time-select');
                const tickerSearch = document.getElementById('ticker-search');
                const sourceSelect = document.getElementById('source-select');
                const minTSlider = document.getElementById('min-t-slider');
                const minTValue = document.getElementById('min-t-value');
                const moneynessSlider = document.getElementById('moneyness-range-slider');
                const moneynessValues = document.getElementById('moneyness-range-values');
                // Initialize noUISlider for Moneyness range
                noUiSlider.create(moneynessSlider, {
                    start: [20, 200],
                    connect: true,
                    range: {
                        'min': 0,
                        'max': 200
                    },
                    step: 10,
                    format: {
                        to: value => Math.round(value),
                        from: value => Number(value)
                    }
                });
                moneynessSlider.noUiSlider.on('update', (values) => {
                    selectedMinMoneyness = values[0] / 100; // Convert to raw Moneyness
                    selectedMaxMoneyness = values[1] / 100;
                    moneynessValues.textContent = `${values[0]} - ${values[1]}`;
                    updatePlots();
                });
                minTSlider.addEventListener('input', () => {
                    selectedMinT = parseFloat(minTSlider.value);
                    minTValue.textContent = selectedMinT.toFixed(1);
                    updatePlots();
                });
                fetch('data/dates.json?v=' + Date.now())
                    .then(response => response.json())
                    .then(dates => {
                        const uniqueDates = [...new Set(dates.map(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$1-$2-$3')))];
                        uniqueDates.forEach(datePart => {
                            const option = document.createElement('option');
                            option.value = datePart.replace(/-/g, '');
                            option.textContent = datePart;
                            dateSelect.appendChild(option);
                        });
                        if (dateSelect.options.length > 0) {
                            dateSelect.value = dateSelect.options[0].value;
                            updateTimeOptions(dateSelect.value, dates);
                            loadData(dateSelect.value + '_' + timeSelect.value);
                        }
                        dateSelect.addEventListener('change', (e) => {
                            updateTimeOptions(e.target.value, dates);
                            loadData(e.target.value + '_' + timeSelect.value);
                        });
                        timeSelect.addEventListener('change', (e) => {
                            loadData(dateSelect.value + '_' + e.target.value);
                        });
                        tickerSearch.addEventListener('change', () => {
                            console.log('Ticker changed to:', tickerSearch.value);
                            updatePlots();
                        });
                        sourceSelect.addEventListener('change', () => {
                            console.log('Data source changed to:', sourceSelect.value);
                            loadData(dateSelect.value + '_' + timeSelect.value);
                        });
                    })
                    .catch(error => console.error('Error loading dates:', error));
            } catch (error) {
                console.error('Error in DOMContentLoaded:', error);
            }
        });
        function updateTimeOptions(selectedDate, dates) {
            try {
                const timeSelect = document.getElementById('time-select');
                timeSelect.innerHTML = '';
                const formattedSelectedDate = selectedDate.replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3');
                const availableTimes = dates
                    .filter(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$1-$2-$3') === formattedSelectedDate)
                    .map(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$4:$5'));
                const uniqueTimes = [...new Set(availableTimes)];
                uniqueTimes.forEach(timePart => {
                    const option = document.createElement('option');
                    option.value = timePart.replace(':', '');
                    option.textContent = timePart;
                    timeSelect.appendChild(option);
                });
                if (timeSelect.options.length > 0) timeSelect.value = timeSelect.options[0].value;
                console.log('Time options updated:', uniqueTimes);
            } catch (error) {
                console.error('Error updating time options:', error);
            }
        }
        function loadData(timestamp) {
            try {
                const source = document.getElementById('source-select').value;
                const prefix = source === 'yfinance' ? 'yfinance_' : '';
                console.log(`Loading data for timestamp: ${timestamp}, source: ${source}`);
                datasetDate = new Date(timestamp.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$1-$2-$3'));
                fetch(`data/processed_${prefix}${timestamp}.csv?v=` + Date.now())
                    .then(response => response.text())
                    .then(csvText => {
                        data = parseCSV(csvText);
                        console.log(`Processed ${source} data loaded:`, data);
                        // Calculate max T
                        maxT = data.reduce((max, item) => {
                            const t = calculateTimeToExpiry(item.Expiry, datasetDate);
                            return t !== null && Number.isFinite(t) ? Math.max(max, t) : max;
                        }, 0);
                        maxT = Math.ceil(maxT * 10) / 10; // Round up to nearest 0.1
                        // Update T slider, preserving selected value or default to 0.2
                        const minTSlider = document.getElementById('min-t-slider');
                        minTSlider.max = maxT;
                        minTSlider.value = Math.min(selectedMinT, maxT, 0.5);
                        selectedMinT = parseFloat(minTSlider.value) || 0.5;
                        document.getElementById('min-t-value').textContent = selectedMinT.toFixed(1);
                        console.log('Max T set to:', maxT, 'Selected T:', selectedMinT);
                        // Calculate max Moneyness
                        maxMoneyness = data.reduce((max, item) => {
                            return Number.isFinite(item.Moneyness) ? Math.max(max, item.Moneyness) : max;
                        }, 0);
                        maxMoneyness = Math.ceil(maxMoneyness * 100) / 100; // Round up to nearest 0.01
                        // Update Moneyness slider, preserving selected values or default to [20, 200]
                        const moneynessSlider = document.getElementById('moneyness-range-slider');
                        const defaultMinMoneyness = 50;
                        const defaultMaxMoneyness = 200;
                        const newMinMoneyness = selectedMinMoneyness * 100 > 0 ? Math.min(selectedMinMoneyness * 100, maxMoneyness * 100, defaultMinMoneyness) : defaultMinMoneyness;
                        const newMaxMoneyness = selectedMaxMoneyness * 100 > 0 ? Math.min(selectedMaxMoneyness * 100, maxMoneyness * 100, defaultMaxMoneyness) : Math.min(maxMoneyness * 100, defaultMaxMoneyness);
                        moneynessSlider.noUiSlider.updateOptions({
                            range: {
                                'min': 0,
                                'max': maxMoneyness * 100
                            },
                            start: [newMinMoneyness, newMaxMoneyness]
                        });
                        selectedMinMoneyness = newMinMoneyness / 100;
                        selectedMaxMoneyness = newMaxMoneyness / 100;
                        document.getElementById('moneyness-range-values').textContent = `${newMinMoneyness} - ${newMaxMoneyness}`;
                        console.log('Max Moneyness set to:', maxMoneyness, 'Selected Moneyness:', [selectedMinMoneyness, selectedMaxMoneyness]);
                        populateTickerSearch();
                        updatePlots();
                    })
                    .catch(error => {
                        console.error(`Error loading processed ${source} data:`, error);
                        document.getElementById('error-message').style.display = 'block';
                    });
            } catch (error) {
                console.error('Error in loadData:', error);
            }
        }
        function populateTickerSearch() {
            try {
                const tickerSearch = document.getElementById('ticker-search');
                const tickerDatalist = document.getElementById('ticker-datalist');
                tickerDatalist.innerHTML = '';
                const uniqueTickers = [...new Set(data.map(item => item.Ticker))]
                    .filter(val => val).sort();
                uniqueTickers.forEach(val => {
                    const option = document.createElement('option');
                    option.value = val;
                    tickerDatalist.appendChild(option);
                });
                if (uniqueTickers.includes('COIN')) {
                    tickerSearch.value = 'COIN';
                } else if (uniqueTickers.length > 0) {
                    tickerSearch.value = uniqueTickers[0];
                }
                console.log('Ticker search populated, default:', tickerSearch.value);
            } catch (error) {
                console.error('Error populating ticker search:', error);
            }
        }
        function prepareSurfaceData(filteredData, zKey) {
            try {
                const tFilteredData = filteredData.filter(item => {
                    const t = calculateTimeToExpiry(item.Expiry, datasetDate);
                    return t !== null && Number.isFinite(t) && t >= selectedMinT &&
                           item.Moneyness >= selectedMinMoneyness && item.Moneyness <= selectedMaxMoneyness;
                });
                const moneynessValues = [...new Set(tFilteredData.map(item => Math.round(item.Moneyness * 10) * 0.1))]
                    .filter(val => !isNaN(val)).sort((a, b) => a - b);
                const expiryValues = [...new Set(tFilteredData.map(item => normalizeDate(item.Expiry)))]
                    .filter(val => val).sort();
                const zData = [];
                moneynessValues.forEach(() => zData.push(new Array(expiryValues.length).fill(null)));
                tFilteredData.forEach(item => {
                    const moneynessIndex = moneynessValues.indexOf(Math.round(item.Moneyness * 10) * 0.1);
                    const expiryIndex = expiryValues.indexOf(normalizeDate(item.Expiry));
                    if (moneynessIndex >= 0 && expiryIndex >= 0 && Number.isFinite(item[zKey])) {
                        zData[moneynessIndex][expiryIndex] = item[zKey] * 100;
                    }
                });
                // Perform interpolation to fill gaps
                const expiryTimes = expiryValues.map(date => calculateTimeToExpiry(date, datasetDate));
                interpolateAlongExpiry(zData, expiryTimes);
                interpolateAlongMoneyness(zData, moneynessValues);
                const zValues = zData.flat().filter(v => Number.isFinite(v));
                const minZ = zValues.length > 0 ? Math.min(...zValues) : 0;
                const maxZ = zValues.length > 0 ? Math.max(...zValues) : 0;
                return {
                    x: expiryValues,
                    y: moneynessValues.map(val => val * 100),
                    z: zData,
                    minZ: minZ,
                    maxZ: maxZ
                };
            } catch (error) {
                console.error('Error preparing surface data:', error);
                return { x: [], y: [], z: [], minZ: 0, maxZ: 0 };
            }
        }
        function updatePlots() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const filteredData = data.filter(item => item.Ticker === selectedTicker);
                console.log('Updating plots for ticker:', selectedTicker, 'Data size:', filteredData.length);
                document.getElementById('error-message').style.display = filteredData.length === 0 ? 'block' : 'none';
                const plotConfigs = [
                    {
                        id: 'iv-mid-calls',
                        title: 'IV Mid (Calls)',
                        data: filteredData.filter(item => item.Type === 'Call'),
                        zKey: 'IV_mid'
                    },
                    {
                        id: 'iv-mid-puts',
                        title: 'IV Mid (Puts)',
                        data: filteredData.filter(item => item.Type === 'Put'),
                        zKey: 'IV_mid'
                    },
                    {
                        id: 'smoothed-iv-calls',
                        title: 'Smoothed IV (Calls)',
                        data: filteredData.filter(item => item.Type === 'Call'),
                        zKey: 'Smoothed_IV'
                    },
                    {
                        id: 'smoothed-iv-puts',
                        title: 'Smoothed IV (Puts)',
                        data: filteredData.filter(item => item.Type === 'Put'),
                        zKey: 'Smoothed_IV'
                    },
                    {
                        id: 'local-vol-calls',
                        title: 'Local Volatility (Calls)',
                        data: filteredData.filter(item => item.Type === 'Call' && item['Call Local Vol'] > 0),
                        zKey: 'Call Local Vol'
                    },
                    {
                        id: 'local-vol-puts',
                        title: 'Local Volatility (Puts)',
                        data: filteredData.filter(item => item.Type === 'Put' && item['Put Local Vol'] > 0),
                        zKey: 'Put Local Vol'
                    }
                ];
                plotConfigs.forEach(config => {
                    const surfaceData = prepareSurfaceData(config.data, config.zKey);
                    const minZ = surfaceData.minZ;
                    const maxZ = surfaceData.maxZ;
                    const colorscale = [
                        [0, 'rgb(0,0,255)'], // Blue at minZ
                        [0.25, 'rgb(0,255,255)'], // Cyan at 25% of range
                        [0.5, 'rgb(0,255,0)'], // Green at 50% of range
                        [0.75, 'rgb(255,255,0)'], // Yellow at 75% of range
                        [1, 'rgb(255,0,0)'] // Red at maxZ
                    ];
                    // Evenly spaced ticks
                    const numTicks = 6;
                    const tickInterval = (maxZ - minZ) / (numTicks - 1);
                    const tickvals = [];
                    const ticktext = [];
                    for (let i = 0; i < numTicks; i++) {
                        const val = minZ + i * tickInterval;
                        tickvals.push(val);
                        ticktext.push(val.toFixed(0));
                    }
                    const layout = {
                        title: {
                            text: config.title,
                            font: { color: '#FFFFFF', size: 16 },
                            y: 0.95
                        },
                        scene: {
                            xaxis: {
                                title: 'Expiry',
                                type: 'date',
                                tickformat: '%Y-%m-%d',
                                color: '#FFFFFF',
                                range: surfaceData.x.length > 0 ? [surfaceData.x[0], surfaceData.x[surfaceData.x.length - 1]] : undefined
                            },
                            yaxis: {
                                title: 'Moneyness (%)',
                                range: [selectedMinMoneyness * 100, selectedMaxMoneyness * 100],
                                color: '#FFFFFF'
                            },
                            zaxis: {
                                title: 'Volatility (%)',
                                color: '#FFFFFF',
                                range: [minZ, maxZ],
                                autorange: false
                            },
                            aspectmode: 'manual',
                            aspectratio: {
                                x: 1,
                                y: 1,
                                z: 0.5
                            },
                            bgcolor: '#1C2526'
                        },
                        margin: { l: 30, r: 30, t: 50, b: 30 },
                        paper_bgcolor: '#1C2526',
                        plot_bgcolor: '#1C2526'
                    };
                    Plotly.newPlot(config.id, [{
                        type: 'surface',
                        x: surfaceData.x,
                        y: surfaceData.y,
                        z: surfaceData.z,
                        colorscale: colorscale,
                        cmin: minZ,
                        cmax: maxZ,
                        showscale: true,
                        colorbar: {
                            title: 'Volatility (%)',
                            titleside: 'right',
                            titlefont: { color: '#FFFFFF' },
                            tickfont: { color: '#FFFFFF' },
                            tickvals: tickvals,
                            ticktext: ticktext
                        }
                    }], layout);
                });
            } catch (error) {
                console.error('Error updating plots:', error);
                document.getElementById('error-message').style.display = 'block';
            }
        }
    </script>
</body>
</html>
