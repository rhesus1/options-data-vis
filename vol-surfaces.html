<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Volatility Surfaces</title>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #1C2526;
            color: #FFFFFF;
            margin: 0;
            padding: 0;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5px;
        }
        .controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }
        select, input {
            padding: 4px;
            background-color: #2E3537;
            color: #FFFFFF;
            border: 1px solid #FFFFFF;
            border-radius: 4px;
        }
        #ticker-search {
            width: 180px;
        }
        #ticker-datalist {
            background-color: #2E3537;
            color: #FFFFFF;
        }
        .nav-link {
            color: #00BFFF;
            text-decoration: none;
            padding: 4px;
            display: inline-block;
        }
        .nav-link:hover {
            text-decoration: underline;
        }
        .plot-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 5px;
            width: 100%;
            max-width: 1000px;
        }
        .plot-container {
            width: 100%;
            height: 600px;
            margin: 5px 0;
        }
        .plot-container h2 {
            margin: 5px 0;
            font-size: 1.2em;
        }
        #error-message {
            color: #FF6666;
            padding: 5px;
            display: none;
        }
        #min-t-slider {
            width: 150px;
        }
        #min-t-value {
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div>
            <a href="index.html" class="nav-link">Back to Charts</a>
            <a href="data-table.html" class="nav-link">View Data Table</a>
        </div>
        <div class="controls">
            <label for="source-select">Source: </label>
            <select id="source-select">
                <option value="nasdaq" selected>Nasdaq</option>
                <option value="yfinance">yfinance</option>
            </select>
            <label for="date-select">Date: </label>
            <select id="date-select"></select>
            <label for="time-select">Time: </label>
            <select id="time-select"></select>
            <label for="ticker-search">Ticker: </label>
            <input type="text" id="ticker-search" list="ticker-datalist" placeholder="Search ticker...">
            <datalist id="ticker-datalist"></datalist>
            <label for="min-t-slider">Min T (years): </label>
            <input type="range" id="min-t-slider" min="0" max="5" step="0.1" value="0">
            <span id="min-t-value">0.0</span>
        </div>
        <div id="error-message">No data available for selected ticker</div>
        <div class="plot-grid">
            <div class="plot-container" id="iv-mid-calls"><h2>IV Mid (Calls)</h2></div>
            <div class="plot-container" id="iv-mid-puts"><h2>IV Mid (Puts)</h2></div>
            <div class="plot-container" id="smoothed-iv-calls"><h2>Smoothed IV (Calls)</h2></div>
            <div class="plot-container" id="smoothed-iv-puts"><h2>Smoothed IV (Puts)</h2></div>
            <div class="plot-container" id="local-vol-calls"><h2>Local Volatility (Calls)</h2></div>
            <div class="plot-container" id="local-vol-puts"><h2>Local Volatility (Puts)</h2></div>
        </div>
    </div>
    <script>
        let data = [];
        let datasetDate = null;
        let maxT = 5;

        function parseCSV(csvText) {
            try {
                const result = Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    dynamicTyping: true
                });
                return result.data;
            } catch (error) {
                console.error('Error parsing CSV:', error);
                return [];
            }
        }

        function normalizeDate(dateStr) {
            try {
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) throw new Error('Invalid date');
                return date.toISOString().split('T')[0];
            } catch (error) {
                console.error('Error normalizing date:', dateStr, error);
                return null;
            }
        }

        function calculateTimeToExpiry(expiryDate, referenceDate) {
            try {
                const expiry = new Date(expiryDate);
                const ref = new Date(referenceDate);
                const diffMs = expiry - ref;
                return diffMs / (365 * 24 * 60 * 60 * 1000); // Convert to years
            } catch (error) {
                console.error('Error calculating time to expiry:', error);
                return null;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            try {
                const dateSelect = document.getElementById('date-select');
                const timeSelect = document.getElementById('time-select');
                const tickerSearch = document.getElementById('ticker-search');
                const sourceSelect = document.getElementById('source-select');
                const minTSlider = document.getElementById('min-t-slider');
                const minTValue = document.getElementById('min-t-value');

                minTSlider.addEventListener('input', () => {
                    minTValue.textContent = parseFloat(minTSlider.value).toFixed(1);
                    updatePlots();
                });

                fetch('data/dates.json?v=' + Date.now())
                    .then(response => response.json())
                    .then(dates => {
                        const uniqueDates = [...new Set(dates.map(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$1-$2-$3')))];
                        uniqueDates.forEach(datePart => {
                            const option = document.createElement('option');
                            option.value = datePart.replace(/-/g, '');
                            option.textContent = datePart;
                            dateSelect.appendChild(option);
                        });
                        if (dateSelect.options.length > 0) {
                            dateSelect.value = dateSelect.options[0].value;
                            updateTimeOptions(dateSelect.value, dates);
                            loadData(dateSelect.value + '_' + timeSelect.value);
                        }
                        dateSelect.addEventListener('change', (e) => {
                            updateTimeOptions(e.target.value, dates);
                            loadData(e.target.value + '_' + timeSelect.value);
                        });
                        timeSelect.addEventListener('change', (e) => {
                            loadData(dateSelect.value + '_' + e.target.value);
                        });
                        tickerSearch.addEventListener('change', () => {
                            console.log('Ticker changed to:', tickerSearch.value);
                            updatePlots();
                        });
                        sourceSelect.addEventListener('change', () => {
                            console.log('Data source changed to:', sourceSelect.value);
                            loadData(dateSelect.value + '_' + timeSelect.value);
                        });
                    })
                    .catch(error => console.error('Error loading dates:', error));
            } catch (error) {
                console.error('Error in DOMContentLoaded:', error);
            }
        });

        function updateTimeOptions(selectedDate, dates) {
            try {
                const timeSelect = document.getElementById('time-select');
                timeSelect.innerHTML = '';
                const formattedSelectedDate = selectedDate.replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3');
                const availableTimes = dates
                    .filter(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$1-$2-$3') === formattedSelectedDate)
                    .map(date => date.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$4:$5'));
                const uniqueTimes = [...new Set(availableTimes)];
                uniqueTimes.forEach(timePart => {
                    const option = document.createElement('option');
                    option.value = timePart.replace(':', '');
                    option.textContent = timePart;
                    timeSelect.appendChild(option);
                });
                if (timeSelect.options.length > 0) timeSelect.value = timeSelect.options[0].value;
                console.log('Time options updated:', uniqueTimes);
            } catch (error) {
                console.error('Error updating time options:', error);
            }
        }

        function loadData(timestamp) {
            try {
                const source = document.getElementById('source-select').value;
                const prefix = source === 'yfinance' ? 'yfinance_' : '';
                console.log(`Loading data for timestamp: ${timestamp}, source: ${source}`);
                datasetDate = new Date(timestamp.replace(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})/, '$1-$2-$3'));

                fetch(`data/processed_${prefix}${timestamp}.csv?v=` + Date.now())
                    .then(response => response.text())
                    .then(csvText => {
                        data = parseCSV(csvText);
                        console.log(`Processed ${source} data loaded:`, data);
                        // Calculate max T
                        maxT = data.reduce((max, item) => {
                            const t = calculateTimeToExpiry(item.Expiry, datasetDate);
                            return t !== null && Number.isFinite(t) ? Math.max(max, t) : max;
                        }, 0);
                        maxT = Math.ceil(maxT * 10) / 10; // Round up to nearest 0.1
                        const minTSlider = document.getElementById('min-t-slider');
                        minTSlider.max = maxT;
                        minTSlider.value = 0;
                        document.getElementById('min-t-value').textContent = '0.0';
                        console.log('Max T set to:', maxT);
                        populateTickerSearch();
                        updatePlots();
                    })
                    .catch(error => {
                        console.error(`Error loading processed ${source} data:`, error);
                        document.getElementById('error-message').style.display = 'block';
                    });
            } catch (error) {
                console.error('Error in loadData:', error);
            }
        }

        function populateTickerSearch() {
            try {
                const tickerSearch = document.getElementById('ticker-search');
                const tickerDatalist = document.getElementById('ticker-datalist');
                tickerDatalist.innerHTML = '';
                const uniqueTickers = [...new Set(data.map(item => item.Ticker))]
                    .filter(val => val).sort();
                uniqueTickers.forEach(val => {
                    const option = document.createElement('option');
                    option.value = val;
                    tickerDatalist.appendChild(option);
                });
                if (uniqueTickers.includes('COIN')) {
                    tickerSearch.value = 'COIN';
                } else if (uniqueTickers.length > 0) {
                    tickerSearch.value = uniqueTickers[0];
                }
                console.log('Ticker search populated, default:', tickerSearch.value);
            } catch (error) {
                console.error('Error populating ticker search:', error);
            }
        }

        function prepareSurfaceData(filteredData, zKey) {
            try {
                const minT = parseFloat(document.getElementById('min-t-slider').value);
                // Filter by minimum time to expiry
                const tFilteredData = filteredData.filter(item => {
                    const t = calculateTimeToExpiry(item.Expiry, datasetDate);
                    return t !== null && Number.isFinite(t) && t >= minT;
                });

                const moneynessValues = [...new Set(tFilteredData.map(item => Math.round(item.Moneyness * 100 / 10) * 0.1))]
                    .filter(val => !isNaN(val)).sort((a, b) => a - b);
                const expiryValues = [...new Set(tFilteredData.map(item => normalizeDate(item.Expiry)))]
                    .filter(val => val).sort();
                const zData = [];
                moneynessValues.forEach(() => zData.push(new Array(expiryValues.length).fill(null)));

                tFilteredData.forEach(item => {
                    const moneynessIndex = moneynessValues.indexOf(Math.round(item.Moneyness * 100 / 10) * 0.1);
                    const expiryIndex = expiryValues.indexOf(normalizeDate(item.Expiry));
                    if (moneynessIndex >= 0 && expiryIndex >= 0 && Number.isFinite(item[zKey])) {
                        zData[moneynessIndex][expiryIndex] = item[zKey] * 100;
                    }
                });

                const zValues = zData.flat().filter(v => Number.isFinite(v));
                const minZ = zValues.length > 0 ? Math.min(...zValues) : 0;
                const maxZ = zValues.length > 0 ? Math.max(...zValues) : 0;

                return {
                    x: expiryValues,
                    y: moneynessValues.map(val => val * 100),
                    z: zData,
                    minZ: minZ,
                    maxZ: maxZ
                };
            } catch (error) {
                console.error('Error preparing surface data:', error);
                return { x: [], y: [], z: [], minZ: 0, maxZ: 0 };
            }
        }

        function updatePlots() {
            try {
                const selectedTicker = document.getElementById('ticker-search').value.toUpperCase();
                const filteredData = data.filter(item => item.Ticker === selectedTicker);
                console.log('Updating plots for ticker:', selectedTicker, 'Data size:', filteredData.length);

                document.getElementById('error-message').style.display = filteredData.length === 0 ? 'block' : 'none';

                const plotConfigs = [
                    {
                        id: 'iv-mid-calls',
                        title: 'IV Mid (Calls)',
                        data: filteredData.filter(item => item.Type === 'Call'),
                        zKey: 'IV_mid'
                    },
                    {
                        id: 'iv-mid-puts',
                        title: 'IV Mid (Puts)',
                        data: filteredData.filter(item => item.Type === 'Put'),
                        zKey: 'IV_mid'
                    },
                    {
                        id: 'smoothed-iv-calls',
                        title: 'Smoothed IV (Calls)',
                        data: filteredData.filter(item => item.Type === 'Call'),
                        zKey: 'Smoothed_IV'
                    },
                    {
                        id: 'smoothed-iv-puts',
                        title: 'Smoothed IV (Puts)',
                        data: filteredData.filter(item => item.Type === 'Put'),
                        zKey: 'Smoothed_IV'
                    },
                    {
                        id: 'local-vol-calls',
                        title: 'Local Volatility (Calls)',
                        data: filteredData.filter(item => item.Type === 'Call' && item['Call Local Vol'] > 0),
                        zKey: 'Call Local Vol'
                    },
                    {
                        id: 'local-vol-puts',
                        title: 'Local Volatility (Puts)',
                        data: filteredData.filter(item => item.Type === 'Put' && item['Put Local Vol'] > 0),
                        zKey: 'Put Local Vol'
                    }
                ];

                plotConfigs.forEach(config => {
                    const surfaceData = prepareSurfaceData(config.data, config.zKey);
                    const maxZ = surfaceData.maxZ;
                    const minZ = surfaceData.minZ;
                    const colorMax = Math.min(maxZ, 200); // Cap red at 200% for jet colorscale
                    const colorscale = [
                        [0, 'rgb(0,0,255)'],                           // Blue at minZ
                        [(50 - minZ) / (colorMax - minZ), 'rgb(0,255,255)'], // Cyan at 50
                        [(75 - minZ) / (colorMax - minZ), 'rgb(0,128,128)'], // Teal at 75
                        [(100 - minZ) / (colorMax - minZ), 'rgb(0,255,0)'], // Green at 100
                        [(125 - minZ) / (colorMax - minZ), 'rgb(128,255,0)'], // Lime at 125
                        [(150 - minZ) / (colorMax - minZ), 'rgb(255,255,0)'], // Yellow at 150
                        [(colorMax - minZ) / (colorMax - minZ), 'rgb(255,0,0)'], // Red at colorMax (≤200)
                        [1, maxZ > 200 ? 'rgb(255,0,255)' : 'rgb(255,0,0)'] // Magenta if maxZ > 200, else red
                    ].filter(point => point[0] >= 0 && point[0] <= 1); // Ensure valid range

                    const tickvals = [minZ, 50, 75, 100, 125, 150, maxZ]
                        .filter(v => v >= minZ && v <= maxZ && Number.isFinite(v));
                    const ticktext = tickvals.map(v => v.toFixed(0));

                    const layout = {
                        title: {
                            text: config.title,
                            font: { color: '#FFFFFF', size: 16 },
                            y: 0.95
                        },
                        scene: {
                            xaxis: {
                                title: 'Expiry',
                                type: 'date',
                                tickformat: '%Y-%m-%d',
                                color: '#FFFFFF',
                                range: surfaceData.x.length > 0 ? [surfaceData.x[0], surfaceData.x[surfaceData.x.length - 1]] : undefined
                            },
                            yaxis: {
                                title: 'Moneyness (%)',
                                range: [0, 200],
                                color: '#FFFFFF'
                            },
                            zaxis: {
                                title: 'Volatility (%)',
                                color: '#FFFFFF',
                                range: [minZ, maxZ],
                                autorange: false
                            },
                            bgcolor: '#1C2526'
                        },
                        margin: { l: 30, r: 30, t: 50, b: 30 },
                        paper_bgcolor: '#1C2526',
                        plot_bgcolor: '#1C2526'
                    };

                    Plotly.newPlot(config.id, [{
                        type: 'surface',
                        x: surfaceData.x,
                        y: surfaceData.y,
                        z: surfaceData.z,
                        colorscale: colorscale,
                        cmin: minZ,
                        cmax: maxZ,
                        showscale: true,
                        colorbar: {
                            title: 'Volatility (%)',
                            titleside: 'right',
                            titlefont: { color: '#FFFFFF' },
                            tickfont: { color: '#FFFFFF' },
                            tickvals: tickvals,
                            ticktext: ticktext
                        }
                    }], layout);
                });
            } catch (error) {
                console.error('Error updating plots:', error);
                document.getElementById('error-message').style.display = 'block';
            }
        }
    </script>
</body>
</html>
